[자바 해바라기 정리] 
0 들어가며
자바가 나온지 약 25년 , 안드로이드를 사용하는 핸드폰의
애플리케이션 에서부터 전자정부 웹 즉 엔터프라이즈 까지
대부분의 IT 분야에서 사용되고 전 세계에서 가장 활용도 높은
프로그래밍 언어로 주목 받고 있다.

자바의 기본 문법 많이 쉬운 편이다. 객체지향적인 개념 중요.
객체지향이란 실생활을 프로그래밍에 반영하면서 시작.
기초 문법, 객체지향 개념을 최대한 실생활과 연결하여 쉽게 접근.

프로그래밍 공부 쉽게 접근 방법.
수다 떨기. -> 많이 타이핑 해보기
문법 오류 겁내지 말고 차분히 보기, 단, 영어이지만,
조금만 노력하면 쉽게 이해 가능.

어떻게 공부?
2-5장은 변수 , 연산자 , 제어문 , 배열
: 젓가락질하는 방법 배우기 정도. 완벽 이해.

6장 7장 객체 , 클래스 , 추상화 , 데이터 은닉과 
보호, 상속, 다형성 등 객체지향 의 핵심적인 내용
: 밥 수준. -> 반복 정독

8장 - 10장, 클래스 이외에 자바 애플리케이션 구성요소나
예외처리, 내부 클래스, 람다표현식 등 
:빠져서 안되는 필수 프로그래밍 기법 김치 정도

나머지 부분은 자바에서 제공하는 API를 배우는 부분 
: 양념정도, 

11장 lang 패키지, 12장 유용한 클래스들과 
13장 컬렉션 프레임워크 는 소금 레벨의 양념.

대부분 메서드 사용법이기 때문에 외우려고 하기보다
이런 것이 있구나. 정도로 기억하고 있다가
필요한 상황에서 찾아 볼수 있게,

14장 스레드 15장 I-O, 16장 스트림
매번 쓰는 양념은 아니다. 
이 부분은 어렵기도 하고, 자주 사용되지도 않는다.
(상황에 따라 다름.)
해당 기능이 필요할 때 그때그때 공부하고 사용하기.
웹 프로그래밍 -> 스레드나 I-O 를 접할 기회가 거의 없다.
그러나, 안드로이드 에서는 스레드가 필수적.

저자 카페: 조용준님.
https://cafe.naver.com/lifecoding 
모르면 저자에게 질문.

===================================
[1 자바 첫걸음]
1.자바 언어 소개

1.1 자바란?

오라클(Oracle : 과거 Sun Microsystems)에서 
개발한 객체지향 프로그래밍 언어.  1996년 발표.
1990년대 말 인터넷 활성화 시점과 맞물려 웹 환경에 
가장 적합한 언어로 인식. 많은 인기 .
웹, 데스크톱 애플리케이션, 안드로이드 모바일 애플리케이션
거의 모든 프로그래밍 분야에 사용 

웹 사이트 검색 빈도수 로 순위 채점 http://www.tiobe.com 발표 
웹 분야에서 대체할 만한 다른 언어가 없어서 꾸준히 인기 유지 할 듯. 

처음 자바 발표 당시, 테스트 개발자는 30명쯤. 
현재, 전 세계 9백만명 이상의 개발자 있고, 
엔터프라이즈 애플리케이션 시장의 97% 이상 차지.

계속 업그레이드 중, 성능 개선 및 기능 추가.
2018년 3월 자바 10 버전 까지 발표 
1.5 버전 부터 -> 자바5 처럼 부름. 

자바 버전별 주요 특징 
내부 버전 : 호칭 : 발표 연도 : 특징 
1.0 : 자바 1.0 : 1996 : 애플릿 기반 
1.1 : 자바 1.1 : 1997 : 내부 클래스, RMI, JDBC, Java Beans
1.2 : 자바 2 : 1998 : Swing, 컬렉션 프레임워크
1.3 : 자바 2 버전 1.4 : 2000 : JVM 개선, JNDI 
1.4 : 자바 2 버전 1.4 : 2002 : assertion, 정규표현식, 자바 웹 스타트 
1.5 : 자바 5.0 : 2004 : 제너릭, for-each 반복문 , 가변인수, 오토박싱,
enum, annotation
1.6 : 자바 6 : 2006 : 컬렉션 프레임워크 개선 
1.7 : 자바 7 : 2011 : <> 연산자, try - with - resources, switch 개선 
1.8 : 자바 8 : 2013 : Lambda, 날짜-시간 관리 강화, 스트림 API
1.9 : 자바 9 : 2017 : jigsaw 프레임워크, JShell, 
컴파일러 개선, 스트림 API 강화
1.10 : 자바 10 : 2018 : 로컬변수에 대한 타입 추정, 내부적인 성능 개선 

특히, 버전 중 1.1 , 1.2 , 1.5 , 1.8 의 업데이트 자바 
프로그래밍 방식에 많은 변화를 준 메이저 업데이트로 평가 . 

새버전이 나왔다고 그 버전을 바로 학습해서 사용하는 건 비추.
실무에서는 새 버전 사용이 보수적이다. 혹시, 모를 오류 및 버그 부담.

plumbr.io 의 발표에 따르면 자바 8은 2013 발표 되어도, 
2016년까지 가장 많이 사용된 버전은 자바 7,
2017 년 들어서야 비로소 8이 주버전으로 사용. 
실제, 현업에서는 프로젝트에 사용되는 자바의 버전이 낮아서 
최신의 라이브러리를 사용하는데 어려움을 겪음.

8부터 10까지의 공통된 내용을 기준으로 설명할 계획. 

9와 10은 부록. 필요할 때 찾아 보기.
----------------------------------------------------

1.2 자바 언어의 특징

운영체제 독립적인 언어이다.
자바의 특징을 나타내는 문장 " Write Once, Run Anywhere".
즉, 프로그램은 한번만 작성하고 어디서나 동작 시킨다.
이를 위해 JVM 가상 머신 개념 도입.
OS와 통신하지 않고, OS위에 설치된 JVM과 통신. 독립적.

객체지향 언어이다. 
현실 세계를 모델링해서 프로그래밍하는 언어로 다른 언어에
비해 개발자가 상대적으로 이해하기 쉽다. 
OOP is A P I E !
Object Oriented Programming.
Abstraction (추상화)
Polymorphism (다형성)
Inheritance (상속)
Encapsulation (캡슐화)

상대적으로 배우기 쉬운 언어이다.
C 언어가 자바보다 오래되고, 아직도 활발히 개발이 되고 있다. 
C 언어의 어려운 단원 포인터, 메모리 관리.
자바에서는 GC(Garbage Collector)이라는 개념을 이용 
메모리 관리 자동으로 처리. 포인터를 이용한 연산은 지원 안함.

매우 다양한 API 제공된다.
프로그래밍이란 필요한 기능을 컴퓨터를 통해서 구현하는 일.
이 과정에서 도움을 주는 다양한 도구가 있다면 편할 것이다. 
밀가루 와 레시피(recipe)를 제공한다면 훨씬 쉽다.
이것을 프로그래밍에서 API(Application Programming Interface)
라 한다. 
API 에 대한 사용법을 잘 익히는 것이 중요.
기본 시스템 라이브러리 뿐 아니라, 다양한 오픈소스 라이브러리가
API로 제공된다. 참조해서 개발 기간을 단축하고, 
신뢰성 있는 프로그래밍 가능. 
문제는 너무 많다는 점. 
많은 API에 대한 해답은 구글링. 

람다를 이용한 함수형 프로그래밍 지원,
손쉬운 멀티스레드 프로그래밍 지원,
객체의 동적 로딩,
네트워크 및 원활한 분산 처리 지원등. 

(1) JVM (Java Virtual Machine)
자바가 운영체제 독립적으로 동작 할수 있는 이유.
C 언어의 예 
C 언어는 텍스트로 소스 코드를 작성하고 컴파일러를 이용해서 
컴파일(compile)과 링킹(linking) 과정을 거친다.
그 결과물은 바이너리로 흔히 실행 파일이라 한다. 
이 바이너리 실행하면 OS(Operating System)
운영체제, 플랫폼) 가 기계어로 번역해서 
CPU (Central Processing Unit : 중앙 처리장치)
에 전달한다. 
문제는 OS 마다 이 바이너리 를 해석하는 방식이 다르다는 점. 
맥에서 컴파일된 결과는 맥에서 만 유효하고,
윈도우에서는 유효하지 않다. 
이것을 플랫폼 종속적이라 한다. 
반면, 자바는 OS에서 JVM이라는 가상 머신이 설치 되어야 한다. 
C 언어와 마찬가지로 자바 역시 텍스트로 만든 소스 코드를
javac 명령을 이용해 컴파일하면 확장자가 class 인 byte 코드가 생성. 
이 byte 코드를 실행하기 위해서 java 명령을 사용. 
java 명령은 인터프리터로서 byte 코드를 한 줄 씩 해석해서 
JVM 내에서 실행 한다. 
OS 와 통신하지 않기 때문에 기본적으로 플랫폼에 독립적이다. 
JVM 이 있기 때문에, "Write Once, Run Anywhere" 가능. 

(2) 가비지 컬렉터 (Garbage Collector: GC) 
쓰레기를 모아 주는 것. 
쓰레기: 프로그램에서 사용하고 난 메모리 공간.
프로그램들은 OS로 부터 일부 메모리를 할당받아서 사용.
이 메모리 공간에 어떤 값을 저장해 사용하고, 더는 필요 없어지면
해당 메모리 공간을 비워서 다른 데이터를 저장 할 수 있게 해야 한다. 
이 과정이 없다면 점차 메모리 부족 오류가 발생하고, 프로그램은 비정상적
으로 종료 된다. 따라서, 메모리 관리가 아주 중요한 부분이고,
초보 개발자가 놓치기 쉽다. 
그래서, 자바는 가비지 컬렉터가 내장되어 , 사용하지 않는 
메모리 공간을 자동으로 회수함.
프로그래머가 메모리 관리로부터 많이 자유로워진다. 
GC는 시스템이 한가할 때나 메모리가 부족한 위급 상황,
JVM 구현에 따라 알아서 동작.
프로그래머가 임의로 동작 시키지 않는다. 

----------------------------------------------------
2. 개발 환경 구축
자바 프로그램 개발 하기 위해서 JDK(Java Development Kit)
자바 개발 키트가 설치 되어야 한다. 
JDK는 JVM, 개발에 필요한 컴파일러, 개발도구와 
기본 시스템 라이브러리, JRE(Java Runtime Environment)
자바 구동 환경이 포함. 
JRE에는 JVM, 기본 시스템 라이브러리 포함.
개발을 위해서는 JDK가 필요하고,
이미 개발된 프로그램을 단순히 실행만 하려는 경우는 JRE만 있으면 된다. 

2.1 자바 JDK의 종류
자바는 개발 분야에 따라 크게 
Java SE, Java EE, Java Embedded 로 나뉜다. 
Java SE(Standard Edition)
자바 언어의 핵심 기능을 제공한다. 
이 책에서 학습하는 내용도 이것이다. 
Java EE(Enterprise Edition) 
Java SE 플랫폼 위에 구축하고, 기업용 애플리케이션
제작에 필요한 도구, 라이브러리를 제공한다. 
Java Embedded
핸드폰 등 모바일 기기나 다른 임베디드 장치에 사용되는 버전. 
현재, Java SE의 JDK가 필요. 

----------------------------------------------------
2.2 JDK 설치 
JDK는 Oracle 웹사이트 
http://www.oracle.com/technetwork/java/javase/downloads/index.html
에서 다운로드 할수 있다. (주소는 버전 이나 접속 시점에 따라 다르다. )
Java SE 10 버전 다운. -> 변경 
11.0.2 버전으로 다운. 
설치 진행.
가이드 사이트 
https://docs.oracle.com/en/java/javase/11/

설치가 끝나면 JDK 설치된 경로 
C:\Program Files\Java\jdk-11.0.2
여기서 bin 디렉터리 안에 
컴파일러 javac.exe,
인터프리터 java.exe 
자바 도큐멘테이션 만드는 javadoc.exe 
자바 9에서 추가된 jshell.exe 
다양한 개발도구 확인. 


----------------------------------------------------
2.3 자바 도큐멘테이션 확인 

자바 API에 대한 설명서. 
JDK를 다운로드의 웹 페이지에서 아래로 스크롤 하면 
Additional Resources (추가 리소스) 부분이 나온다. 
도큐멘테이션 확인하기 위해서는 
Java SE 
10 버전 확인 하기.
https://docs.oracle.com/javase/10/docs/api/index.html?overview-summary.html
p44 확인 
Package Explorer -> JRE System Library 확장하고 
우클릭 Properties 선택 -> Javadoc Location 
URL path : https://docs.oracle.com/en/java/javase/11/docs/api/
변경

----------------------------------------------------
2.4 환경 변수 설정 
필수 사항은 아니지만, 나중에 라이브러리 관리 시스템 도구인 
MAVEN 등에서 JAVA_HOME 환경변수를 찾는 경우가 있어
미리 설정 진행하는게 좋음. 

제어판 -> 시스템 -> 고급 시스템 설정 
시스템 (변수)속성 창에서 환경변수 버튼 클릭. 
새로 만들기 클릭하여. 설정. 
변수이름 
JAVA_HOME
변수 값 지정. 
C:\Program Files\Java\jdk-11.0.2
!
Path에
C:\Program Files\Java\jdk-11.0.2\bin
추가.

CLASSPATH 
확인.
C:\Program Files\Java\jdk1.8.0_65\lib;.; 
뒤에 ";.; "확인. 

----------------------------------------------------
3. 애플리케이션 개발 및 실행 절차

이제 JDK 설치 되어서 자바 애플리케이션 개발이 가능. 
자바 프로그램 소스 파일은 확장자를 *.java 로 한다. 
이를 컴파일러인 javac.exe 로 컴파일하면 확장자를 
*.class 로 결과물 생성. 
*.class  파일을 java.exe 로 실행해서
java.exe 는 인터프리터로써 *.class 파일을 한 줄씩 읽어서 
기계어로 번역 후 JVM에서 실행. 

3.1 메모장을 이용한 프로그램 작성 
메모장에서 

public class Hello {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
System.out.println("안녕 자바!!");
	}

}

오타 주의 !!
주의 사항 
1. public 이 붙은 class는 하나의 소스 파일에 하나만 존재. 
2. public class 가 있다면 소스 파일의 이름은 class 이름과 같아야 한다. 
3. 대/소문자를 구별해서 작성.
4. 문장의 끝은 세미콜론 (;) 으로 끝낸다. 
5. 영역을 표시 할 때는 중괄호 ({ } )를 사용하며 중첩해서 사용 가능. 

작성 후, 파일 - 다른 이름으로 저장 
c:\Temp로 선택하고, Hello.java 라 입력하고 저장. 


----------------------------------------------------
3.2 이클립스 활용 

프로그램 개발 도구를 IDE(Integrated Development Environment)
통합 개발 환경이라 부른다. 
프로그램 개발시 IDE 를 잘 사용할 때와 그렇지 않을 때 생산성의 차이가
매우 크다. 
프로그램 개발을 위한 IDE 중 가장 많이 사용되는 것은 
www.ecilpse.org에서 배포하는 이클립스 (Eclipse).
무료이고 플러그인 방식으로 개발에 필요한 다양한 기능들
(Git, Maven, Code Assist, 등 ) 손쉽게 추가할수 있는 장점.

(1) 이클립스 설치와 실행. 
http://www.eclipse.org/
에서 다운로드
앞으로 웹 분야까지 활용하기 위해서는 
Java SE 와 Java EE 까지 쉽게 접근 할 수 있는 
Eclipse IDE for Java EE Developers 를 사용. 

D 드라이브나 , 사용할 폴더 워크스페이스 공간 지정. 

Workspace 변경 하고 싶다면, 
File - Switch - Workspace - Other 메뉴를 통해서 변경. 

(2) 이클립스의 기본 화면 구성과 배치 
편집기 기본 구조. 
작은 창들이 배치 : 뷰 
Project Explorer : 프로젝트들의 소스, 경로 등 전반적인 사항에 대한 관리 
소스 편집 : 소스 코드를 편집. 
Outline 소스 파일의 구조를 표시 

Console 뷰 : 표준 출력에 자주 사용 
Window - Show View - Console 선택. 

디버깅 정보 보여주는 
Debug, Variables, Breakpoints 등의 뷰가 훨씬 유용하다. 
각 뷰들을 보기가 불편하므로, 
퍼스펙티브(Perspective) 뷰를 그룹화해서 관리. 
Windows - Perspective 메뉴에서 관리 

오른쪽 상단 퍼스펙티브로 원래 자바로 변경 가능. 

(3) 인코딩 설정. 
인코딩 파일을 저장할 때 사용하는 부호화 방식으로 어떤 문자 
코드(Character code )를 사용할 것인지 결정하는 것. 
다른 팀원들과 협업할 때 서로간의 인코딩이 맞지 않은 상태에서 
소스를 열면 글자가 깨지므로, 변경. !!
Windows는 기본 인코딩 MS949 , 
OS에 상관없이 표준적으로 사용할 수 있는 UTF-8 사용. 
!
Window - Preference - type filter text 
-workspace 입력 
Text file encoding 에서 
Other : UTF-8 선택. 
!

(4) 새로운 프로젝트 생성 
File - New - Java Project : 선택 
Project name 에 적당한 이름. :Java-0312
Location 영역은 자동 입력 .
프로젝트 이름은 같은 Workspace 내에서 중복 불가. 

JRE 설정 부분에서 
현재 설치된 JDK 폴더로 지정. 
C:\Program Files\Java\jdk-11.0.2

(5) 소스 파일의 생성과 실행 
프로젝트-src-에서 우클릭 new - class 만들기. 
Names : Hello 
입력 .
public static void main(String[] args) 체크 하기.
만들기 .
stub (대충 만들어 놓은 뼈대 정도)
class 만들 때 main() 메서드 뼈대를 만들어준다. 

내용에 
public class Hello {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
System.out.println("안녕 자바!!");
	}

}
추가  , 파일명 부분에 * 표시 된다. 
ctrl + s 저장 하면 없어짐. 

코드 실행 : F11 , play 버트 클릭. 
Always save resources before launching 항목 체크하기. 
콘솔 뷰에서 확인. 
코드 템플릿을 이용한 코드 자동완성 기능 지원. 
System.out.println(); 자주 나오는 데 
main() 메서드 안에서 
"sysout " ctrl + space 하면 자동 완성. 

(6) 컴파일과 디버깅 
이클립스는 코드를 입력하면 자동으로 바로 컴파일 수행. 
프로젝트 디렉터리 에 src 와 bin 디렉터리가 생성 

소스 코드에서 static 정적 메서드를 만드는 자바 키워드. 
STATIC 으로 변경 해보자.  저장 할 필요 없고, 
오류 코드 생성.  
자바의 키워드가 아니라 오류가 발생하고 소스 코드에 빨간 밑줄이 
생기고, 줄번호 앞에도 에러 기호 표시. 
저장과 상관없이 컴파일 되고 오류를 소스 편집 부분에 바로 표시. 
마우스 커서로 확인 하면 오류의 자세한 내용을 알려준다. 

----------------------------------------------------
3.3 소스 코드 분석 

앞에 작성한 Hello.java 소스 코드 분석. 
이 짧은 코드를 완벽히 이해하기 위해서는 7장까지 학습이 끝나야 한다. 
용어나 설명이 이해 안되는 부분 . 일단 이런 것이 있구나 하고
넘어가기. 

package helloProject;

public class Hello {

	public static void main(String[] args) {

System.out.println("안녕 자바!!");
	}

}

1행 
package는 자바의 예약어로 , 소스 파일을 다양한 
기준으로 분리해서 관리.
3행 
public , class 는 자바 예약어. 
public이 붙은 class의 이름은 반드시 파일 이름과 같아야 함.!!
4행 
여는 중괄호 { , class 영역의 시작을 나타내며 , 짝을 이룬다. }
클래스 영역. 
클래스 영역에 뒤에 배울 ,  멤버 변수, 멤버 메서드 등 선언문 위치.
5행 
main() 메서드에 대한 선언부 
public, static, void  모두 자바 예약어. main은 메서드 이름. 
소괄호 안의 String[ ] args 는 메서드의 파라미터(parameter).
6행 
메인 메서드 내부 중괄호 내부를 메서드 구현부라고 한다. 
어떤 일을 수행하는 실행문이 작성되는 곳. 
대부분 메서드는 필요에 따라 개발자가 만들고 수정 가능. 
main( ) 메서는 아주 특별함. 
이 메서는 자바 애플리케이션의 시작점.
다른 메서드들은 이름 등을 변경 할수 있고,
main( ) 메서드의 선언부는 언제나 위 예제처럼 써야 한다. 
7행 
System.out.println(); 콘솔에 무언가를 출력하기 위해 사용. 
문자열을 표현 할 때에는 큰 따옴표로 묶기. 
System과 out, println( ) 모두 마침표를 이용해서 
연결돼 있는데 
이런 표기법을 dot notation (마침표 표기법)이라고 부른다. 
'XX가 가지고 있는'으로 해석. 
XX.YY는 XX가 가지고 있는 YY이다. 
각각의 항목에는 
소괄호가 있으면 메서드를 실행하는 것이고, 없으면 변수를 나타냄. 
System이 가지고 있는 out, out 이 가지고 있는 println( ) 메서드를
실행하라. 
 
코드 어시스트 (Code assist)
System. 이렇게 하면 코드 어시스트가 나온다. 
코드 입력 시간 줄이고, 오타 발생도 줄이고,
불필요한 디버깅 시간을 줄인다. 
예제 코드 공부하면서 발생하는 오류는 90%가 오류 일것이다. 
 
API 소스와 도큐멘테이션 연결 
System.out.println(); 메서드를 이용하여 파라미터인 문잘열이 콘솔에 출력.
이 메서는는 자바에서 기본적으로 제공되는 시스템 라이브러리에 구현 
되어 있다. 이런 라이브러리의 소스 코드를 확인하거나 도움말 확인이
필요하다. 

도움말은 앞서 보았던 자바 도큐멘테이션이다. 
이클립스에서는 대상 클래스, 메서드, 변수에 마우스 커서를 살 짝 
올리고 있으면 자동으로 팝업으로 나타난다. 

자세히 알아보기 위해 해당 메서드등에 올려 놓고 F1 누르기. 

API 소스 코드를 확인하기 위해서 Ctrl 키를 누른 상태에서 대상을 클릭. 
팝업 메뉴에서 Open Declaration 을 클릭 하면 API 소스코드를 확인
할수 있다. 

주석 
소스 코드에 작성하는 설명문으로 프로그램의 해독력을 향상시키는데 필요. 
소스는 수정 가능하므로 유지 보수를 위해서 주석은 반드시 필요. 
주석문은 컴파일 시에 결과에서 제외되기 때문에 애플리케이션의 크기에는
영향을 미치지 않는다. 하지만, 많은 주석은 가독성을 떨어 뜨림.
(1) 
"// " : 행주석 : 한 줄의 내용을 주석 처리. 
(2)
"/* */" : 블록 주석 : /* 와 */ 사이에 나오는 모든 내용을 주석으로 처리.
여러 라인 주석처리.
(3)
"/**  */" : 도큐먼트 주석 : /** 와 */ 사이에 나오는 모든 내용을 주석.
여러 라인 주석 처리하고, 도큐멘테이션을 생성할 때 사용. 
도큐먼트 주석은 별도의 Javadoc.exe 명령어를 통해서 앞에서 
살펴봤던 도큐멘테이션 같은 형태의 문서를 만들수 있다. 6장에서 !!

ex)
// 행 주석 연습1
/*
 *  블록 주석 연습2
 * 
 * 
 */
/**
 * 도큐먼트 주석 연습3
 */
 
----------------------------------------------------
4. 예제 소스 코드 설치 
이 책에서 사용할 예제를 설치.
예제는 Git (깃) 시스템을 통해서 배포된다. 
Git ? 프로그램 소스 코드 관리를 위한 분산 버전 관리 시스템.
!
File -import -Select -> Git 선택. 
Select Repository Source -> Clone URI 선택. 
URI : https://github.com/itsmeyjc/java-kame.git 
입력. 
URI를 파싱(parsing)해서 Host 와 Repository path 항목이 자동완성.
나머지 항목은 비워두고 Next 버튼 클릭. 
Branch Selection 대화상자에서 master 가 체크되어 있는지 확인하고 
Next 버튼을 클릭. 
Local Destination - Directory : 해당 워크스페이스\java-kame 입력. 

Select a wizard to use for importing projects - Wizard and project import
항목에서 : Import existing Eclipse projects 사 선택 된것을 확인하고 next .

마지막으로 Import Projects 대화상자에서 Search for nested projects 체크하기. 
Finish 
!
=======================================
[자바 해바라기 정리] 2 변수와 자료형  
//실습9개
1. 변수 
1.1 변수란?
변하는 수. 수학 시간 미지수 x ,  변수라 부름. 
x에 값의 타입에 상관없이 뭐든지 할당 가능. 
x=3;
프로그래밍에서의 변수는 그릇의 개념에 가까움. 
그릇의 다양한 크기를 갖는다는 점. 
변하는 값을 저장할 수 있는 메모리 공간을 의미.
음식을 그릇에 담기전에 그릇을 준비하는 것처럼 
값을 저장하기 위해서는 미리 변수 즉, 메모리의 공간을
준비해야 한다. 이것을 변수 선언. 
변수의 크기 값의 타입에 따라 결정. 
큰 메모리 공간에 작은 타입을 저장하면 그 만큼 메모리 낭비가 있다. 
그릇과 달리 변수의 공간이 남는다고 해서 하나의 변수에 여러 개의 
값을 저장 할수는 없다. 
변수는 한번에 하나의 값만 .
그릇은 작은 그릇에 음식을 넘치더라도 담지만, 
프로그래밍에서 기본적으로 작은 메모리에 큰 타입의 값을 
저장 할 수 없다.  값에 따른 변수의 타입 선택이 중요. 

(2) 변수의 선언 
변수 타입과 변수 이름으로 구성. 
예) 
byte  age;
변수 타입 : byte
변수명 : age 
JVM은 위 코드를 읽으면서 byte 타입을 인지하고 
이에 적합한 공간을 메모리에 할당.
뒤에 나오지만, byte 타입은 8bit의 메모리 공간이 필요. 
할당된 메모리는 특정 주소값을 갖는다. 
(정확한 주소는 알기 어렵기 때문에 관습적으로 
0x100 번지 형태로 사용한다. )
하지만, 프로그래밍하면서 주소값을 이용하는 것은 
매우 번거롭기 때문에 이 주소를 나타내는 변수명으로 age 이용.
이 age라는 변수명으로 8bit의 메모리 공간에 접근.

변수 선언하면서 위처럼 타입과 이름만 표시 할수 있고,
리터럴(literal)을 이용해 값을 할당 할 수도 있다. 
변수에 값을 할 당 할 때는 '=' 대입연산자 사용. 
double  height  =  180.5;
변수타입  변수명   <----- 리터럴 
                               할당. 
리터럴이란? 변수에 할당되기 전의 순수한 값을 말한다. 

동일한 타입의 변수를 선언할 때는 다음 처럼 한 번만 명시하고 
뒤에 콤마를 이용해 여러 개의 변수를 선언한다. 

ex)
int   number, count;
char  c1 = 'a' , c2 = 'b';

그러나, 타입이 다를 경우는 한 줄에 여러 개의 변수를 함께 선언 불가. 

실습1
예제 코드 

[ch02.variable.Declaration.java]
package ch02.variable;

public class Declaration {
	public static void main(String[] args) {
		byte age; // 단순 선언
		double height = 180.5; // 선언과 동시에 값의 할당
		int number, count; // 동일한 타입의 변수를 한꺼번에 선언
		char c1 = 'a', c2 = 'b'; // 동일한 타입의 변수에 대한 선언과 할당

		// int price, double weight; // 다른 타입은 같이 선언 불가
	}
}

(3) 변수 명명 규칙 
-대/소문자를 구분하며 길이 제한 없음 
-숫자로 시작 할수 없다 
-특수 문자로는 "_"와 "$"만 허용. 
-예약어는 사용 할 수 없다. 

자바 예약어
자료형 
boolean, byte, char, double, float, int , long, short 
논리값 
false, true 
접근 제한자 
private, protected, public
클래스 구성 
abstract, class, enum, extends, implements, import, interface, package
객체 활용 
instnaceof , new , null, this, super 
메서드 작성 
return, void 
제어문 
break, continue, case, default, do, else, for, if, switch, while 
예외처리
catch, finally, throw, throws, try 
기타 
assert, const, final, goto, native, synchronized, static, transient, volatile

ex)
int 3number; // 숫자로 시작할 수 없음. 
int number@; // _ , $ 이외의 특수문자 사용 불가 
int goto; // 예약어 사용 불가
_, $ 기호는 주로 프레임워크나 라이브러리등 특수한 목적으로 사용되므로 
일반 프로그램에서는 사용 안함. 
한글 이용해서 변수 이름 작성 할 수도 있지만, 
실제로 사용하지는 않는다. 

권장 사항.
-가급적 의미 있는 단어를 사용해서 변수의 용도를 파악 쉽게.
-클래스, 인터페이스, 이넘(Enum), 애노테이션의 이름은 대문자로 시작. 
-변수, 메서드의 이름은 소문자로 시작.
-두 개 이상의 단어를 붙여서 사용할 때는 - 케멀-케이스(Camel Case)
표현법 이용 
-ex) lastChange, isPowerOn, 연결되는 단어의 첫 글자를 대문자로 씀.
-상수는 모두 대문자를 사용하고 , 단어의 연결에는 _ 를 사용. 
ex) PI , MAX_AGE 

잘되는 프로젝트는 전체 팀원들이 처음 받아보는 문서에 
프로젝트 명명 규칙에 대한 기준이 포함된다. 

---------------------------------------
2. 자료형(-데이터 타입)

2.1 기본형과 참조형
정보들을 분류 하면 크게 문자, 숫자, 논리, 어떤 것 
4가지로 구분. 
문자 : 'a' , 'b' , '가', '각' 처럼 하나의 글자를 의미 
숫자 : 1,2,3 정수와, 1.5 , 3.14와 같은 실수로 나뉜다
논리 : '예' , '아니오'
어떤 것 : 앞의 3가지로 표현 못하는 것.
예를 들어 사람, 자동차 등 
한글과 같이 두개 이상의 문자로 이뤄진것 
문자열이라고 하며, 문자와 다른 어떤 것에 포함. 

생활에서의 자료형 : 프로그래밍에서의 자료형 : 예시
문자 : char : char firstAlpha = 'A'; , char gender = '남';
숫자 : 정수형 : byte, short, int, long : int age =20; , 
long earthAge = 4540000000L;
숫자 : 실수형 : float, double : float height = 180.5f;
double weight = 80.5;
논리 : boolean : boolean isPowerOn = true;
어떤 것 : 나머지 모두 : Date today = new Date();
Person person = new Person();
String name ="홍길동";

8개의 타입 기본형(Primitive type)
char, byte, short, int, long, float, double, boolean
어떤 것에 해당하는 것 참조형(Reference type)
기본형은 변수에 직접 값을 저장하고,
참조형은 힙(Heap)이라는 메모리 영역에 실제 데이터인 객체를
저장하고, 변수에는 그 객체를 참조할수 있는 참조값만 저장. 

// 기본형 변수의 선언과 할당 
int sum = 10;
// 참조형 변수의 선언과 할당 
Date birthDate = new Date();
기본형인 sum이 직접 10이라는 값을 갖지만, 
참조형인 birthDate는 실제 값인 Date 타입의 객체를 참조 할수 있는 
0x100 이라는 참조값 가지고 있다. 

(2) 기본형의 크기 
논리형 : boolean : 1 byte
문자형 : char : 2 byte
정수형 : byte 1 byte , short 2 byte , int 4 byte , long 8 byte
실수형 : float 4 byte , double 8 byte
컴퓨터는 모든 자료를 0과 1로만 구분한다. 
1byte 8비트 .

정수형인 byte, short, int, long 의 맨 앞의 bit 를 부호 비트(sign bit)라 하고,
양수, 음수 인지 표시. 
byte 부호 비트를 뺀 나머지 7개의 비트에만 값을 기록.
byte : -2^7 ~ 2^7 - 1
short : -2^15 ~ 2^15 - 1
int : -2^31 ~ 2^31 - 1
long : -2^63 ~ 2^63 - 1

- 2^(n-1) ~ 2^(n-1) -1

ex)
byte b = 129; // 범위를 넘어가는 값은 할당 못함. 

실수형인 float, double 역시 정수형 처럼 부호 비트가 있지만,
나머지 비트를 사용하는 방법은 전혀 다르다. 

구분 : 표현범위 : 비트 구성 
float : +-(m)*10^e  :  s | E(8) | M(23)
double : +-(m)*10^e : s | E(11) | M(52)

+- : 부호 표시 
(m) : 가수 
10^e : 지수 
float : 지수 부분 8bit , 가수 부분 23비트
double : 지수 부분 11bit , 가수 부분 52비트
지수함수 생각해보면 표현 할수 있는 값의 범위가
기존의 정수형에 비해 엄청나게 커진다. 

char : 0 ~ 2^16 - 1 : 16비트 

---------------------------------------
2.2 정수형

byte, short, int, long : 기본형은 int 타입. 
System.out.println(10); // 타입 없이 사용한 정수는 int 의미 
정수를 byte 나 int 등 보다 작은 타입의 변수에 할당 할 경우는 
자동으로 해당 타입으로 변경. 묵시적 형변환.
타입의 범위를 넘어가는 값은 할당 못함. 
ex) 
byte b = 10; // byte 에 할당되면서 int가 byte 로 변경됨.
// byte b2 = 128;
// Type mismatch :cannot convert from int to byte 

(1) 정수 리터럴 
진수 : 접두어: 활용예 : 10진수 환산 
10진수(decimal) : 없음: 10: 10^1 *1 + 10^0 * 0 = 10
2진수(binary):0b : 0b11 : 2^1 * 1 + 2^0 * 1 = 3
8진수(octal) : 0 : 016 : 8^1 * 1 + 8^0 * 6 = 14
16진수(hexadecimal) : 0x : 0x10 : 16^1 * 1 + 16^1*0 = 16

ex)0123 = 8^2 *1 + 8^1 * 2 + 8^0 * 3 = 64 + 16 + 3 = 83

음수의 경우, 
먼저 부호를 뺀 나머지 2진수로 바꾼 후
0 -> 1 , 1-> 0 으로 바꾼 : 1의 보수
더하기 1을 해준다. 
프로그램에서는 간단하게 
Integer.toBinaryString(-100)으로 확인 할수 있다. 
!
ex) 
long long1 = 10;
long long2 = 10000000000; //0 : 10개 The literal 10^10 of
type int is out of range 
long long3 = 10000000000L; 
ex)
int largeLiteral = 100_000_000; // 천 단위에 _를 사용해 가독성을 높이다.

실습2
ex)
package ch02.variable;

public class IntegerTest {

	public static void main(String[] args) {
		byte b1 = -128;
		// byte b2 = 128;
		// Type mismatch: cannot convert from int to byte
		System.out.println(b1);
//	byte b1 = (byte)128;
//	int c1 = 128;
//	System.out.println(c1);
//	System.out.println(b1);
//	System.out.println(Integer.toBinaryString(b1));
//	System.out.println(Integer.toBinaryString(c1));
//	System.out.println(String.format
//	("%032d", Integer.parseInt(Integer.toBinaryString(c1).toString())));
//  System.out.printf("%032d%n",e1);
		
		int i1 = 15;
		int i2 = 0b1111;
		int i3 = 017;
		int i4 = 0xf;
		System.out.println(i1 + ", " + i2 + ", " + i3 + ", " + i4);

		int i5 = 1_000_000_000;
		System.out.println(i5);

		// long l1 = 10000000000;
		// The literal 10000000000 of type int is out of
		// range
		long l2 = 1000000000L;
		System.out.println(l2);
	}
}

(2) 적절한 자료형의 선택 
자료형은 메모리 공간 할당과 밀접하게 연관되므로 사용하는 값의 
범위에 적합한 타입을 선택하는 것이 중요하다. 
다리의 개수 지정하는 변수 legCnt 라는 변수를 선언하다고 하자. 
대부분 byte 범위 내에서 처리 가능. 
int 기본형으로 바뀌니 3byte가 아깝다. 
그런, + , - 와 같은 산술 연산을 하게 되면 이야기가 달라진다. 
정수의 기본 연산 단위가 int 이므로 byte 를 다시 int로 변경해서 연산. 
byte + byte 의 연산을 수행해도, 
(byte -> int 변환) + (byte -> int 변환)의 과정을 거쳐 결과로 
int 로 돌려준다. 
메모리 절약하려다가 오히려 CPU에 더 부담을 주게 된다. 
연산이 일어나지 않으면, 각 타입에 맞게 설정하고,
연산이 일어나면, int를 사용하는게 좋다. 
지금은 메모리가 기가바이트이므로.

----------------------------------------------------
2.3 실수형 

기본형은 double이다.
아무 표현 없이 실수를 사용했다면 double 타입의 자료를 사용한다. 
ex) double weight = 90.5;

(1) 실수형의 리터럴 
float 타입 변수에 실수를 할당할 때에는 실수값 뒤에 별도로 f 또는 F를
추가해야 한다. 
또, 지수를 표현 하기 위해 e 를 사용 할수 있다. 
ex) float height = 180.5f;
double income = 3.0e2; // 3.0 * 100 = 300;

float 과 double 의 차이는 값의 표현 범위도 있지만,
정확도에 있다. 
float 는 소수점 이하 9번째 자리에서 반올림해서 8자리까지 표현.
double 는 소수점 이하 18째 자리에서 반올림해서 17자리까지 표현. 
double 이 float 보다 두 배 정도 더 정밀한 값을 표현 할수있다.

실습3
ex)
package ch02.variable;

public class FloatTest {

	public static void main(String[] args) {
		// float f1 = 3.14;
		// Type mismatch: cannot convert from double to float
		float f2 = 3.14f;

		double d1 = 3.14;
		System.out.println(d1);

		double d2 = 3.14e2;
		System.out.println(d2);
		double d3 = 3.14e-2;
		System.out.println(d3);

		// 출력 결과의 유효숫자 비교
		float f3 = 0.1234567890123456789f;
		double d4 = 0.1234567890123456789;
		System.out.println(f3);
		System.out.println(d4);
	}

}
//
3.14
314.0
0.0314
0.12345679
0.12345678901234568


----------------------------------------------------
2.4 문자형
문자형인 char 는 하나의 문자만을 표현하기 위한 자료형.
일반적으로 문자를 표현 할때 아스키코드 또는 유니코드 사용된다. 
컴퓨터는 bit 즉 숫자 0과 1로만 값을 기억하기 때문에 문자형이 필요없다. 
사람은 bit를 바로바로 해석하면서 프로그래밍 하기 어렵다. 
초기에는 문자를 특정 숫자에 매칭시켜서 아스키코드(ASCII code)라는 것을
만들어 문자를 입력. 
즉 0100 0001 (10진수 65) 는 'A'를 나타내고 
즉 0110 0001 (10진수 97) 는 'a'를 나타낸다.
아스키코드의 구성 표 참고하기.

아스키코드는 미국에서 만들어져서 영문자와 숫자, 일부 특수 문자 등이 포함되고
한글을 포함한 다양한 아시아권의 문자를 표현 못함. 
그래서, 모든 언어를 포함할 수 있도록 아스키코드를 확장해서 유니코드(Unicode)
가 개발됨. 유니코드는 아스키코드를 모두 포함하고, 추가적인 문자들이 매핑.
자바는 유니코드를 지원하기 때문에 한글을 사용하는데 지장 없다. 
(1) 문자형 리터럴 
문자형을 표현할 때는 작은 따옴표로 하나의 문자를 표현 하거나,
문자가 매칭된 유니코드 값을 입력한다. 
유니코드를 입력할때 '\u'와 함께 16진수 값을 입력한다. 
ex) char c1 = 'A';
char c2 = '\u0041';
System.out.println(c1 + "," + c2); // A,A 
유니코드를 다 외우고 다니는 사람은 거의 없으므로, 
직접 문자를 할당한다. 

(2)특수 문자 표현 
아스키코드는 영문, 숫자, 기호뿐 아니라 다양한 특수 문자들도 포함한다. 
특수 문자는 '\'와 함께 사용. 
자주 사용되는 특수 문자.
아스키코드의 특수 문자 
의미 : 표시 
tab : \t 
form feed : \f 
carriage return : \r
작은따옴표 : \'
backspace : \b 
new line : \n 
역슬래시 \\
큰따옴표 \"

(3)문자의 연산 
문자는 사실 정수형 숫자이다. 일반적으로 정수처럼 연산 할수있다
예에서
int i = 'A' + 1;
System.out.println( i+ ":" + (char)i); //66:B 
A 는 65에 매칭되어서, 
66 을 뒤에 배울 형변환 연산자 (char) 통해 문자로 바꿔보면 'B' 출력 


실습4
예) 유니코드를 이용한 표현 
package ch02.variable;

public class CharTest {

	public static void main(String[] args) {
		char c1 = 'A';
		char c2 = '\u0041';
		// \t(탭)와 \n(새줄) 삽입
		System.out.println("문자 출력: " + c1 + '\t' + c2 + '\n');

		int i = c1 + 1;
		System.out.println(i);
		System.out.println((char) i);
	}
}
//
문자 출력: A	A

66
B



----------------------------------------------------
2.5 논리형 
true , false 두개의 값만 사용. 
boolean b1 = true;
boolean b2 = false;

ex) 논리형 주로 제어문에서 상태값에 따라 반복 또는 조건문의 실행 흐름을 
결정할 때 사용된다.

실습5
package ch02.variable;

public class BooleanTest {

	public static void main(String[] args) {
		boolean b1 = true;
		if (b1) {
			System.out.println("참입니다.");
		} else {
			System.out.println("거짓입니다.");
		}
	}

}
//
참입니다.


----------------------------------------------------
2.6 문자열
문자열은 기본 자료형이 아니다. 
자바의 문자열은 String 이라는 클래스 타입으로 참조형이다.
아직 클래스 부분을 다루지 않았지만, 문자열은 계속 사용되므로 
먼저 알아보기 

(1)문자열 리터럴 
문자열 표시할 때는 문자와 달리 큰 따옴표(이중 따옴표)로 문자들을 
묶어 준다. 
ex)
String s1 = "String과 char는 다르다"; //String과 char는 다르다.
String s2 = "Hello\t\'Java\'\tWorld";
// Hello	'Java'	World

(2) 문자열의 덧셈 
문자열은 덧셈 연산이 가능한데 , 어떤 타입의 자료든 문자열과 더하면
기존 문자열과 결합하여 문자열로 변한다. 
그래서 문자열에서 + 연산은 결합 연산이라고 한다. 

예)연산 결과를 살펴보자. 
System.out.println("1" + "1"); //11
System.out.println(1 + "1"); /11
System.out.println(1 + 1 + "1"); /21
System.out.println(1 + "1" + 1); //111
System.out.println('1' + '1'); // 98
문자열이 들어간 덧셈은 숫자의 더하기가 아니라 문자열로 결합한 것.
세번째 내용은 + 연산의 경우 앞에서부터 순차적으로 진행되므로 
산술 연산으로 1 + 1 이 먼저 계산되고,
이어서 2 + "1"  을 문자열의 결합으로 연산하는 것이다. 
다섯번째 연산은 문자열이 아니라 문자!! . 
char '1'은 숫자 49에 매칭. 98.

----------------------------------------------------
2.7 형변환 (Type casting)
형변환이란 값의 형을 다른 형으로 변환하는 것을 말한다. 
일반적으로 형변환은 기본형은 기본형끼리, 참조형은 참조형끼리 가능하다. 
여기서 기본형의 형변환을 보고, 참조형 형변환은 7장에서 보자. 
기본형과 참조형 사이의 형변환은 Wrapper 클래스가 사용되는데,11장에서 

(1)형변환 연산자 
소괄호를 사용하고, 소괄호 내부에 변환하려는 자료형을 입력한다. 
예) 100.5를 갖는 double 형 변수 d를 int 형 변수 result에 할당하기
위해 int로 형변환 하는 방법.
double d = 100.5;
int result = (int)d;

d는 실수형이므로 소숫점과 소숫점 이하의 숫자를 포함하고 있다. 
하지만 int는 정수형이므로 소숫점과 소숫점 이하의 숫자를 표현 못함.
이 때 변수 d를 형변환 연산자 (int)를 이용해 int 타입으로 변경하면 
형변환 연산 과정에서 소숫점 이하가 손실되고 변수 result에 할당된 값은 
100이 된다. 

(2) 형변환의 종류 
묵시적 형변환 : 별도의 형변환 연산자를 사용 안해도 자동으로 이뤄짐. 
명시적 형변환 : 반드시 형변환 연산자를 사용 해야 한다. 
차이점 ? 값의 이동 방향에 따른 표현 가능 범위의 변화에 있다. 
작은 곳에서 넓은 곳은 상관없지만, 
넓은 곳에서 작은 곳으로 가면, 버려야 한다. !!
ex)
byte b = 10;
int i1 = (int)b; //형변환 연산자를 써도 되지만 
int i2 = b; //생략해도 상관없다. 

ex)
int i1 = 266;
byte b1 = i1 ; // Type mismatch: cannot convert from int to byte
byte b2 = (byte)i1;

값의 손실이 발생해서 , 변경됨. 
 
만약, i1의 값이 byte에서 표현할 수 있는 작은 값이었다면
형변환은 필요 없을까?
ex) 
int i1 = 10;
byte b1 = i1; // Type mismatch: cannot convert from int to byte
명시적 형변환이 필요한 기준은 값의 크기가 아니라,
값의 타입에 따르는 것이다. 

정수형 long 형과 실수형 float 형 중 어느 집이 더 클까?
long 64bit , float 겨우 32bit 이다. 
float에서 표현 할수있는 값의 범위는 long 과 비교할 수 없을 만큼 크다. 
자료형이 가지는 메모리상의 크기가 아니라 자료형이 표현할 수 있는 값의 범위에
따라 형변환 연산자의 사용 여부가 결정 된다. 
ex) 
long l1 = 100;
float f1 = l1; // 묵시적 형변환 가능 
long l2 = (long)f1; //명시적 형변환 필요 

화살표 방향으로 묵시적 형변환
byte -> short -> int -> long -> float -> double 
char -> int 

char 묵시적 형변환 고려할 점. 부호. 16bit 의 크기 이지만, 
부호가 없어서 양수만 존재. 따라서 음수의 측면에서는 byte 보다 
표현 할수 있는 범위가 작다. byte, short가 비록 bit 수는 
작거나 같지만 char로 묵시적 형변환 안된다. 
ex)
byte b1 = 10;
char c1 = (char)b1; // 8bit --> 16bit 이지만 부호 처리 문제로 
// 명시적 형변환 필요 

(3) 기본형 사이의 형변환 현상 
변수의 타입별로 형변환시 어떤 현상이 일어나는지

-정수형 간의 형변환
명시적 형변환 필요할 때 자릿수가 줄어들어 값의 손실 발생 여부 주의 

-정수형과 실수형 간의 형변환 
가장 큰 차이 소숫점 유무이다. 
정수에서 실수로의 형변환 묵시적 형변환. 소수점이 추가된다. 
반대로 실수에서 정수로 형변환이 될 때는 반드시 명시적으로 진행되며
실수부가 삭제되고 정수부는 자릿수에 맞게 줄어들수있다. 

-실수형 간의 형변환
double에서 float로 명시적 형변환이 이뤄질때는 유효 자릿수에
대한 문제로 값 손실이 발생할 수 있다.
묵시적 형변환 상관없다.

-문자와 숫자의 형변환
타입의 크기와 상관없이 숫자는 문자로 묵시적 형변이 안된다.
반드시 명시적 형변환이 필요.
숫자가 문자로 형변환 되면 실수부는 없어지고 정수부를 
자릿수에 맞게 줄인 후 유니코드에 매칭되는 문자로 표시.
반면, 문자를 숫자로 변환하면 문자가 매칭된 정수가 앞서 설명한 
규칙대로 형변환.
char -> int : 묵시적 형변환 가능. 

-논리형의 형변환 
다른 어떤 기본형과도 형변환 안됨. 

실습6
ex) 
package ch02.casting;

public class TypeCastingTest {
	public static void main(String[] args) {
		int i1 = 1234;
		long l1 = i1;
		byte b1 = (byte) i1;
		System.out.println(i1 + "\t" + l1 + "\t" + b1);

		double d1 = i1;
		byte b2 = (byte) d1;
		System.out.println(d1 + "\t" + b2);

		double d2 = 0.12345678901234567890;
		float f1 = (float) d2;
		System.out.println(d2 + "\t" + f1);

		byte b3 = 67;
		char c1 = (char) b3;
		float f2 = c1;
		System.out.println(c1 + "\t" + f2);

		boolean b = false;
		// int i2 = (int)b;
		// Cannot cast from boolean to int
	}

}
//
1234	1234	-46
1234.0	-46
0.12345678901234568	0.12345679
C	67.0

----------------------------------------------------
3.자료형에 따른 출력과 입력 
프로그램 입장에서 값을 받아들이는 것을 입력.
값을 내보내는 것을 출력.
본격적인 입력과출력은 15장에서 
여기서는 예제 진행을 위해 간단히 콘솔과 키보드를 이용하는 
입력과 출력에 대해서만 알아봄.
자바에서는 입력과출력을 위해서는 스트림(stream)을 사용.
스트림은 데이터가 흐르는 관이라고 볼 수 있다. 

키보드에서 입력한 값을 프로그램으로 가져오는 스트림 , 입력 스트림
입력 스트림 사용하기 위해서는 System.in 을 사용한다.
프로그램에서 콘솔로 출력하기 위해서는 출력 스트림이 사용된다.
System.out 이 사용.

3.1 포맷 문자열을 이용한 문자열과 기본형 출력 

출력 
System 클래스에 선언된 out 타입은 PrintStream 이므로 
println() 메서드는  PrintStream에 선언된 메서드이다. 
PrintStream 클래스에는 출력과 관련된 여러 메서드가 있다.
그 중에 대표적으로
print(), println(), printf() 이다. 

메서드명 : 선언부와 설명 
print() : public void print(Object obj) : obj 를 콘솔에 출력.
println() : public void println(Object x) : x를 콘솔에 출력하고 줄바꿈 한다. 
printf() : public PrintStream printf(String format, Object .. args) : 
지시자로 구성된 format 에 의거해서 args를 콘솔에 출력한다. 
!
print() 메서드 있는 그대로 파라미터 출력하고 
println() 파라미터 출력 후 줄 바꿈 처리.
그러나, 모든 자료를 있는 그대로의 형태로만 출력하거나 문자열과의 결합 형태로
출력하기 때문에 원하는 형태로의 출력이 없다. 
예)
소숫점 두자리까지만 출력 한다거나,
다양한 진법으로 출력이 필요할 수도 있다. 
이런 출력을 형식화된 출력. 
!
System.out.printf( ) 메서드를 사용. 
f 는 format을 의미.
파라미터로는 포맷을 지정하는 문자열인 format 
출력 할 값인 args로 구성. 
format 지시자 
!
지시자 : 설명 
%b : 논리값 (boolean)
%d : 10진수 정수 (decimal integer)
%o : 8진수 (octal) 
%x, %X : 16진수 (hexadecimal)
%f : 10진수 실수 (decimal float)
%e, %E : 지수형태 표현 (exponent)
%c : 문자(character)
%s : 문자열 (String)
%n : 줄 바꿈 (개행문자) 
!
두번째 파라미터 args 앞에 "..." 기호가 있는데 이것은 0개 이상의
파라미터가 올수 있다는 의미. 이런 형태의 변수를 가변 인수(variabl args) 
메서드 호출 할 때에는 format 문자열에 설정된 지시자 개수만큼
파라미터를 넣어서 메서드를 호출해야한다. 
즉 지시자가 파라미터로 대체되는 형태. 

println( ) 에서는  여러 값을 출력하기위해 계속 +  연산을 사용해서 가독성이 떨어지고,
반면, printf( ) 는 format 문자열 기반으로 훨씬 읽기가 편하다. 
!
ex)
boolean b1 = true; 
int i1 = 65;
double d1 = 3.141592;
System.out.println("b1:" + b1 + ",i1 : " + i1 + "(" + (char)i1 + "), d1:" +d1);
System.out.printf("b1: %b, i1: %d(%c), d1: %f%n", b1, i1, i1, d1);
// 두 출력 결과는 같다.
// 출력 결과 : b1: true, i1 :65(A), d1:3.141592
printf( ) 출력 후 개행 문자 ('\n')를 삽입해주지 않기 때문에 줄 바꿈을 위해서는
포맷문자열에 %n을 추가하는 것이 좋다. 
!
자릿수 표현 방법 
형태 : 	설명 :		사용예
%nd : n 자릿수를 확보하고 오른쪽 정렬 : [%4d] , 10 -> [   10]
%-nd : n 자릿수를 확보하고 왼쪽 정렬 : [%-4d], 10 ->   [10   ]
%0nd : n 자릿수를 확보하고 빈 칸은 0으로 채움 : [%04d], 10 ->[0010]
%m.nf : 전체 m 자릿수로, 소숫점 이하 n 자리까지 표현 
: [%5.2f],  10.1234 -> [10.12]
실수를 출력 할 때 %f 는 기본적으로 소수점 7자리에서 
반올림해 6자리까지 표현한다. 
예)
%10.4f 는 전체 10자리 중 소수점 이하 4자리를 의미. 
소수점도 한자리 차지 !! 정수부는 5자리 사용 가능. 
자릿수가 부족 하더라도 정수부는 언제나 출력. 
[%10.4f] , 10.123456789 -> [   10.1235]

실습7
ex)
package ch02.format;

public class Formatting {

	public static void main(String[] args) {
		boolean b1 = true;
		int i1 = 65;
		double d1 = 3.141592;
		System.out.printf("b1: %b, i1: %d(%c), d1: %f%n", b1, i1, i1, d1);
		System.out.println("b1: " + b1 + ", i1: " + i1 + "(" + (char) i1 + "), d1: " + d1);

		// 자릿수 지정
		System.out.printf("[%4d], [%-4d], [%04d]%n", i1, i1, i1);

		// 소숫점 이하 자리 표현
		System.out.printf("[%010.3f], [%10.8f]%n", d1, d1);

	}

}
//
b1: true, i1: 65(A), d1: 3.141592
b1: true, i1: 65(A), d1: 3.141592
[  65], [65  ], [0065]
[000003.142], [3.14159200]


----------------------------------------------------
3.2 포맷 문자열을 이용한 시간과 날짜 출력 

기본형 출력할 때 % 기호를 이용. 
시간을 출력할 때는 %t 사용. 
!
지시자 :  설명 
%tH : 24시간 체제의 시간 (00 ~ 23)
%tI : 12 시간 체제의 시간 (01 ~ 12)
%tM : 분 (00~59)
%tS: 초(00~60)(참고, 60은 윤초를 표시하기 위해 특별히 사용.
%tp : 오전 오후의 표현(오전/오후)
%tT : %tH : %tM : %tS (11:23:10)
%tR : %tH : %tM (11:23)
%tr : %tI : %tM: %tS %tp : (05:33:41 오후 )
!
%tT , %tR, %tr 각각 다른 지시자들을 조합해 놓은 형태로 예약어 개념. 

포맷 문자를 이용한 날짜 출력 
지시자    :			설명 
%tB : 월 (2월, Feburary)
%tb : 월 (2월, Feb)
%tA : 요일(일요일,  Sunday)
%ta : 요일(일,  Sun)
%tY : 년도(2018)
%ty : 년도(18)
%td : 일 (05)
%te : 일 (5)
%tm : 02 (월)

%tD : "%tm/%td/%ty" (02/25/18)   
%tF : "%tY-%tm-%td" (2018-02-25)
%tc  : "%ta %tb %td %tT %tZ %tY " :  (일 2월 25 17:21:31 KST 2018)
!
%t 대신 %T 를 사용할수 있다. 
영어권에서 출력 내용을 대문자로 할 것인지 소문자 인지 결정. 
예)
%tB : Feburary
%TB : FEBURARY 
!
자바에서 시간에 대한 정보는 일반적으로 하나의 객체가 갖는다. 
지시어마다 동일한 객체를 연결하는 형태가 된다. 
이런 경우 '<' 기호의 사용이 아주 유용하다. 
'<' 는 처음 지시어에서 사용된 파라미터를 두 번째 지서어에서 
재사용 가능 
ex)
System.out.printf("%ta %tb %te %n", currentTime, currentTime, currentTime);
System.out.printf("%ta  %<tb  %<te  %n" , currentTime)

실습8
ex)
package ch02.format;

import java.util.Calendar;

public class DateFormatting {

	public static void main(String[] args) {
		Calendar currentTime = Calendar.getInstance();
	    System.out.printf("%tA %<tB  %<te,  %<tY  %n", currentTime);
	    System.out.printf("%tD %n", currentTime);
	    System.out.printf("%tF %n", currentTime);
	    System.out.printf("%tc %n", currentTime);
	    System.out.printf("오늘은 %tF 이고 지금은 %<tR 입니다.%n", currentTime);
	}

}
//
일요일 3월  17,  2019  
03/17/19 
2019-03-17 
일 3월 17 13:17:35 KST 2019 
오늘은 2019-03-17 이고 지금은 13:17 입니다.


이클립스에서 
println : sysout + ctrl + space : 사용가능. 
미리 등록된 템플릿을 활용하는 것.
!
printf 등록 하기 
Window -> Preferences -> Java -> Editor -> Templates 
미리 등록된 템플릿을 볼수 있다. 
다음 처럼 입력 
예) 뉴 선택 
Name : printf 
Description : 포맷화된 출력 
Pattern : System.out.printf("${cursor}");
이제, 
printf 입력하고 , ctrl + space 누르면 된다. 

----------------------------------------------------
3.3 Scaner를 이용한 입력 

키보드에서 입력되는 데이터를 처리하는 방법. 
값을 입력할 때는 Scanner 라는 클래스를 사용한다.
클래스 전이라 이해가 어렵지만, 데이터를 입력 받는 방법.
클래스는 6장에서 

키보드에서 값을 입력 받을 때 가장 쉬운 방법은 Scanner 클래스 이용.
Scanner 를 사용하기 위해서는 소스에서 Scanner 클래스의 위치를
표시 해야한다.  클래스의 위치를 패키지(package - 폴더와 유사한 개념)
Scanner는 java.util 패키지 속에 있다. 다른 패키지의 클래스를 
사용하기 위해서는 import 키워드를 사용해야 한다. 
ex) import java.util.Scanner;

import 가 됐다면 소스 코드에서 Scanner 클래스를 사용 가능.
new 키워드를 이용해서 Scanner 타입의 객체를 생성한 후 사용.
ex) Scanner myScanner = new Scanner(System.in);

myScanner는 변수명이고, Scanner가 타입 .
마치 int i 와 유사한 형태.
myScanner 는 참조형 변수라고 한다. 
new 는 클래스를 통해 객체를 생성하기 위한 키워드.
Scanner 의 파라미터로 사용된 System.in 은 표준 입력 
스트림으로 키보드 의미.
따라서, 키보드에서 데이터를 읽어 들일수 있는 Scanner 타입 객체를 생성하고 
변수 myScanner에 할당하는 내용. 

Scanner 클래스에 선언된 대표적인 메서드

메서드명: 선언부 : 설명 
-next(): public String next()
:Scanner로부터 문자열을 공백 기준으로 한 단어씩 입력받아 리턴한다.
-nextLine(): public String nextLine()
:Scanner로부터 한 줄 전체를 입력 받아서 리턴한다. 
-nextInt() : public int nextInt()
:Scanner로부터 int 값을 받아 리턴한다.
-nextDouble(): public double nextDouble()
:Scanner로부터 double 값을 받아 리턴한다.
-nextBoolean(): public boolean nextBoolean()
:Scanner로부터 boolean 값을 받아 리턴한다. 
-close(): public void close()
Scanner에 연결된 자원(입력 스트림)을 종료한다. 

이외에도 데이터 타입에 따라 다양한 nextXXX 메서드가 포함 되어 있다. 
이들 메서드를 실행하면 사용자가 값을 입력할 때까지 프로그램은 대기하고 
있다가 값이 입력되고 enter 키를 누르면 비로서 
다음 행으로 실행을 이동한다. 
ex)
String line = scanner.nextLine();
먼저, 등호의 오른쪽을 수행하면서 scanner.nextLine() 메서드
를 동작시키고 사용자의 입력을 기다린다. 
사용자가 특정 문자열을 입력시킨 후 enter 키를 누르면 비로서 
사용자가 입력한 문자열이 변수 line에 할당된다. 

실습9
ex)
package ch02.input;

import java.util.Scanner;

public class ScannerTest {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		System.out.println("문자열을 입력하세요.");
		String line = scanner.nextLine();
		System.out.printf("입력한 문자열: %s%n", line);
		System.out.println("정수를 입력하세요.");
		int num1 = scanner.nextInt();
		System.out.printf("입력한 정수: %d%n", num1);
		System.out.println("실수를 입력하세요.");
		double num2 = scanner.nextDouble();
		System.out.printf("입력한 실수: %f%n", num2);
		System.out.println("불리언을 입력하세요.");
		boolean bool = scanner.nextBoolean();
		System.out.printf("입력한 불리언: %b%n", bool);
		scanner.close();
	}
}
//
문자열을 입력하세요.
서준아 안녕
입력한 문자열: 서준아 안녕
정수를 입력하세요.
1
입력한 정수: 1
실수를 입력하세요.
1.0
입력한 실수: 1.000000
불리언을 입력하세요.
true
입력한 불리언: true

===================================
[자바 해바라기 정리] 3 연산자
실습13개
1. 연산자란?
일상생활에서 수행하는 +,-,*,/ 등 계산하는 행위를 연산 
(operation)이라 한다. 
연산 구성요소는 연산자(operator), 피연산자(operand),
연산식(expression)으로 구분한다.

프로그래밍에서 사용되는 연산자는 일상에서 흔히 사용
되는 사칙연산, >>, >>> 와 같이 생소한 것들도 있다. 
피연산자는 당하는 요소로 변수나 리터럴이다.
연산식은 연산자와 피연산자를 이용해서 구성한 식을
말한다.  
ex)
int a = 10;
int b = a + 10;
'=' 로 할당 대입연산자 라 한다. 
피연산자는 10으로 변수 a에 할당. 
두번째 두 개의 연산자가 사용된 연산식이다. 
먼저, '+' 가 동작해서 a 와 10을 더해 20이라는 결과를 
만든 후, '=' 로 변수 b에 할당하는 과정을 거친다. 

----------------------------------------------------
2. 결합 방향과 우선순위
연산자는 종류별로 고유의 결합 방향과 우선순위를 갖는다. 

2.1 결합 방향 
연산자 종류  :  결합방향  : 우선순위
높음
(  ) ,  .  : -> :
증감( ++ , --) , 부호 ( + , -), 비트 (~), 논리(!), 형변환(type) : <--
산술 (*, /, %) : -->
산술(+, -) : -->
시프트(<< ,  >> , >>>) : -->
비교( < , > , <= , >=, instnaceof ) : -->
비교 (==, !=)
논리(&) : -->
논리(^) : -->
논리(|) : --> 
논리(&&) : -->
논리(||) : --> 
삼항 ( ? : ) : -->
대입(=, +=,-+,+=,/=,%=,^=,|=, <<=,>>=,>>>= ) : <--
낮음

연산이 진행되는 방향을 의미,
컴퓨터의 연산에서는 연산자별로 결합 방향이 정해져 있다. 
그 방향으로만 연산이 진행 된다. 
'*' 는 결합 방향이 오른쪽(-->)이어서 언제나
3*4 로 연산 .
ex)
x= y = 3 
'=' 결합 방향은 왼쪽 (<--) 이므로 
y에 먼저 3을 할당하고 다시 x에 y를 할당한다. 
다행히, 증감, 부호, 비트, 논리, 형변환 연산자와 
대입연산자의 결합 방향만 왼쪽이고 
나머지는 오른쪽.

----------------------------------------------------
2.2 우선순위
우선순위는 연산이 진행되는 순서. 
연산자들 모두 각 우선순위가 있다. 
ex) 
수식     :    연산 우선순위 설명 
-x + 3 : 1) -x 부호 연산  2) +3 
x + 3 * y  : 1) 3 * y   2) x + 연산 
x  << 2 + 1 :  1) 2 + 1 2)  x << 
x + 3 > y - 2 :  1) x+3  2) y-2  3) > 연산 
x > 3  &&  x < 5  :  1) x>3 2) x<5  3) &&
x < -1 ||  x>3  && x<5 :  1) x < -1  2) x>3 3) x<5 4) && 5)||
z = x + y * 3  : 1) y*3  2) x+  3) z =
소괄호 우선순위가 가장 높음.

소괄호 사용해서 가독성 높이기 쉽게 코드 분석 할수 있게.
(x + 3) > (y - 2) :  1) x+3  2) y-2  3) > 연산 
(x > 3)  &&  (x < 5)  :  1) x>3 2) x<5  3) &&
(x < -1) ||  (x>3)  && (x<5) :  1) x < -1  2) x>3 3) x<5 4) && 5)||


----------------------------------------------------
3. 연산자의 종류

3.1 산술 연산자
+, -, *, /, % (% : 모듈러스 : Modulus)
결합 방향 --> 
+ , - , * , / 
% : 두 피연산자의 나눗셈에 대한 나머지 
산술연산자는 boolean을 제외한 모든 기본형에서 사용. 
ex)
System.out.println( 10 /3 ); // 3 
System.out.println( 10 % 3 ); // 1

(1)산술 연산 시 형변환 
산술 연산하기 전에 피연산자의 형(타입)을 먼저 일치시키고
연산한다. 
원칙
1. 피연산자의 크기가 4byte 미만, 즉 int 미만인 경우 모두 int로 
자동 형변환 후 연산 진행. 
ex)
byte + byte = (int)byte + (int) byte = int 
ex2)
byte b1 = 10;
byte b2 = 20;
// byte b3 = b1 + b2;
// Type mismatch : cannot convert from int to byte

2. int 이상의 타입이 피연산자로 있을 때 
두 개의 피연산자 중 큰 타입으로 묵시적 형변환이
되고 후 연산이 진행.
ex) int + long = (long) int + long = long 
ex2)
int i1 =100;
long l1 = 200;
// int i2 = i1 + l1 ;
// Type mismatch : cannot convert from int to byte

실습1

package ch03.arithmetic;

public class ArithmeticOperatorTest {

	public static void main(String[] args) {
		// 나누기와 나머지 연산의 차이
		System.out.println(10 / 3); // 3
		System.out.println(10 % 3); // 1

		// 연산시의 형변 환 int 이하의 피연산자 끼리의 연산은 최소 단위가 int
		byte b1 = 10;
		byte b2 = 20;
		// byte b3 = b1 + b1;
		// Type mismatch: cannot convert from int to byte

		// 연산시의 형 변환 - int 이상의 피 연산자 타입으로 형 변환
		int i1 = 100;
		long l1 = 200;
		// int i2 = i1 + l1;
		// Type mismatch: cannot convert from long to int

		System.out.println(10 / 3);
		System.out.println(10 / 3.0);

	}

}
//결과
3
1
3
3.3333333333333335


(2) 변수의 연산과 리터럴 연산의 차이 
int 이하의 리터럴 간의 연산은 별도의 형변환이 일어나지 
않는다. 
리터럴 간의 연산은 컴파일러가 컴파일하기 전에 리터럴 간의
연산을 수행한 이후에 할당한다. 
컴파일 결과가 이미 계산이 끝난 상황이므로 형변환이 
발생하지 않는다. 
연산 결과가 할당받는 변수의 범위를 벗어날 경우는 오류가 발생. 
ex)
byte b3 =10 + 10  // byte  b3 = 20 과 같다. 
System.out.println(b3);
// byte b4 = 100 + 28 ; // Type mismatch : cannot convert from int to byte

(3)정수 연산의 문제점 - 오버플로우( overflow)

자료형의 범위에 따른 오버플로우를 조심. 
int 의 최댓값에 + 1를 더하면 
표현할 수 없는 값이기 때문에 에러 발생이 기대.
실제 연산 해보면, 에러 대신 전혀 몰랐던 
쓰레기 값 표현. 

정수들은 최댓값과 최솟값이 띠처럼 맞닿아 있는 구조.
최대값에 1을 더하면 최솟값이 된다. 
이런 연산 결과를 오버플로우라 한다. 
계수기의 동작을 생각.
-2147483647
-2147483648  // 최솟값 
2147483647  //최댓값 +1   위에 결과.
2147483646
2147483645

2진수 연산을 통해서 확인 
ex) 
 부호 비트 제외하고 31 비트 모두 1
01111111 11111111 11111111 11111111 
+ 1
-------------------------------------------------
10000000 00000000 00000000 00000000

다시, 10진수로 변경 할려면, 
1의 보수를 구하고
01111111 11111111 11111111 11111111 = Integer.MAX_VALUE)
결과에 1을 더한 후 부호를 추가.
-(Integer.MAX_VALUE +1 )
오버플로우 발생. 
에러 상황은 아니다. 결과는 엉뚱해도 프로그램은 잘 돌아감. 
그러나, 쓰레기값이 할당된 상황에서 프로그램이
제대로 동작하기는 어렵다.

실습2
ex)
package ch03.arithmetic;

public class IntegerProblem {

	public static int addNormal(int base, int addThis) {
		return base + addThis;
	}

	public static int addSafety(int base, int addThis) {
		if ((Integer.MAX_VALUE - addThis) > base) {
			return base + addThis;
		} else {
			throw new ArithmeticException("오버플로우 발생");
		}
	}

	public static void main(String[] args) {
		int result = addNormal(Integer.MAX_VALUE, 1);
		System.out.println("일반 덧셈 결과: " + result);

		try {
			result = addSafety(100, 100);
			System.out.println("안전한 덧셈 결과 1: " + result);

			result = addSafety(Integer.MAX_VALUE, 100);
			System.out.println("안전한 덧셈 결과 2: " + result);

		} catch (ArithmeticException e) {
			System.out.println(e.getMessage());
		}
	}

}
//출력 결과 
일반 덧셈 결과: -2147483648
안전한 덧셈 결과 1: 200
오버플로우 발생

더 큰 자료형인 long 타입을 사용하는 것도 좋은 대안. 
그러나, 형변환에 대한 고민 없이 long 타입을 무턱대고 사용한다고
문제가 해결되지 않는다. 
!!오버플로우는 연산하는 과정에서 발생하기 때문에 연산하기 전에 
미리 더 큰 데이터 타입을 준비한 후 연산 해야 한다. !!

실습3
ex2)
package ch03.arithmetic;

public class OverFlowAndCasting {

	public static void main(String[] args) {

		int i1 = Integer.MAX_VALUE;
		int i2 = i1 + 1;
		System.out.println("정수 overflow : " + i2);

		long l1 = i1 + 1;
		System.out.printf("long 타입에 할당: %d%n", l1);

		long l2 = (long) (i1 + 1);
		System.out.printf("캐스팅 된 값 : %d%n", l2);

		long l3 = (long) i1 + 1;
		System.out.printf("형변환 적용 연산 : %d%n", l3);

		int i3 = 1000000 * 1000000 / 100000;
		int i4 = 1000000 / 100000 * 100000;
		System.out.printf("i3 : %d, i4: %d%n", i3, i4);

	}

}
//결과물
정수 overflow : -2147483648
long 타입에 할당: -2147483648
캐스팅 된 값 : -2147483648
형변환 적용 연산 : 2147483648
i3 : -7273, i4: 1000000

(4) 실수형의 문제점은 정확도 
실수형에서의 문제점은 값이 정확하지 않다는 점. 
1 < x < 3 사이에 몇개의 실수가 있는지 알수 없다. 
사용하는 실수형은 근사값을 기초로 계산한다. 
ex) 
2.0 - 1.1 = 0.9 
그러나, 컴퓨터는 그렇게 생각 못한다. 
float 타입의 f1과 f2의 뺄셈 연산 결과를 f3에 저장. 
double 타입의 d1과 d2의 뺄셈 연산 결과는  d3에 저장. 
2개를 비교. 
ex) 
float f1 = 2.0f;
float f2 = 1.1f;
float f3 = f1 - f2;
double d1 = 2.0;
double d2 = 1.1;
double d3 = d1 - d.2;
System.out.println ( "결과 비교 " + (f3 == d3) + ", f3: " + f3 + ", d3: " + d3);
//결과 비교 : false , 
f3 : 0.9 ,
d3 : 0.8999999999999999
float의 연산결과가 더 정확하다는 이야기가 아니다. 
실수형은 연산의 결과가 부정확하다는 이야기이다. 

정확한 연산을 위한 방법?
쉬운 방법 
실수 -> 정수로 변경해서 처리.
d1 과 d2 를 각각 10을 곱하고, 정수로 만들고, 차를 구하고 
10으로 나눈다. 
ex) 
int i1 = (int)(d1 * 10);
int i2 = (int)(d2 * 10);
double result = (i1 - i2 ) / 10.0 ;
System.out.println(" 변환 후 처리 : "  + result ); // 0.9

좀더 세련된 방법으로 BigDecimal 과 같은 미리 제공된 API이용.
ex) 
BigDecimal bd1 = new BigDecimal("2.0");
BigDecimal bd2 = new BigDecimal("1.1");
System.out.println(bd1.subtract(bd2));

(5) Infinity  와 NaN 
/ , % 연산을 하다 보면 주의점
오른쪽의 피연산자가 0이 되는 경우이다. 
이 경우 정수를 0으로 나눌 때, 실수를 0으로 나눌 때 다르다. 

먼저, 정수 이용한 연산. 
ArithmeticException 이라는 예외 발생. 
ex)
int i = 1 / 0; // ArithmeticException 발생 
int j = 1 % 0 ;  // ArithmeticException 발생 
프로그램으로 이런 경우 try ~ catch 라는 예외 처리 구문을 이용해서 
명확히 오류에 대한 대처 구문을 작성 할수 있다. 
자세한 예외 처리는 9장에서 학습 함. 

try {
int i = 1 / 0 ;
// ArithmeticException 발생 
} catch ( ArithmeticException e ) {
System.out.println(" 예외 처리 완료 : 0으로 나눌 수 없습니다. ");
}

그러나 , 실수를 이용한 연산에는 다른 결과가 나온다. 
double d1 = 1 / 0.0 ; //Infinity
double d2 = 1 % 0.0 ; // NaN

실수형에서 0으로 나누면 Infinity( 무한대)가 나오고, 
나머지는 NaN (Not a Number - 숫자가 아님) 나온다. 
Infinity나 NaN 다른 어떤 것과 연산해도 Infinity 나 Nan 값이 나옴. 
ex)
double d3 = d1 + 100 ;  // Infinity
double d4 = d2 + 100 ;  // NaN
중요한 점은 이런 연산 결과 오류가 아니라는 것.
따라서, Infinity 나 NaN 결과를 가지고 계속 연산을 진행 하면 안된다. 

이런 상황을 대비해서 
Double 클래스가 제공하는 isInfinite  와 isNaN 메서드를 이용해 
값의 상태를 확인 하는 방법 제공. 
사용 가능한 double  인지 판단하는 Double의 메서드 

메서드 명  :  선언부와 설명 
isInfinite() : public static boolean isInfinite(double v)
v가 무한대의 값인지 리턴한다
isFinite() : public static boolean isFinite(double d)
d가 계산 가능한 유한의 값인지 리턴한다. 
isNaN() : public static boolean isNaN(double v)
v가 숫자가 아닌지 여부를 리턴한다. 
!

실습4
ex)
package ch03.arithmetic;

public class InfinityNaN {

	public static void main(String[] args) {
		try {
			int i = 1 / 0;
			// ArithmeticException 발생
			// int j = 1 % 0;
			// ArithmeticException 발생
		} catch (ArithmeticException e) {
			System.out.println(e.getMessage());
		}

		double d1 = 1 / 0.0;
		double d2 = 1 % 0.0;
		System.out.printf("d1 : %f, d2: %f%n", d1, d2);

		canUse(d1);
		canUse(d2);
	}

	public static void canUse(double d) {
		if (Double.isInfinite(d) || Double.isNaN(d)) {
			System.out.println("사용 할 수 없는 값입니다.");
		} else {
			System.out.printf("d : %f%n", d);
		}
	}
}
//결과물 
/ by zero
d1 : Infinity, d2: NaN
사용 할 수 없는 값입니다.
사용 할 수 없는 값입니다.

----------------------------------------------------
3.2 대입 연산자 

단순대입연산자 , 복합대입연산자 로 구분.

연산자 :  연산자 기능 : 결합방향 모두 <--
= : = 우측의 피연산자 값을 좌측의 변수에 할당 (예 : a=b)
+= : 두 피연산자의 합을 앞의 피연산자에 할당 
(예 : a = a + b ->  a += b) 
ex)
int i = 10;
i += 1; // i = i + 1 ; 와 같은 내용 

복합대입연산자 는 다양한 연산자와 결합할 수 있다. 
산술연산자 결합 ( -=, *=, /=, %=),
논리연산자 결합 (&= , |= , ^=)
시프트연산자 결합 ( <<= , >>= , >>>=)이 가능하며 
동작은 모두 +=  와 동일 하다. 

실습5
ex)
package ch03.assign;

public class AssignOperator {

	public static void main(String[] args) {
		int i1 = 10;
		i1 += 20; // i1 = i1 + 20;
		System.out.println(i1);
		i1 -= 10; // i1 = i1 - 10;
		System.out.println(i1);
		i1 *= 10; // i1 = i1 * 10;
		System.out.println(i1);
		i1 /= 10; // i1 = i1 / 10;
		System.out.println(i1);
		i1 %= 2; // i1 = i1 % 2;
		System.out.println(i1);
	}

}
//결과물 
30
20
200
20
0
----------------------------------------------------
3.3 비교 연산자
두 피연산자의 대소나 동등 여부를 비교해서 true 또는 false 값을 리턴. 

연산자 : 연산자 기능 : 결합 방향(--->)
< : 앞의피연산자가뒤의피연산자보다 작은가? a<b 
> : 앞의피연산자가뒤의피연산자보다 큰가? a>b 
<= : 앞의피연산자가뒤의피연산자보다 작거나 같은가? a<=b
>= : 앞의피연산자가뒤의피연산자보다 크거나 같은가? a>=b
== : 앞의피연산자가뒤의피연산자 와 같은가 ? a == b 
!= : 앞의피연산자가뒤의피연산자 와 다른가 ? a != b 
!
주로 if  제어문이나 반복문에서 실행 흐름 제어에 사용된다. 
재미있는 점. 비교하는 데이터의타입에 따라 동작 방식이 약간다르다.
!
char 는 비교연산자로 비교할때 일단 유니코드로 변경후 비교한다.
System.out.println('A' > 'B'); // false
System.out.println('A' == '65'); // true

위의 첫 번째에서는 'A'는 65, 'B'는 66에 매핑되는 문자. false
두번째 'A'가 65이므로 true .

산술연산자에 형변환에 대한 규칙도 그대로 적용.
int 이하의 자료들을 비교할 때 먼저 int로 자료형을 맞추거나,
두 개의 피연산자중 큰 데이터 타입으로 형변환 실행. 
ex)
System.out.println( 3 == 3.0) ; // true
3 과 3.0의 동등 비교에서 3.0 이 double로 큰 타입이므로 
앞의 int 인 3을 double의 3.0으로 변환 후 연산한다. 

실수 연산의 부정확이라는 문제도 여전히  존재 
ex)
System.out.println(0.1 + ":" + 0.1f + ":" + (0.1 == 0.1f)); 
// 0.1:0.1:false
double 타입 0.1 과 float 타입 0.1f 를 출력 했을 때 모두 0.1
을 나타낸다. 하지만, 두 수를 동등 비교연산자로 같은지 
확인하면 다르다고 나옴.
이유, float 타입의 0.1 이 double로 변환되는 과정에서 근사값으로
표현돼서 
0.10000000149011612로 평가 되므로,
그래서, 실수를 비교할때는 정수로 변경해서 비교하기.
또는 double를 float로 형변환해서 연산할 수 도 있다. 
ex)
double d1 = 0.1;
float f1 = 0.1f;
System.out.println((int) (d1 * 10) == (int) (f1 * 10));
System.out.println((float) d1 == f1);

실수를 이용한 연산은 가급적 안하기. 

비교연산자 중 부등호가 들어가는 대소 비교연산자(<,>, <=, >=)
는 boolean 타입을 제외한 기본형에만 사용.
boolean 타입이나 참조형 데이터 타입은 비교연산자 중 
== 과 != 만 사용 할수 있다. 

참조형에서 ==과 !=의 사용시 주의.
참조형변수에서 사용되는 == 연산은 내용을 비교하는게 아니다. 
두 개의 참조형 변수가 정확히 같은 객체를 참조하는지 비교.
객체의 내용을 비교하기 위해서는 equals 메서드를 재정의
(override)해서 사용. 이 내용은 7장에서 다룬다. 

실습6
ex)
package ch03.compare;

public class CompareOperator {

	public static void main(String[] args) {
		System.out.println('A' > 'B'); // 65 > 66
		// 비교 연산에서의 형 변환
		System.out.println('A' == 65); // int 이하의 연산 - 일단 int로 변경:65 == 100
		System.out.println(3 == 3.0); // 두 피 연산자 중 큰 타입으로 형 변환: 3.0 ==3.0

		// 주의 사항: 0.1의 표현 문제
		System.out.println(0.1 + " : " + 0.1f + " : " + (0.1 == 0.1f));
		System.out.println(0.5 + " : " + 0.5f + " : " + (0.5 == 0.5f));
		double d1 = 0.1;
		float f1 = 0.1f;
		System.out.println((int) (d1 * 10) == (int) (f1 * 10));
		System.out.println((float) d1 == f1);

		// 문자열에서의 == 과 equals
		String s1 = new String("Hello");
		String s2 = new String("Hello");
		System.out.println((s1 == s2) + " : " + s1.equals(s2));
	}

}
//결과물
false
true
true
0.1 : 0.1 : false
0.5 : 0.5 : true
//0.5 = 2^-1, hence can be represented exactly in binary. 0.1 is not
System.out.println(0.5 + " : " + 0.5f + " : " + (0.5 == 0.5f));
System.out.println(0.25 + " : " + 0.25f + " : " + (0.25 == 0.25f));
true
true
false : true


----------------------------------------------------
3.4 논리 연산자

boolean 타입만 사용할 수 있는 연산자로 연산의 결과도 
true 또는 false 만 리턴.
논리곱(&) , 논리합(|), 부정(!), 배타적 논리합(^)으로 구성 
연산자 : 연산자기능 : 결합방향 (-->)
& : AND 연산자로 두 개의 피연산자가 모두 true 인 경우만 true 
| : OR 연산자로 두 개의 피연산자 중 하나라도 true이면 true
! : NOT 연산자로 단항 연산자이며 피연산자의 값을 반대로 바꿈.
^ : XOR 연산자로 두 피연산자가 서로 다르면 true, 같으면 false

실습7
ex)
package ch03.logical;

public class LogicalOperator {
	public static void main(String[] args) {
		boolean b1 = true;
		boolean b2 = false;
		boolean b3 = false;

		System.out.printf("b1 & b2 : %b%n", b1 & b2); // false
		System.out.printf("b1 | b2 : %b%n", b1 | b2); // true
		System.out.printf("b1 ^ b2 : %b%n", b1 ^ b2); // true
		System.out.printf("b2 ^ b3 : %b%n", b2 ^ b3); // false
		System.out.printf("!b1 : %b%n", !b1); // false

	}
}
//
b1 & b2 : false
b1 | b2 : true
b1 ^ b2 : true
b2 ^ b3 : false
!b1 : false

&&, || 재미있게 사용하는 형태 
숏 서킷(short circuit)연산자라고 함.
사실 연산자의 연산결과는 각각 &와 | 연산자의 연산결과가 동일.
그러나, 결과값을 도출하는 과정에서 큰 차이가 있다. 

& 연산의 경우 하나만 false 가 되어도 결과는 false이다. 
따라서 연산표 두번째 줄의 연산은 처음 피연산자가 false 임을
확인하는 순간 false가 결정되기 때문에 굳이 두 번째 피연산자를
확인할 필요가 없다. && 연산자는 이런 상황에서 두 번째 피연산자의
값을 확인하지 않는다. 
|| 연산도 마찬가지. | 연산의 경우 하나만 true여도 결과는 true.
따라서 오른쪽 표에서 첫번째 줄의 연산을 보면 처음 피연산자가 true
이기 때문에 굳이 두번째 피연산자를 확인할 필요가 없다. 
|| 연산자는 이런 상황에서 두 번째 피연산자의 값을 확인하지않는다.

연산자 : 연산자기능 : 결합방향 (-->)
&& : AND 연산자로 두개의 피연산자가 모두 true 인 경우만 true 
단 앞의 피연산자가 false일 경우 뒤의 피연산자를 검사 생략 
|| : OR 연산자로 두개의 피연산자 중 하나라도 true이면 true
단 앞의 피연산자가 true 일 경우 뒤의 피연산자를 검사생략 

숏 서킷 연산자는 불필요한 연산을 줄여서 프로그램 성능을 좋게 하므로 
복합 비교시 주로 사용된다. 
그러나, 두번째 피연산자에 연산식이 들어온다면 혼란이 올수도있다. 

실습8
ex)
package ch03.logical;

public class ShortCircuit {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		System.out.println((a += 10) > 15 | (b -= 10) > 15);
		System.out.println("a = " + a + ", b = " + b);

		a = 10;
		b = 20;
		System.out.println((a += 10) > 15 || (b -= 10) > 15);
		System.out.println("a = " + a + ", b = " + b);

	}
}
//
true
a = 20, b = 10
true
a = 20, b = 20

결론, 논리값을 비교할 때 &나 | 보다는 성능을 위해 숏서킷 연산자인 
&& 나 || 사용. 
그러나, 과정에 연산을 끼워 넣으면 경우에 따라 실행 되지 않을 수 있으니
주의.


----------------------------------------------------
3.5 증감 연산자

++과 --로 각각 1씩 증가시키거나 감소시키는 단항연산자.
연산자 : 연산자기능 : 결합방향 ( -->)
++ : 단항연산자로 피연산자의 값을 1 증가시킴 
-- : 단항연산자로 피연산자의 값을 1 감소시킴 
반복문에서 조건값을 1씩 증가시키거나 감소시키는 목적으로 자주 사용.
ex)
for(int i = 0; i < 10; i++){
// do something..
}

(1)증감연산자의 위치 
전위연산자로 사용될 경우, 후위연산자로 사용될 경우 동작이 다르니 주의 

전위연산자는 ++a ,--a 와 같이 증감연산자가 피연산자 앞에 사용되는 경우
먼저, 변수의 값을 증감해서 메모리에 있는 값을 변경시킨 후 다음 동작 
(출력,대입등)을 진행한다. 

후위연산자는 a++, a-- 와 같이  증감연산자가 피연산자 뒤에 사용되는 경우
먼저, 출력, 대입 등을 처리한 후에 변수의 값을 증감시킨다.

따라서, 변수가 사용되는 시점에 따라 값이 다르게 할당되므로 주의.

실습9
ex)
package ch03.monadic;

public class MonadicOperation {
	public static void main(String[] args) {
		int i = 5;
		i++;
		System.out.println(i);
		++i;
		System.out.println(i);

		int j = ++i;
		System.out.println(j++);
		System.out.println(--j);

	}
}
//
6
7
8
8

(2)증감연산자의 형변환 
산술연산자 부분에서 정수형 연산의 최소 단위는 int 이며 이때 
묵시적형변환이 발생한다 했다.
그러나, 증감연산자가의 경우 타입에 대한 변화가 발생하지 않는다.
이런 현상은 복합대입연산자를 사용할 때도 마찬가지.

예를 통해 1을 증가시키는 3가지 방법과 형변환에 대해 알아보자.

실습10
ex)
package ch03.monadic;

public class MonadicCasting {
	public static void main(String[] args) {
		byte b1 = 10;
		b1 += 1;
		System.out.println(b1);

		byte b2 = ++b1;
		System.out.println(b2);

		byte b3 = (byte) (b2 + 1); //b2의 값이 연산 과정에서 int로 자동형변환 발생.
		//다시 byte로 명시적 형변환 필요.
		System.out.println(b3);
	}
}
//
11
12
13

----------------------------------------------------
3.6 삼항 연산자

연산을 수행할때 연산에 참여하는 항목이 3개인 연산자를 말하며 
조건부 연산자라고 불린다.
연산자 : 연산자기능 : 결합방향(-->)
?:  : 처음 피연산자의 값이 true이면 두번째 피연산자를 
false이면 세번째 피연산자를 수행해서 결과를 리턴한다. 

ex)
평가식 ? <표현식1> : <표현식2>;
평가식은 true와 false를 리턴하는 식 또는 값이 올수있다.

ex)
String result = 10 % 2 == 0 ? "짝수" : "홀수";
System.out.println(result);

삼항연산자는 4장에서 배울 if문에서 판단해야 할조건이 간단할때 사용하면
코드를 간결하게 줄일수있다. 
if 문으로 병경하면 

ex)
String result = null;
if(10%2 ==0){
result = "짝수";
}else{
result = "홀수";
}
System.out.println(result);


----------------------------------------------------
3.7 비트연산자

2진수 형태로 연산을 진행.
2진수로 표현할수있는 정수만이 피연산자가 될수있다.
논리 비트연산자 (&, |, ^, ~) 와 이동 비트연산자
(<< , >> , >>>) 로 구성된다. 

(1)논리 비트연산자
논리연산자와 유사. ! 연산자만 ~ 로 대체.
연산자 : 연산자기능 : 결합방향 (-->)
& : AND 연산자로 두개의 피연산자가 모두 1인 경우만 1
| : OR 연산자로 두개의 피연산자 중 하나라도 1이면 1 
~ : NOT 연산자로 단항연산자이며 피연산자의 값을 반대로 바꿈 : <--
^ : XOR 연산자로 두 피연산자가 서로 다르면 1, 같으면 0

Integer 클래스가 제공하는 toBinaryString() 메서드
사용하면 정수를 2진수 형태의 문자열로 리턴한다

실습11
ex)
package ch03.bit;

public class BitLogical {

	public static void main(String[] args) {
		int i1 = 3;
		System.out.printf("%32s%n", Integer.toBinaryString(i1));
		// %32s 는 포맷 문자에서 총 길이를 32자로 출력한다는 의미.
		int i2 = 5;
		System.out.printf("%32s%n", Integer.toBinaryString(i2));

		System.out.printf("%32s%n", Integer.toBinaryString(i1 & i2)); // 1
		System.out.printf("%32s%n", Integer.toBinaryString(i1 | i2)); // 7
		System.out.printf("%32s%n", Integer.toBinaryString(i1 ^ i2)); // 6
		System.out.printf("%32s%n", Integer.toBinaryString(~i1)); // -4
	}

}
//
                              11
                             101
                               1
                             111
                             110
11111111111111111111111111111100

비트 논리 연산은 주로 비트 마스크라는 기법으로 많이 사용된다. 
만약, true/false 형태로 된 많은 자료를 관리한다고 가정. 
그에 맞는 변수의 개수의 변수를 선언해서 사용.
그러나, 2진수는 이미 true/false로 생각할 수 있는 
1과 0으로 구성된 32개의 값을 가지고 있는 숫자.
1 true , 0 false로 매칭해서 사용 해보면 어떨까?

집에 있는 가전제품 32개의 on/off 여부를 관리해야 한다고 생각.
기본값이 모두 off 상태라면,
int homeElecStatus = 0;

homeElecStatus 00000000 00000000 00000000 00000000

이제 각각의 비트에 특정 전자제품 상태를 연결 가능. 
맨뒤(오른쪽 끝)의 bit 를 TV의 on/off 상태라고 생각하면 
현재 TV는 꺼져 있는 상태이다. 
이제 TV가 켜져 있는지 연산을 통해서 알아보자. 
& 연산은 둘다 1일 때만 1인 특성을 이용해보자. 
ex)
int tvCheck = 0b1;
String result ="";
result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
System.out.println("tv 상태 : " + result);
결론, TV는 꺼져 있다. 
&
homeElecStatus 00000000 00000000 00000000 00000000
tvCheck        00000000 00000000 00000000 00000001

이제 TV를 켜보자. 
이때는 | 연산은 둘중 하나만 1이어도 1인 특징을 이용. 
ex)
homeElecStatus |= tvCheck;
result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
System.out.println("tv 상태(켜기) : " + result);
|
homeElecStatus 00000000 00000000 00000000 00000000
tvCheck        00000000 00000000 00000000 00000001
TV가 켜져있거나 꺼져 있거나 언제나 homeElecStatus의 마지막 bit
1이 될것이다. 

제품의 on/off 상태를 반전시키려면 ^연산자를 이용.
ex)
homeElecStatus ^= tvCheck;
result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
System.out.println("tv 상태(반전) : " + result);
^
homeElecStatus 00000000 00000000 00000000 00000001
tvCheck        00000000 00000000 00000000 00000001
예는 현재 TV가 켜져 있는데, tvCheck와 ^연산을 진행하면 
둘 다 1이므로 결과는 0이 돼서 TV가 꺼진 상태가 된다. 

TV를 꺼보자. tvCheck 변수의 보수를 구한 후 & 연산 수행.
결과는 0이 되어 TV는 꺼지게 된다. 
&
homeElecStatus 00000000 00000000 00000000 00000001
tvCheck        11111111 11111111 11111111 11111110
ex)
homeElecStatus &= ~tvCheck;
result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
System.out.println("tv 상태(끄기) : " + result);

이런 연산은 낯설다. 그러나, 컴퓨터에서 가장 빠른 연산은 2진수 연산이다. 
따라서, 임베디드 환경처럼 메모리가 작거나 많은 옵션의 적용이 필요한 안드로이드
개발 분야 등에서는 자주 사용된다. 

실습12
ex)
package ch03.bit;

public class BitMask {

	public static void main(String[] args) {
		int homeElecStatus = 0;
		int tvCheck = 0b1;
		String result = "";
		result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
		System.out.println("tv 상태 : " + result);

		// tv 켜기
		homeElecStatus |= tvCheck;
		result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
		System.out.println("tv 상태(켜기) : " + result);

		// tv 상태 반전
		homeElecStatus ^= tvCheck;
		result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
		System.out.println("tv 상태(반전) : " + result);

		// tv 끄기
		homeElecStatus &= ~tvCheck;
		result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
		System.out.println("tv 상태(끄기) : " + result);
	}
}
//
tv 상태 : 꺼짐
tv 상태(켜기) : 켜짐
tv 상태(반전) : 꺼짐
tv 상태(끄기) : 꺼짐

(3)이동 비트연산자
정수 데이터의 비트를 왼쪽 또는 오른쪽으로 이동시키는 연산을 말하며
시프트(Shift)연산이라는 표현을 더 자주 사용한다. 
방향에 따라 우측으로 이동할 때는 라이트(right)시프트 연산,
왼쪽으로 이동할 때는 레프트(left) 시프트 연산.
연산자 : 연산자기능 : 결합방향(-->)
<< : 왼쪽 피연산자의 각비트를 왼쪽으로 오른쪽 피연산자만큼 
이동시키고 빈자리는 0으로 채움 
>> : 왼쪽 피연산자의 각비트를 오른쪽으로 오른쪽 피연산자만큼 
이동시키고 빈자리는 부호 비트로 채움 
>>> : >>와 이동은 동일하나, 빈자리를 0으로 채움.

실생활에서 자주 사용되는 연산자가 아니기 때문에 쉽게 
어떤 역할을 하는지 감이 오지 않는다. 결과를 보자. 
ex)
int a = 0b1010; //십진수 10
a를 왼쪽으로 1만큼 레프트 시프트 연산을 수행하고 값 확인.
이동 후 오른쪽 빈자리는 0으로 채움 
ex)
int b = a<<1; //10100 십진수 20 

결과는 자리수가 한 자리 앞으로 진행되면서 2가 곱해진다.
레프트 시프트 연산 효과는 *2

이번에는 a를 왼쪽으로 2비트 만큼 레프트 시프트 연산. 
ex)
int c = a<<2; //101000 십진수 40 
레프트 시프트 연산 효과는 2*2

이제 a를 오른쪽으로 1만큼 라이트 시프트 연산을 해보자.
이때는 앞자리(왼쪽 비트 위치)가 하나씩 값이 비게 된다. 
부호 비트를 복사해서 값이 비는 비트를 채운다. 
ex)
int d = a>>1; //101 십진수 5 
라이트 시프트 연산 효과는 /2 

이제 a를 오른쪽으로 2만큼 라이트 시프트 연산을 해보자.
int e = a>>2; //10 십진수 2
라이트 시프트 연산 효과는 /(2*2)

비트 이동(시프트)연산은 곱셈과 나눗셈 효과가 있는데 사실 우리가 *2
라는 연산을 요청하면 JVM 은 이것을 다시 비트 연산으로 변환해서
처리한다. 우리는 << 연산이 어렵지만, 컴퓨터는 사실 *2라는 것을 
알지 못하고 *2를 << 1로 변형해서 연산을 처리한다. 
결국, 이동(시프트) 비트연산자는 처리 속도를 향상하는 한가지 방법이 된다.

>>> 연산자는 음수를 오른쪽으로 비트 이동했을 때 >>와 차이점이 있다. 
-100을 >>와 >>> 연산의 예를 보자. 
int f = 0b11111111111111111111111110011100; //-100
int g = f >> 1;
int h = f >>> 1;
ex)
연산 : 2진수 : 10진수 
a     : 11111111111111111111111110011100 :-100
a>>1  : 11111111111111111111111111001110 :-50
a>>>1 : 01111111111111111111111111001110 :2147483598
>> 연산자는 이동한 빈칸을 부호 비트로 채우기 때문에 1로 채웠고,
>>> 는 언제나 0으로만 채운다. 
>> 연산결과는 /2의 결과를 
>>> 연산결과는 일종의 쓰레기값 출력.

실습13
ex)
package ch03.bit;

public class ShiftOperation {

	public static void main(String[] args) {
		byte b1 = 0b1010;
		System.out.println(b1);
		
		int a = 0b1000;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(a), a);
		int b = a << 2;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(b), b);
		int d = a >> 2;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(d), d);
		int e = a >>> 2;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(e), e);

		a = -100;
		System.out.println(Integer.toBinaryString(a));
		int h = a << 1;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(h), h);
		int f = a >> 1;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(f), f);
		int g = a >>> 1;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(g), g);

	}

}
//10
                            1000, 8
                          100000, 32
                              10, 2
                              10, 2
11111111111111111111111110011100
11111111111111111111111100111000, -200
11111111111111111111111111001110, -50
 1111111111111111111111111001110, 2147483598



===================================
[자바 해바라기 정리] 4 제어문 
실습18개
1. 제어문
제어문이란 프로그램의 흐름을 제어하기 위한 문장. 
제어문은 조건문과 반복문으로 나눈다. 
조건문은 참과 거짓의 기준을 가지고 행동 할지 또는 말지 결정.

----------------------------------------------------
2. 조건문

2.1 조건문의 종류와 특징
조건문이란 조건식과 실행 문장을 포함하는 블록으로 구성.
조건식은 true 또는 false를 반한하는 식으로 이 식의 결과가 
true이면 블록을 실행하고 false이면 실행하지 않는다. 
ex)
true // 가장 가단한 형태로 자체가 true로 평가.
2>3 // 부등호 연산의 결과로 false로 평가된다.
a % 2 == 0 //a를 2로 나눈 나머지로 연산 결과와 0을 비교해 true/false 반환.
a>10 && b>20 //최종 연산은 논리연산자인 &&의 실행 결과.

조건문은 크게 if 계열과 switch ~ case 문으로 나눈다. 
if 계열 
if 
if ~ else
if ~ else if ~ else if ~ else 의 형태 
모든 상황에서 사용할 수 있는 기본적인 조건문의 형태.
switch ~ case 문은 주로 경우의 수가 많아지고 값이 
정확히 떨어지는 경우 사용된다. (범위가 아닌 경우)


----------------------------------------------------
2.2 if 계열

(1) if 문 
if 문은 조건이 만족하면 실행하는 가장 단순한 구조.
if 키워드 뒤의 소괄호 안에 조건식을 작성. 
조건식이 true일 경우 뒤에 나오는 중괄호 블로 ( { } )을 실행.
그런데, 실행할 블록이 한 문장으로 구성된 경우 블록 표시인 중괄호를 
생략하고 문장만 작성할 수 있다. 
ex)
if(조건식)
{
//조건식이 true일 경우 실행할 문장 
}
ex2)
if(조건식)
//조건식이 true일 경우 실행할 문장 

ex3)
두 형태로 작성된 if 문장 
int visitCnt = 0;
if (visitCnt <1)  //조건식
{
System.out.println("처음 방문");  //실행블록  (1)
}

System.out.println("날씨 굿"); // 조건문과 무관 (2)

조건식이   참이면 : 진행순서 (1) -> (2)
조건식이 거짓이면 : 진행순서 (2)

실행하는 문장이 한 문장인 경우 중괄호 생략 
int visitCnt = 0;
if (visitCnt <1)  //조건식
System.out.println("처음 방문");  //실행블록  (1)

System.out.println("날씨 굿"); // 조건문과 무관 (2)

가독성을 위채 중괄호 사용하기.!!

주의!
제어문 부터 소괄호 및 중괄호가 많이 나오고, 짝을 못찾아 오류가 
자주 발생. 괄호를 열고 닫고, 안에 코드 작성하기.!!
IDE 대부분은 바로 자동으로 닫아준다. 

(2)if ~ else 
조건식에서 false가 반환되었을 때 실행할 블록을 작성할수 있다. 
구조 
ex)
if(조건식){
// 조건식 true 일 경우 실행할 문장 
} else { 
// 조건식 false 일 경우 실행할 문장 
}
ex2)
int num = 10;
if (num % 2 == 0){
result = "짝수 입니다.";
} else {
result = "홀수 입니다.";
}

삼항 연산자(조건부 연사자)를 이용해서 좀더 간단하게 처리.
ex3)
int num = 10;
result = (num % 2 == 0) ? "짝수입니다." : "홀수 입니다.";

ex4) 
무작위로 정수를 발생시켜 범위를 확인하는 프로그램. 
Random 클래스가 제공하는 nexInt() 메서드 사용하면 
0 부터 경계값(bound) - 1 사이의 무작위 정수를 발생시킴.
메서드명 : 선언부와설명 
nexInt() : public int nexInt(int bound)
0부터 bound - 1사이의 무작위 정수를 리턴한다.

Random 클래스는 java.util 패키지에 있기에, 먼저 import 해야함.
import 관련 내용은 7장에서 다룬다.

예제 무작위로 정수를 생성하고 결과를 num1에 할당하기 때문에 
매번 실행때 마다 다르다.

실습1
ex) 
package ch04.condition;

import java.util.Random;

public class IfElseTest {

	public static void main(String[] args) {
		String result = null;
		Random myRandom = new Random();

		System.out.println("큰수? 작은수?");
		int num1 = myRandom.nextInt(100); // 0 ~ 99 사이의 정수
		if (num1 >= 50) {
			result = "큰 수";
		} else {
			result = "작은 수";
		}
		System.out.printf("%d는 %s이다%n", num1, result);

		System.out.println("짝수일까?");
		int num2 = myRandom.nextInt(10); // 0 ~ 9 사이의 정수

		if (num2 % 2 == 0) {
			result = "짝수";
		} else {
			result = "홀수";
		}
		System.out.printf("%d는 %s입니다.%n", num2, result);

		// 삼항연산자(조건부 연산자)를 이용하는 형태
		result = (num2 % 2 == 0) ? "짝수 입니다." : "홀수 입니다.";
		System.out.printf("%d는 %s%n", num2, result);

	}

}
//
큰수? 작은수?
34는 작은 수이다
짝수일까?
3는 홀수입니다.
3는 홀수 입니다.
!

팁 !
이클립스에서 자동 들여쓰기 단축키 : ctrl + shift + f 
!

(3) if~else if~else
비교해야 할 조건이 많을 경우는 중간에 else if 를 끼워 넣을 수 있다. 
ex)
if(조건식){
// 처음 조건식 true 일 경우 실행할 문장 
} else if(조건식){ 
// 두번째 조건식 true 일 경우 실행할 문장 
}...
else{
// 모든 조건식이 false 일 경우 실행할 문장 
}


ex2) 
int score = 75;
String grade = "";
if (score>=90){
grade = "A" ;
} else if (score >= 80 && score <90) {
grade = "B" ;
} else if (score >= 70 && score <80) {
grade = "C" ;
} else if (score >= 60 && score <70) {
grade = "D" ;
} else {
grade = "E";
} 
System.out.println(score + "는 " + grade + "등급입니다.");

해당하는 조건식에서 true 만나야 빠져 나온다. 

다음은 Scanner 를 이용해 사용자로 부터 32 ~ 126까지의
아스키코드 값을 입력 받은 후 그 값이 어떤 성격의 값인지를 
출력하는 프로그램.
Scanner는 java.util 패키지에 속해 있으므로 
import 해야 한다. 

실습2
ex)
package ch04.condition;

import java.util.Scanner;

public class IfElseIfTest {
	public static void main(String[] args) {
		System.out.println("32 ~ 126 사이의 정수를 입력하세요.");
		Scanner scanner = new Scanner(System.in);
		int scanned = scanner.nextInt();
		String type = null;
		if (scanned >= 48 && scanned < 58) {
			type = "숫자";
		} else if (scanned >= 65 && scanned < 91) {
			type = "대문자";
		} else if (scanned >= 97 && scanned < 123) {
			type = "소문자";
		} else {
			type = "기타 타입";
		}
		System.out.printf("숫자 %d는 문자로 %c이고 %s입니다.", scanned, scanned, type);
		scanner.close();
	}

}
//
32 ~ 126 사이의 정수를 입력하세요.
90
숫자 90는 문자로 Z이고 대문자입니다.

(4) 중첩 if 문 
중첩 if 문은 if 문의 실행 블록 내에 또 다른 if 블록이 오는 형태.
else 블록에도 다른 if 블록이 위치할수 있다. 

ex) 
if(조건식1) {
// do something // 조건식1이 true 일 경우 실행할 문장. 
if(조건식2) {
// 조건식 1과 조건식 2가 모두 true 일 경우 실행 
}else{
// 조건식1은 true , 조건식2는 false 일 경우 실행 
}
}else{
// do something // 조건식1이 false 일 경우 실행할 문장. 
}

ex2)
12세 관람가 영화를 관람할 수 있는지를 판별하는 애플리케이션 예제. 

실습3

package ch04.condition;

import java.util.Scanner;

public class NestedIf {

	public static void main(String[] args) {
		String result = "";
		Scanner scanner = new Scanner(System.in);

		System.out.println("나이를 입력하세요.");
		int age = scanner.nextInt();

		System.out.println("보호자가 동반하나요?");
		boolean withParent = scanner.nextBoolean();

		if (age >= 12) {
			result = "관람가";
		} else {
			if (withParent) {
				result = "나이는 적지만 보호자가 있어서 관람가";
			} else {
				result = "나이가 적고 보호자도 없어서 관람 불가";
			}
		}
		System.out.printf("나이: %d, 보호자 동반: %b, 결과: %s", age, withParent, result);
		scanner.close();
	}
}
//
나이를 입력하세요.
1
보호자가 동반하나요?
true
나이: 1, 보호자 동반: true, 결과: 나이는 적지만 보호자가 있어서 관람가
!


----------------------------------------------------
2.3 switch ~ case 

if 문과 달리 범위를 지정할수 없고 특정한 값과 같은지 여부만 비교 할수있다. 
하지만, 표현식 자체가 명확해서 동등성을 비교하는 경우 자주 사용된다. 

기본구조는 switch 의 파라미터로 조건식을 작성한다. 
이 조건식은 true/false를 반환하지 않고 정수값, 문자열, Enum
상수값을 반환한다. 

case 문에서 조건식의 값과 비교할 값을 쓰고 뒤에 콜론(:)으로 
실행문 또는 블록과 구분한다. 
case 값과 조건식의 값이 같은 경우 콜론 뒤의 문장 또는 블록을 실행.
실행 중간에 break 를 만나면 전체 switch 문을 벗어나고 그렇지 않으면 
다른 case 문을 계속 실행한다. 
만약 어떤 case 값도 조건식과 일치하지 않는다면 if ~ else 의 else에
해당하는 default 의 블록이 실행 된다. 
ex)
switch(조건식){
case 값1:
do something 1.. // 조건식의 결과가 값 1과 같은 경우 실행될 문장 
break; // switch 문을 벗어난다. 
case 값2:
do something 2.. // 조건식의 결과가 값 2과 같은 경우 실행될 문장 
default :
do something 3.. // 조건식의 결과와 일치하는 case 문이 없을 때 
실행될 문장 
}

case 값1 이면 // do something 1.. 실행하고 break 만나 빠져나오고 
case 값2 이면 // do something 2.. 실행하고 , default도 실행. 
case 값3 이면 // do something 3.. 실행하고 종료 


실습4
ex2)
package ch04.condition;

public class SwitchSimple {

	public static void main(String[] args) {
		int level = 0;
		String levelString = "";
		switch (level) {
		case 0:
			levelString = "운영자관리, 회원관리, 글쓰기, 보기";
			break;
		case 1:
			levelString = "회원관리, 글쓰기, 보기";
			break;
		case 2:
			levelString = "글쓰기, 보기";
			break;
		default:
			levelString = "보기";
		}
		System.out.println("당신의 권한은 : " + levelString);
	}
}
//
당신의 권한은 : 운영자관리, 회원관리, 글쓰기, 보기

실습5
ex3) 
package ch04.condition;

public class SwitchString {

	public static void main(String[] args) {
		String levelString = "";
		String level = "관리자";
		switch (level) {
		case "관리자":
			levelString = "운영자관리, 회원관리, 글쓰기, 보기";
			break;
		case "운영자":
			levelString = "회원관리, 글쓰기, 보기";
			break;
		case "회원":
			levelString = "글쓰기, 보기";
			break;
		default:
			levelString = "보기";
		}
		System.out.println("당신의 권한은 : " + levelString);
	}
}
//
당신의 권한은 : 운영자관리, 회원관리, 글쓰기, 보기

실습6
ex4)
package ch04.condition;

public class SwitchNoBreak {

	public static void main(String[] args) {
		String levelString = "";
		String level = "관리자";
		switch (level) {
		case "관리자":
			levelString += "운영자관리";
		case "운영자":
			levelString += "회원관리";
		case "회원":
			levelString += "글쓰기";
		default:
			levelString += "보기";
		}
		System.out.println("당신의 권한은 : " + levelString);
	}
}
//당신의 권한은 : 운영자관리회원관리글쓰기보기

실습7
ex5)
package ch04.condition;

import java.util.Scanner;

public class DayByMonthTest {

	public static void main(String[] args) {
		System.out.println("달을 1 ~ 12까지로 입력하세요.");
		Scanner scanner = new Scanner(System.in);
		int month = scanner.nextInt();
		int days = 0;
		switch (month) {
		case 2:
			days = 29;
			break;
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		default:
			days = 31;
		}
		System.out.printf("%d월은 %d일까지 있습니다.", month, days);
		scanner.close();
	}
}
//
달을 1 ~ 12까지로 입력하세요.
4
4월은 30일까지 있습니다.


----------------------------------------------------
3. 반복문

3.1 반복문의 특징과 종류 

특정 블록을 일정한 조건 또는 횟수만큼 반복해서 실행하도록 하는 문.
초기화, 조건식, 증감식, 실행 블록 4가지 요소로 구성. 
상황에 따라 불필요한 요소는 생략가능. 

초기화 -> 조건식 -> 실행블록 -> 증감식의 순서로 진행.
초기화 과정은 사용할 조건 값을 초기화한다. 
조건식에서 초기화한 값이 주어진 조건에 맞는지 확인하며 
true/false 의 boolean 값을 반환.
실행블록 조건식에서 true가 반환되면 실행된다. 
만약 반복할 내용이 한 문장일 경우는 조건문의 블록과 같이 
중괄호 생략가능. 그러나, 가독성 이유로 , 그냥 쓰기.
이후, 증감식을 통해 조건을 변경하고 변경된 내용을 다시 평가해서 
false가 나오기 전까지 계속 실행블록 -> 증감식 -> 조건식 반복. 

종류 3가지 
for 문 : 반복해야 하는 횟수가 지정될 경우 유리 
예 : 10번 먹으세요. 
while 문 : 반복회수 보다는 상황에 의한 반복을 정의할 경우 유리 
예 : 다 먹으세요
do ~ while 문 : while 작업 중 최소 한번은 실행해야 할 작업이
있는 경우 유리 
예 : 한번 먹어보고 맛있으면 다 먹으세요. 

----------------------------------------------------
3.2 for 문 
(1)기본 형태의 for문
가장 기본적인 반복문 4가지 구성요소를 작성하는 위치가 명확해서 
초심자들에게 유리.

for 문을 사용할 때는 소괄호 안에 초기화, 조건식, 증감식을 
각각';'으로 구분해서 넣고 중괄호를 이용해 조건식의 평가 값이 
true 일 경우 실행할 블록을 작성. 
ex)
for(초기화; 조건식; 증감식) {
//조건식이 true 일 경우 실행할 문장  //= 3)
}
순서 초기화 -> 조건식 -> 3) -> 증감식 
조건식 -> 3) -> 증감식 
조건식 -> 3) -> 증감식  // 반복. 

실습8
ex2)
package ch04.loop;

import java.util.Scanner;

public class TimesTableFor1 {

	public static void main(String[] args) {
		System.out.println("출력할 단을 입력하세요.");
		Scanner scanner = new Scanner(System.in);
		int dan = scanner.nextInt();

		for (int i = 1; i <= 9; i++) {
			System.out.print(dan + "*" + i + "=" + (dan * i) + "\t");
		}
	}
}
//
출력할 단을 입력하세요.
7
7*1=7	7*2=14	7*3=21	7*4=28	7*5=35	7*6=42	7*7=49	7*8=56	7*9=63	
 
(2) 다양한 형태의 for 문 
기본 for 문은 정확히 구성요소를 넣을 공간이 있어서 사용하기 편하다. 
초기값 i와 j가 선언, 조건식은 i만 평가.
증감식에는 i는 1씩 증가, j는 2씩 증가.
ex)
for( int i=0, j=0; i<10; i++, j +=2){
System.out.println(i+j+"\t");
}
ex2)
초기값 boolean 타입의 flag가 선언되어 있고 조건식은 flag를 사용.
3번째 항목인 증감식 부분은 비어 있는 것을 주의.
이 문장은 조건이 변경되지 않기 때문에 무한으로 반복하게 됨.
for ( boolean flag = true; flag;){
System.out.println("무한 루핑");
}

(3) 중첩 for 문 
반복되는 블록이 또 다른 반복문인 형태.
이중 for 문을 이용해서 직각삼각형의 모양을 출력하는 예.

실습9
ex)
package ch04.loop;

public class NestedForTest {

	public static void main(String[] args) {
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10 && j <= i; j++) {
				System.out.print("*");
			}
			System.out.println();
		}
	}
}
//
*
**
***
****
*****
******
*******
********
*********
**********

실습10
ex2)
package ch04.loop;

public class TimesTableFor2 {

	public static void main(String[] args) {
		for(int i=1; i<=9; i++){
			System.out.print(i+"단: ");
			for(int j=1; j<=9; j++){
				System.out.print(i+"*"+j+"="+(i*j)+"\t");
			}
			System.out.println();
		}
	}
}
//
1단: 1*1=1	1*2=2	1*3=3	1*4=4	1*5=5	1*6=6	1*7=7	1*8=8	1*9=9	
2단: 2*1=2	2*2=4	2*3=6	2*4=8	2*5=10	2*6=12	2*7=14	2*8=16	2*9=18	
3단: 3*1=3	3*2=6	3*3=9	3*4=12	3*5=15	3*6=18	3*7=21	3*8=24	3*9=27	
4단: 4*1=4	4*2=8	4*3=12	4*4=16	4*5=20	4*6=24	4*7=28	4*8=32	4*9=36	
5단: 5*1=5	5*2=10	5*3=15	5*4=20	5*5=25	5*6=30	5*7=35	5*8=40	5*9=45	
6단: 6*1=6	6*2=12	6*3=18	6*4=24	6*5=30	6*6=36	6*7=42	6*8=48	6*9=54	
7단: 7*1=7	7*2=14	7*3=21	7*4=28	7*5=35	7*6=42	7*7=49	7*8=56	7*9=63	
8단: 8*1=8	8*2=16	8*3=24	8*4=32	8*5=40	8*6=48	8*7=56	8*8=64	8*9=72	
9단: 9*1=9	9*2=18	9*3=27	9*4=36	9*5=45	9*6=54	9*7=63	9*8=72	9*9=81	


 ----------------------------------------------------
3.3 while 문 
(1) 기본 형태의 while 문 
for 문과 달리 구성요소를 위한 영역이 표시되지 않으므로 실수로 
구성요소를 빠뜨리지 않도록 주의 해야 한다. 
ex) 
초기화; //(1)
while(조건식) { //(2)
// 조건식이 true일 경우 실행할 문장 //(3)
증감식; //(4)
}
순서 
(1) ->(2)->(3)->(4)->(2)->(3)->(4)->..
반복 .

실습11
ex1)
package ch04.loop;

import java.util.Scanner;

public class TimesTableWhile1 {
	public static void main(String[] args) {
		System.out.println("출력할 단을 입력하세요.");
		Scanner scanner = new Scanner(System.in);
		int dan = scanner.nextInt();

		int i = 1;
		while (i <= 9) {
			System.out.print(dan + "*" +i+ "=" + (dan * i)+"\t");
			i++;
		}
		System.out.println();
	}
}
출력할 단을 입력하세요.
3
3*1=3	3*2=6	3*3=9	3*4=12	3*5=15	3*6=18	3*7=21	3*8=24	3*9=27	

(2) 중첩 while 문 
while 문에서도 실행 블록내에 다른 while 문을 가질수 있다. 

실습12
ex)
package ch04.loop;

public class TimesTableWhile2 {
	public static void main(String[] args) {
		int i = 1;
		while (i <= 9) {
			System.out.print(i + "단: ");
			int j = 1;
			while (j <= 9) {
				System.out.print(i + "*" + j + "=" + (i * j) + "\t");
				j++;
			}
			i++;
			System.out.println();
		}
	}
}
//
1단: 1*1=1	1*2=2	1*3=3	1*4=4	1*5=5	1*6=6	1*7=7	1*8=8	1*9=9	
2단: 2*1=2	2*2=4	2*3=6	2*4=8	2*5=10	2*6=12	2*7=14	2*8=16	2*9=18	
3단: 3*1=3	3*2=6	3*3=9	3*4=12	3*5=15	3*6=18	3*7=21	3*8=24	3*9=27	
4단: 4*1=4	4*2=8	4*3=12	4*4=16	4*5=20	4*6=24	4*7=28	4*8=32	4*9=36	
5단: 5*1=5	5*2=10	5*3=15	5*4=20	5*5=25	5*6=30	5*7=35	5*8=40	5*9=45	
6단: 6*1=6	6*2=12	6*3=18	6*4=24	6*5=30	6*6=36	6*7=42	6*8=48	6*9=54	
7단: 7*1=7	7*2=14	7*3=21	7*4=28	7*5=35	7*6=42	7*7=49	7*8=56	7*9=63	
8단: 8*1=8	8*2=16	8*3=24	8*4=32	8*5=40	8*6=48	8*7=56	8*8=64	8*9=72	
9단: 9*1=9	9*2=18	9*3=27	9*4=36	9*5=45	9*6=54	9*7=63	9*8=72	9*9=81	

----------------------------------------------------
3.4 do ~ while 문 
while 문과 문법이 비슷하다. 차이점은 그대로 일단 한번 실행(do)
하고 나서 반복(while)을 결정한다. 

구조 
초기화 후 실행문과 증감식이 있는 블록을 먼저 수행하고 나서 
조건을 확인하게 되어 있다. 즉 처음 조건에 관한 확인은 이미 실행 
블록을 한 번 수행한 후라는 것이다. 조건식 뒤에 세미콜론(';')을 추가해서 
문장의 마지막임을 표시해야 하는 것도 주의하자. 

ex)
초기화; (1)
do {
// 조건식이 true 일 경우 실행할 문장 (2)
증감식; (3)
} while(조건식);

실습13
ex2)
package ch04.loop;

import java.util.Scanner;

public class DoWhile {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int i = 0;
		do {
			System.out.println("제곱근을 알고 싶은 숫자를 입력하세요.(그만은 0)");
			i = scanner.nextInt();
			System.out.println(i + "의 제곱근은 : " + Math.sqrt(i));
		} while (i > 0); 
		// Math.sqrt(double d) 메서드는 파라미터의 제곱근을 반환.
	}
}
//
제곱근을 알고 싶은 숫자를 입력하세요.(그만은 0)
3
3의 제곱근은 : 1.7320508075688772
제곱근을 알고 싶은 숫자를 입력하세요.(그만은 0)
4
4의 제곱근은 : 2.0
제곱근을 알고 싶은 숫자를 입력하세요.(그만은 0)
0
0의 제곱근은 : 0.0


----------------------------------------------------
3.5 반복문의 제어 

중간에 반복을 멈추거나 동작을 생략할수 있다. 
break 와 continue 문 

(1)break 문 
반복문 중지할 때 사용. 
제곱수가 1000보다 작거나 같은 정수를 1부터 찾아가는 과정. 
즉 제곱수가 1000보다 커지면 반복을 종료한다. 
몇 번을 반복해야 할지 모르는 상황에서 그런 조건의 값을 
만나면 반복을 종료하도록 해야 함.

실습14
ex)
package ch04.loop;

public class BreakTest {

	public static void main(String[] args) {
		System.out.println("제곱수가 1000보다 작은 가장 큰 정수는?");
		int i = 0;
		while (true) {
			if (Math.pow(i, 2) > 1000) {
				break;
			}
			i++;
		}
		System.out.println("제곱 수가 1000보다 작은 가장 큰 정수는 " + (--i));
	}
}
//
제곱수가 1000보다 작은 가장 큰 정수는?
제곱 수가 1000보다 작은 가장 큰 정수는 31

실습15
ex2)
package ch04.loop;

import java.util.Random;
import java.util.Scanner;

public class GuGuQuizTest {

	public static void main(String[] args) {
		System.out.println("구구단 문제를 맞추세요. 그만하려면 0 입력");
		Random random = new Random();
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int num1 = random.nextInt(9) + 1;
			int num2 = random.nextInt(9) + 1;

			System.out.printf("%d * %d = %n", num1, num2);

			int result = scanner.nextInt();
			if (result == 0) {
				break;
			} else {
				if (result == num1 * num2) {
					System.out.println("정답입니다.");
				} else {
					System.out.println("정답은 " + (num1 * num2) + "입니다.");
				}
			}
		}
		scanner.close();
	}

}
//
구구단 문제를 맞추세요. 그만하려면 0 입력
2 * 7 = 
14
정답입니다.
7 * 3 = 
0

실습16
ex3)
반복 벗어나게 
package ch04.loop;

import java.util.Scanner;

public class ProductManagerClient {
	private final String line = "********************************************************************";
	String mainMenu = "현황조회(L)\t상품등록(R)\t상품판매(S)\t종료(X)";
	Scanner scanner = new Scanner(System.in);

	private void displayMainMenu() {
		do {
			System.out.printf("%s%n%s%n%s%n", line, mainMenu, line);
			String input = scanner.nextLine();
			if (input.equalsIgnoreCase("X")) {
				System.out.println("종료합니다.");
				return;
			} else if (input.equalsIgnoreCase("L")) {
				System.out.println("현황을 조회합니다.");
			} else if (input.equalsIgnoreCase("S")) {
				System.out.println("상품을 판매합니다.");
			} else if (input.equalsIgnoreCase("R")) {
				System.out.println("상품을 등록합니다.");
			} else {
				System.out.println("적절한 메뉴가 아닙니다.");
			}
		} while (true);
	}

	public static void main(String[] args) {
		ProductManagerClient pm = new ProductManagerClient();
		pm.displayMainMenu();
	}
}
//
********************************************************************
현황조회(L)	상품등록(R)	상품판매(S)	종료(X)
********************************************************************
L
현황을 조회합니다.
********************************************************************
현황조회(L)	상품등록(R)	상품판매(S)	종료(X)
********************************************************************
R
상품을 등록합니다.
********************************************************************
현황조회(L)	상품등록(R)	상품판매(S)	종료(X)
********************************************************************
S
상품을 판매합니다.
********************************************************************
현황조회(L)	상품등록(R)	상품판매(S)	종료(X)
********************************************************************
X
종료합니다.

메인 메뉴는 언제나 최초1회는 보여야 하기 때문에 do ~ while문을 사용.
String에서 제공하는 equalsIgnoreCase()는 대/소문자에 상관없이
문자열을 비교한다. 

(2)continue
반복문 수행중 continue를 만나면 더이상 아래 실행문을 실행하지 않고 
다음 반복으로 이동한다. 

예제 1 ~ 1000 까지의 정수중 3의 배수를 모두 더하는 프로그램.
3의 배수가 아니면 더하기 동작을 수행 안함. 


실습17
ex)
package ch04.loop;

public class ContinueTest {
	public static void main(String[] args) {
		System.out.println("1~1000까지의 정수 중 3의 배수의 합은?");
		int sum = 0;
		for (int j = 1; j <= 1000; j++) {
			if (j % 3 > 0) {
				continue;
			}
			sum += j;
		}
		System.out.println("1~1000까지의 정수 중 3의 배수의 합은 " + sum);
	}
}
//
1~1000까지의 정수 중 3의 배수의 합은?
1~1000까지의 정수 중 3의 배수의 합은 166833

(3) label의 활용 
중첩 반복문에서 label 활용. 
반복문 앞에 붙이는 일종의 이름이고,
break 와 continue 호출시 label을 지정할 수 있다. 
break 또는 continue를 호출할 때 label을 생략하면 
가장 가까운 반복문에 영향을 준다. 
만약 label이 입력된 경우라면 해당 label이 적용된 
반복문에 영향을 준다. 

이중 for 문을 통해서 구구단 출력.
label 와 continue가 어떻게 동작하는지 보기. 

실습18
ex)
package ch04.loop;

public class LabelTest {

	public static void main(String[] args) {
		outer: for (int i = 1; i < 10; i++) {
			inner: for (int j = 1; j < 10; j++) {
				if (j == 5) {
					break; // 각 단별로 *4까지만 출력
					// break inner; // break와 동일
					// break outer; // 1 * 4까지만 출력
					// continue; // *5는 생략하고 출력
					// continue inner; // continue와 동일
					// continue outer; // *5 부터 빠지고 단 구분이 없음
				}
				System.out.printf("%d*%d=%d\t", i, j, i * j);
			}
			System.out.println();
		}
	}
}
//
1*1=1	1*2=2	1*3=3	1*4=4	
2*1=2	2*2=4	2*3=6	2*4=8	
3*1=3	3*2=6	3*3=9	3*4=12	
4*1=4	4*2=8	4*3=12	4*4=16	
5*1=5	5*2=10	5*3=15	5*4=20	
6*1=6	6*2=12	6*3=18	6*4=24	
7*1=7	7*2=14	7*3=21	7*4=28	
8*1=8	8*2=16	8*3=24	8*4=32	
9*1=9	9*2=18	9*3=27	9*4=36	


===================================
[자바 해바라기 정리] 5 배열 
실습15개
1. 배열의 정의와 활용 

1.1 배열의 정의와 특징 
(1) 일상생활에서의 배열과 정의 
일상생활에서 배열이란 동일한 종류의 물건들을 연속적으로 배치하는 것.
예) 달걀 한판 
배열로 관리하는 이유? 관리의 효율성.
개수가 많아지면 관리가 어려워진다. 
배열 사용. 장점 자료 찾기가 쉬움.
주의 할점.
1) 관리할 수 있는 것의 종류 -> 타조알 예 
2) 한번 정해진 크기는 변경 할수 없다. 
3) 관리되는 대상이 달걀이 아니라 판이라는 점. 배열의 개념. 

(2) 배열의 특징 
1) 같은 타입의 데이터 여러 개를 연속된 테이터 하나로 다루는 것 
예) int로 관리하기로 한 배열이라면 , 묵시적형변환이 가능한 
byte, short , char 등. 이외의 값들은 관리할수 없음. 

연속된 데이터라는 말은 , 관리할수 있는 데이터의 개수로 메모리 공간의
연속성을 나타냄. 
예) int 타입의 데이터 4개를 담는 배열 선언 하면 
128비트 공간을 연속적으로 확보.

메모리에 구성된 배열의 뒤에 새로운 데이터들이 추가 안됨.
배열 뒤에 이미 다른 데이터를 사용중이므로, 공간의
연속성이라는 원칙 위배.
따라서, 배열을 한번 생성하고 나면 배열의 크기는 바꿀수 없다. 

2) 동일한 타입의 데이터를 저장하기에 데이터들이 일정한 간격으로 배치.
따라서 처음 데이터의 위치를 찾게 되면 다음 데이터를 찾아가는데 임의의
위치에 있는 데이터를 찾는 것보다 속도가 매우 빠르다. 

----------------------------------------------------
1.2 배열의 활용
(1) 배열의 선언 
변수 타입과 이름으로 선언. 
배열의 타입은 관리할 데이터의 타입과 함께 대괄호[ ]를 사용.
위치는 변수명 앞이나 뒤에 위치.
가독성을 위해 변수명 앞에 사용.!
ex)
관리할_데이터_타입 [ ] 변수명; //권장
관리할_데이터_타입 변수명 [ ]; 
주의 
배열의 타입과 관리할 데이터 타입은 다르다는 것. 
ex) 
int, String을 관리할 수 있는 배열은 다음처럼 선언.
int [] intArray;
String [] strArray;
위 코드는 
배열 타입 변수에 대한 선언. 
앞에 변수의 선언 타입과 이름으로 구성.
변수이름 : intArray가 되고 
나머지 : int [ ] 은 변수의 타입이 된다. 
절대로 intArray의 타입이 int가 아님을 명심.
int [ ] 은 int 를 관리하는 배열타입이지 int 타입이 아니다. 

배열의 데이터 타입은 참조형 데이터 타입이다. 

(2)배열의 생성과 초기화 
참조형 변수 사용하기 위한 객체 설명 6장에서 자세히.
new 키워드와 어떤 데이터를 몇 개나 저장할지 대한 정보 필요. 
ex)
new 관리하려는_데이터_타입 [데이터의_개수]
int 타입의 데이터 3개를 관리할 배열 points .
int [] points = new int [3]
배열선언 			배열생성 
배열의 크기 : length 속성.
현재 points 배열의 length는 3.
System.out.println(points.length); // 3

배열 생성 코드가 실행되면 메모리에 int 타입의 데이터 3개를 저장할수
있는 공간이 할당되고 points가 그 메모리의 위치를 참조함. 
points (참조변수)	
0x100 ---->  0x100 : int int int 
(객체 생성 6장에서 자세히)

배열의 각각의 공간들은 생성과 동시에 관리되는 데이터 타입에 대한 
기본값으로 초기화된다. 
데이터 타입 : 기본값 : 비고 
boolean : false
char : '\u0000' : 공백문자
byte,short, int : 0
long : 0L
float : 0.0f
double : 0.0
참조형변수 : null :아무것도 참조하지 않음. 
points (참조변수)	
0x100 ---->  0x100 : int int int 
(객체 생성 6장에서 자세히)  0    0   0

(3)배열의 사용과 메모리 
배열이 가지는 각각의 공간은 각 공간의 순서를 나타내는 index 갖음.
index 0부터 시작하며 1씩 증가하는 정수값.
배열의 각 요소에 접근할려면 배열이름[index_번호] 사용. 

실습1
ex) 
package ch05.basic;

public class SimpleArray {
	public static void main(String[] args) {
		int [] points = new int[3];
		System.out.printf("배열의 크기: %d%n", points.length);
		
		points[0] = 1;
		points[1] = 'A';
		//points[2] = 1.5;

		System.out.printf("0 번째 요소: %d%n", points[0]);
		System.out.printf("1 번째 요소: %d%n", points[1]);
		System.out.printf("2 번째 요소: %d%n", points[2]);
	}
}
//
배열의 크기: 3
0 번째 요소: 1
1 번째 요소: 65
2 번째 요소: 0

메모리 동작 
1) 배열 선언 : int [] points
참조형 변수 points 가 선언, 아직 참조하지 않고 null 상태 
2) 배열 생성 : new int [3] 
int 타입 3개 , 32비트 * 3만틈의 메모리에 연속적으로 할당. 
맨 처음 요소의 시작 주소를 0x100 이라고 가정. 
이 값이 배열의 참조값. 
이후 배열 크기 변경 불가. 각 요소 초기값 0으로 초기화 
3) 참조값 할당 : points = new int [3]
'=' 연산이 진행되고, 참조값이(0x100) 이 points에 할당. 
배열명 points을 통해 각 요소에 접근 가능.
4)배열 요소에 값 할당 : points[0] = 1; 
points[1] = 'A'; 

(4) 반복문과 배열 
length와 인덱스를 가지는 특성상 반복문을 이용해서 
배열 요소에 접근하는 경우가 많다. 
배열에 3단을 저장하고, 홀수 번째 요소의 합 구하기.

실습2
ex)
package ch05.basic;

public class TimesTableArrayTest {
	public static void main(String[] args) {
		int[] timesTable = new int[9];
		for(int i=0; i<timesTable.length; i++){
			timesTable[i] = 3 * (i+1);
		}
		System.out.println("배열 생성 완료");
		
		int sum = 0;
		for(int i=0; i<timesTable.length; i++){
			if(i %2==0){
				sum+=timesTable[i];
			}
		}
		System.out.printf("홀수 번째 요소들의 합은: %d%n", sum);
	}
}
//
배열 생성 완료
홀수 번째 요소들의 합은: 75

(5) 배열의 경계 
0 <= 인덱스 < length 
범위를 넘어가면 ArrayIndexOutOfBoundsException 예외 발생. 
비정상적 종료. 

실습3
ex)
package ch05.basic;

public class BoundsTest {

	public static void main(String[] args) {
		char [] charArray = new char [3];
		for(int i=0; i<charArray.length; i++){
			charArray[i] = (char)(i+'A');
		}
		
		for(int i=0; i<4; i++){
			System.out.printf("%d 번째 요소: %c%n",i, charArray[i]);
		}
	}
}
//
0 번째 요소: A
1 번째 요소: B
2 번째 요소: C
Exception in thread 
"main" java.lang.ArrayIndexOutOfBoundsException: 
Index 3 out of bounds for length 3
	at ch05.basic.BoundsTest.main(BoundsTest.java:12)
	
반복문에서 배열을 사용할 때 될수 있으면 length 속성을 통해 접근.!!

(6)배열 생성과 동시에 할당한 값으로 초기화 
중괄호 { } 이용해서 배열의 생성과 동시에 배열 요소에 값을 
지정하는 방식. 
주의 배열의 선언과 생성이 동시에 진행될 때만 사용가능.
ex)
int [] iArray1 = { 100, 200};
int [] iArray2; // 배열선언
//iArray2 = {100,200}; // 문법오류 

선언과 생성을 따로 할 경우,
new 와 중괄호 동시에 사용해서 표현한다
주의. 배열 객체를 생성시 배열의 크기를 지정 안한다.
ex)
int [] iArray3 = new int [] { 100,200};
int [] iArray4;
iArray4 = new int [] {100,200};
이런 형태는 배열 타입 변수를 파라미터로 전달받은 후 
새롭게 초기화해야 하는 경우 유용. 

실습4
ex2)
	package ch05.basic;

public class InitArrayTest {

	public static void main(String[] args) {
		String [] strs1 = new String [3];
		strs1[0] = "Hello";
		strs1[1] = "Java";
		strs1[2] = "World";
		
		String [] strs2 = {"Hello", "Java", "World"};

		if(args.length==0){
			args = new String[]{"Hello", "Java", "World"};
		}
		
		for(int i=0; i<strs1.length; i++){
			System.out.printf("strs1: %s, strs2: %s, args: %s %n", strs1[i], strs2[i], args[i]);
		}
	}
}
//
strs1: Hello, strs2: Hello, args: Hello 
strs1: Java, strs2: Java, args: Java 
strs1: World, strs2: World, args: World 
		
----------------------------------------------------
2. 다차원 배열 

2.1 다차원 배열의 정의 

2차원 배열 대괄호 2개로 구성. 
변수 선언의 
ex)
int a; // a의 타입은 int 
int [] arr; // arr 의 타입은 배열, 관리하는 데이터 int 
int[] [] arr2Dim; // arr2Dim의 타입은 배열, 관리하는 데이터는 int []
int[][] [] arr3Dim; // arr3Dim의 타입은 배열,
관리하는 데이터는 int[][]
int[][]...[] [] arrnDim; //arrnDim의 타입은 배열,
관리하는 데이터는 int[][]...[]
변수 이름을 제외한 나머지는 모두 타입이다. 
특이한 점. arr2Dim 타입 역시 배열이고,
관리하는 데이터가 int가 아니라 int[]인점. !!
다차원 배열이란 단순히 그것보다 한 차원 낮은 배열을 관리하는 
1차원 배열일 뿐
ex) 
int 의 99차원 배열은 단순히 int의 98차원 배열을 관리하는
1차원 배열이다. 

----------------------------------------------------
2.2 2차원 배열의 생성과 사용 

배열 생성시 길이 지정.
여러 개의 대괄호 등장하는데 이 중 맨 앞의 대괄호에 배열의 크기 명시.
생략 불가. 그 뒤에 등장하는 대괄호는 관리하는 배열의 크기 지정.
ex)
arr2Dim은 int[3]인 배열 2개를 관리하는 2차원 배열. 
int [][] arr2Dim = new int [2][3];
[2] : 2차원 배열의 크기 
[3] : 1차원 배열의 크기 
[] [] []
[] [] []

arr2Dim의 length는 2개 
주의 arr2Dim이 관리하는 것은 int가 아니라 int[]라는 점. 
arr2Dim[0]은 타입은 int[]이다. 배열 길이는 3이다. 
arr2Dim[0][0]은 arr2Dim[0]의 0번째 요소가 되고 타입은 int .

실습5
ex2)
package ch05.multi;

public class TimesTable2Dim {

	public static void main(String[] args) {
		// 구구단을 저장할 2차원 배열 선언
		int[][] gugu = new int[9][9];
		System.out.printf("gugu의 길이: %d%n", gugu.length);
		System.out.printf("gugu의 0 번째 요소의 길이: %d%n", gugu[0].length);

		// 배열에 구구단 저장
		for (int i = 0; i < gugu.length; i++) {
			for (int j = 0; j < gugu[i].length; j++) {
				gugu[i][j] = (i + 1) * (j + 1);
			}
		}
		// 배열 내용 출력
		for (int i = 0; i < gugu.length; i++) {
			for (int j = 0; j < gugu[i].length; j++) {
				System.out.printf("%d\t", gugu[i][j]);
			}
			System.out.println();
		}

		char[][] charArr = { { 'H', 'E', 'L', 'L', 'O' }, { 'J', 'A', 'V', 'A' }, { 'W', 'O', 'R', 'L', 'D' } };
	}
}
//
gugu의 길이: 9
gugu의 0 번째 요소의 길이: 9
1	2	3	4	5	6	7	8	9	
2	4	6	8	10	12	14	16	18	
3	6	9	12	15	18	21	24	27	
4	8	12	16	20	24	28	32	36	
5	10	15	20	25	30	35	40	45	
6	12	18	24	30	36	42	48	54	
7	14	21	28	35	42	49	56	63	
8	16	24	32	40	48	56	64	72	
9	18	27	36	45	54	63	72	81	

(1) 2차원 배열의 메모리 
코드가 실행되는 과정을 메모리 할당 측면에서.
ex)
int [][] arr2Dim = new int [2][3];
arr2Dim[1][1]=100;
//
int [][] arr2Dim = new int[2][];
arr2Dim[0] = new int [3]; // 관리할 1차원 배열 생성후 할당.
arr2Dim[1] = new int [3];
arr2Dim[1][1] = 100;

1)배열 선언과 생성 : int [][] arr2Dim = new int[2][];
              0x100
arr2Dim -> [0] null 
0x100      [1] null 

2) int[3]을 생성하고 arr2Dim의 각요소로 할당 
arr2Dim[0] = new int[3]
arr2Dim[1] = new int[3]

              0x100
arr2Dim -> [0] 0x200 -> 0x200[0][1][2]
                              0  0  0
0x100      [1] 0x300 -> 0x300[0][1][2]
                              0  0  0
3)arr2Dim[1][1]에서 100 할당 : arr2Dim[1][1]=100;

              0x100
arr2Dim -> [0] 0x200 -> 0x200[0][1][2]
                              0  0  0
0x100      [1] 0x300 -> 0x300[0][1][2]
                              0 100 0
(2)가변배열 
배열의 한 형식으로 포함된 요소 배열의 length가 다른 배열. 

ex) 
int [][] arr2Dim = new int [3][];

arr2Dim[0] = new int[4];
arr2Dim[1] = new int[3];
arr2Dim[2] = new int[5];

메모리 구조 
              0x100
arr2Dim -> [0] 0x200 -> 0x200[0][1][2][3]
                              0  0  0  0
0x100      [1] 0x300 -> 0x300[0][1][2]
                              0  0  0
           [2] 0x400 -> 0x400[0][1][2][3][4]
		                      0  0  0  0  0
배열의 길이가 가변이라도 length를 이용한 접근이면 된다. 

실습6
ex2)
package ch05.multi;

public class VariableLengthArrayTest {

	public static void main(String[] args) {
		int[][] arr2 = new int[4][];
		arr2[0] = new int[] { 1, 2, 4, 5 };
		arr2[1] = new int[] { 10, 20, 30, 40, 50 };
		arr2[2] = new int[] { 20, 20, 20 };
		arr2[3] = new int[] { 30, 30, 30, 30, 30 };

		int sum = 0;
		int count = 0;

		for (int i = 0; i < arr2.length; i++) {
			for (int j = 0; j < arr2[i].length; j++) {
				sum += arr2[i][j];
				count++;
			}
		}
		System.out.printf("배열의 총 합은: %d, 평균은: %3.1f", sum, (sum * 1.0 / count));
	}
}
//
배열의 총 합은: 372, 평균은: 21.9

(3) 다차원 배열의 초기화 
중괄호를 이용해 선언과 동시에 초기화 진행 가능.
ex)
char [][] charArr2Dim = {
{ 'H', 'E', 'L', 'L', 'O' }, 
{ 'J', 'A', 'V', 'A' }, 
{ 'W', 'O', 'R', 'L', 'D' }
};

실습7
ex2)
package ch05.multi;

public class SimpleInitTest {

	public static void main(String[] args) {
		char[][] charArr2Dim = { 
								{ 'H', 'E', 'L', 'L', 'O' }, 
								{ 'J', 'A', 'V', 'A' }, 
								{ 'W', 'O', 'R', 'L', 'D' } 
								};
		for(int i=0; i<charArr2Dim.length; i++) {
			for(int j=0; j<charArr2Dim[i].length; j++) {
				System.out.print(charArr2Dim[i][j]);
			}
			System.out.println();
		}
	}
}
//
HELLO
JAVA
WORLD


----------------------------------------------------
3. 고급 배열 특성 

3.1 향상된 for 문 : for each 문 

자바 5버전 부터 향상된 for 문 사용.
for each 문으로도 불린다.
배열 또는 java.lang.Iterable 인터페이스를 구현한 컬렉션 프레임워크에서 
사용 가능. 
기존 for 문과 비교해서 초기값과 증감식을 사용안함.
배열이 가지고 있는 요소들을 특정 변수로 바로 할당해서 
사용 가능. 
ex)
for(관리되는_타입변수명 : 배열_이름){
//반복할문장
}
1) 내부적으로 인덱스 0번부터 배열의 길이만큼 복사하면서 
그때그때 요소값을 변수에 할당.
2) 반복문 안에서 해당 변수를 이용가능.
전체적으로 간결.

단점
인덱스를 사용하지 않고, 인덱스를 사용할수 없다. 
반복처리할 범위 지정 할수 없다. 

용도 
인덱스를 사용하거나, 특정 범위의 반복이 필요한 경우 
기본 for 문 사용 
그렇지 않은 경우는 for each문 사용. 

실습8
ex)
package ch05.advanced;

import java.util.Random;

public class IteratorFor {

	public static void main(String[] args) {
		int [] datas= new int[100];
		Random random = new Random();
		for(int i=0; i<datas.length; i++){
			datas[i] = random.nextInt(100);
		}
	
		int evenSum = 0;
		for(int i=0; i<datas.length; i++){
			int data = datas[i];
			if(data%2==0){
				evenSum+=data;
			}
		}
		System.out.printf("짝수들의 합: %d%n", evenSum);
		
		int oddSum = 0;
		
		for(int data: datas){
			if(data%2==1){
				oddSum+=data;
			}
		}		
		System.out.printf("홀수들의 합: %d%n", oddSum);
	}
}
//
짝수들의 합: 2770
홀수들의 합: 2384



----------------------------------------------------
3.2 배열 데이터의 정렬 

배열 같은 자료구조에 대해서는 정렬에 대한 요구사항이 많다. 
정렬을 구현 하기 위한 알고리즘
버블 정렬, 선택 정렬, 삽입 정렬등 여러가지 방식 있다. 

버블 정렬 
인접한 두수를 일정 기준으로 비교해서 큰 수를 뒤로 보내는 정렬.
만약, 오름차순이면 큰 값을 뒤로 이동.
내림차순이면 작은 값 뒤로 이동.

ex)
2와 1의 오름차순 1->2 , 프로그래밍적으로 할려면 
임시 변수를 이용.
2를 임시변수에 넣고, 2의 자리에 1넣고, 1의 자리에
2넣고 두값 자리를 바꾸는 것을 swap이라 함. 

이 작업을
배열의 크기에서 현재까지의 순환횟수를 뺀 만큼 반복한다. 
단 매번 맨 뒤자리가 고정되기 때문에 반복할수록 
비교해야 할 가짓수는 하나씩 줄어든다. 

실습9
ex)
package ch05.advanced;

import java.util.Random;

public class Sorting {

	public static void main(String[] args) {
		Random rand = new Random();
		int temp = 0;
		int[] arr = new int[10];
		for (int i = 0; i < 10; i++) {
			arr[i] = rand.nextInt(100);
		}
		System.out.println("초기 상태");
		for (int i : arr) {
			System.out.printf("%d \t", i);
		}
		// 정렬
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 0; j < arr.length - 1 - i; j++) {	// 비교 가지 수 줄이기
				if (arr[j] > arr[j + 1]) {
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
		System.out.println("\n정렬 후");
		for (int i : arr) {
			System.out.printf("%d \t", i);
		}
	}
}
//
초기 상태
66 	56 	73 	87 	31 	48 	9 	5 	50 	97 	
정렬 후
5 	9 	31 	48 	50 	56 	66 	73 	87 	97 	

정렬은 배열 등에서 당연히 구현되어야 할 기능. 
이런 기능들은 미리 API(Application Programming Interface)
를 통해 제공. 
Array 클래스에서 제공하는 sort()는 파라미터로 들어오는 배열을 
오름차순으로 정렬.
만약, 문자열을 관리하는 배열이 파라미터로 들어온다면 
대문자 -> 소문자의 사전순으로 정렬.

Arrays 의 sort()메서드 
메서드명 : 선언부와 설명 
sort() : public static void sort(Object[] a)
a 를 오름차순으로 정렬한다. a 의 요소들은 Comparable을 
구현해야 한다. 

실습10
ex)
package ch05.advanced;

import java.util.Arrays;

public class SortingAPI {

	public static void main(String[] args) {
		String [] arr = {"Java", "is", "A", "PIE"};
		Arrays.sort(arr);
		System.out.println("정렬 후");
		for (String i : arr) {
			System.out.printf("%s \t", i);
		}
	}
}
//
정렬 후
A 	Java 	PIE 	is 	

----------------------------------------------------
3.3 배열의 출력 

배열 출력할려고 for 문 이용.
API 이용하면 쉬움.
Arrays 클래스가 제공하는 toString()이용 

Arrays의 toString() 메서드
메서드명 : 선언부와설명
toString() : public static String toString(Object[] a)
a의 요소들을 쉼표를 구분자로 하는 문자열로 리턴한다. 

실습11
ex)
package ch05.advanced;

import java.util.Arrays;

public class PrintArray {

	public static void main(String[] args) {
		String [] strs = {"Hello", "Java", "World"};
		System.out.println(Arrays.toString(strs));

		for(String str: strs){
			System.out.print(str+"\t");
		}
	}
}
//
[Hello, Java, World]
Hello	Java	World	


실습12

ex2)
package ch05.advanced;

import java.util.Arrays;
import java.util.Random;

public class LottoGeneratorByArray {

	public static void main(String[] args) {
		int[] selected = new int[6];
		int[] fullBall = new int[45];

		int cnt = 0;
		Random rand = new Random();
		while (cnt < 6) {
			int num = rand.nextInt(45);
			int ball = fullBall[num];
			if (ball == 0) {
				selected[cnt] = num + 1;
				fullBall[num] = -1;
				cnt++;
			}
		}
		Arrays.sort(selected);
		System.out.println(Arrays.toString(selected));
	}
}
//
매번 다름 
[4, 9, 16, 23, 34, 36]


----------------------------------------------------
3.4 배열의 크기 변경 

배열을 데이터에 적합한 길이로 만들어야 하고,
필요에 따라 늘어날 수 있어야 한다는 점. 
기존 배열의 크기 변경 불가.
좀 더 큰 새로운 배열 만들고 복사해 넣고,
다시 새로운 데이터를 추가. 

System 클래스가 제공하는 arraycopy()를 사용하면 
이 과정을 API 차원에서 지원함.
메서드명 : 선언부와설명
toString():public static void arraycopy(
Object src, int srcPos, Object dest, int destPos, int length);
src의 srcPos부터 length 만큼 복사해서 dest의 destPos에 저장.

실습13
ex)
package ch05.advanced;

import java.util.Arrays;

public class ArrayCopy {
	public static void main(String[] args) {
		int [] source = {1,2,3,4,5};
		int [] target = new int[10];
		for(int i=0; i<source.length; i++){
			target[i] = source[i];
		}
		System.out.println(Arrays.toString(target));
		
		int [] target2 = new int[10];
		System.arraycopy(source, 0, target2, 0, source.length);
		System.out.println(Arrays.toString(target2));
	}
}
//
[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]
[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]


----------------------------------------------------
3.5 main()메서드에서의 배열 

자바 공부 시작하면서 배열을 배우기 전부터 배열을 사용했다.
main()메서드의 파라미터로 전달되는 String[] args.
자바 애플리케이션이 실행될 때 JVM은 String 배열을 만들어서
파라미터로 전달한다. 평상시에는 전달하는 파라미터가 없기 때문에
이 배열의 길이는 0이다. 만약 100,200,300 처럼 값을 
입력하면 ["100", "200","300"] 형태로 된 배열이 전달.

만약, 프로그램 시작 시 입력되는 숫자를 더하는 프로그램을 
만든다면 어떻게 될까?
숫자를 넣어도 문자열로만 처리 되어서 연결만 발생.
100200300 될뿐 600이라는 값을 얻을 수 없다. 

이런 경우 Integer라는 Wrapper 클래스에서 제공하는 
parseInt()사용하면 문자열을 int로 변경 가능. 

Integer의 parseInt()메서드 
메서드명 : 선언부와 설명 
parseInt() : public static int parseInt(String s)
throws NumberFormatException 
:문자열의 형태인 s를 int로 변경해 리턴.

실습14
ex)
package ch05.advanced;

public class MainParam {
	public static void main(String[] args) {
		int sum = 0;
		for (String arg : args) {
			int num = Integer.parseInt(arg);
			sum = sum + num;
		}
		System.out.printf("배열의 길이: %d, 요소의 총합: %d", args.length, sum);
	}
}
//
배열의 길이: 0, 요소의 총합: 0

이클립스에서 프로그램을 실행시 파라미터 전달을 위해서 절차 필요.
패키지 탐색기에서 소스 파일을 
우클릭-> Run As- Run Configurations 선택.
Name:MainParam 확인 
Program arguments 에 (Tab 항목 2번째)
100 200 300 
입력 
Run. 
//
배열의 길이: 3, 요소의 총합: 600

실습15
ex2)
package ch05.advanced;

public class MainParam2 {

	public static void main(String[] args) {

		int num = args.length > 0 ? Integer.parseInt(args[0]) : 5;
		int sum = 0;
		for (int i = 1; i <= 100; i++) {
			if (i % num == 0) {
				sum += i;
			}
		}
		System.out.println("1~100까지 " + num + "의 배수의 합은 : " + sum);
	}
}

//
1~100까지 5의 배수의 합은 : 1050


===================================
[자바 해바라기 정리] 6 클래스와 객체
실습17개

1. 객체지향 프로그래밍

1.1 생활에서의 클래스와 객체 
클래스와 인스턴스(객체) 이야기 
도면 -> 제품 
도면 : 클래스 
제품 : 객체 
즉, 클래스는 객체를 만들어내는 원판이고, 원판을 통해 
만들어진 객체들을 사용한다. 

----------------------------------------------------
1.2 객체지향 프로그래밍(OOP:Object Oriented Programming)

요즘 스크립트 언어, 함수형 언어들이 주목 받고 있지만,
엔터프라이즈 계열의 대형 프로젝트들은 대부분 자바로 구성. 
객체지향 언어로서의 장점이 많이 드러나서.
객체 , 손님 객, 주체가 아닌 것이 객체이다.
객체를 이용하면 편하다. 주체적으로 객체 반대로 하면 힘들다. 
예)꽃배달 
객체지향 프로그래밍이란 프로그램에서 필요한 요소들을 객체로 만들고 
이것들을 이용해 프로그래밍 하는 것.

(1)객체지향과 모듈화 
모듈화 : 예 레고 
비행기의 머리, 몸통 , 날개, 꼬리를 모듈.
모듈은 재사용이 가능하도록 조립된 블록이고 
모듈화란 모듈 형식으로 작업을 진행 하는것.

모듈화된 프로그램 특징 
-추가/수정/삭제가 쉽다
-재사용 가능.
-검증된 모듈 사용은 신뢰도가 좋음.

레고 vs 프라모델 중 
날개를 쉽게 변경할수 있는 작품은?
하늘을 날 수 있게 멋진 것은?
모듈화는 장점들이 많지만 완벽하지는 않다.
특정 프로그래밍 방법이 맞고 나머지는 틀렸다는 개념은 아님.

(2) 좋은 객체와 올바른 사용법 
좋은 객체란 자신이 가진 정보를 활용하는 기능이 
다양한 객체.
예) 홍길동, 임꺽정 말하기 기능의 유무로 뭐가 더 편한가?
정보를 가져오지 말고 정보를 가진 객체에게 일을 
시키는 것이 올바른 객체의 사용법.


----------------------------------------------------
2. 클래스 와 객체

2.1 클래스 와 객체 

객체를 어떻게 만들까?
APIE 특징중 , Abstraction에 대한 부분.
-현실의 객체가 갖는 속성과 기능은 추상화(abstraction)
과정을 거쳐 클래스로 정의된다. 
-클래스는 구체화 과정을 거쳐 프로그램의 객체(object, instance)
가 된다. 

자바에서 이런 틀을 클래스라고 부른다. 
클래스는 하나의 데이터 타입이 되며 제품의 틀로서 동작. 
클래스를 통해서 나온 제품을 객체라고 부르며 
클래스의 정의대로 생성된다. 

(1) 클래스와 객체가 만들어지는 과정
모든 객체를 분석하면 속성과 기능을 찾을수 있다. 
속성은 객체가 가지는 정보, 데이터로 변수(variable)
,상태(status), 필드(field)와 같은 말로 사용.
기능은 메서드(method), 행위(behavior), 
함수(function)로 불리고, 객체가 할수있는 작업.

현실 세계 객체에 대한 분석 결과를 프로그래밍 영역으로 가져오면,
먼저, 추상화라는 과정을 거쳐 클래스를 만드는 과정이다.
추상화 과정에서는 객체 타입을 나타낼 이름을 정하고,
객체의 속성을 변수로, 객체의 기능을 메서드로 하여 
하나의 클래스를 작성. 

클래스를 구성하는 변수와 메서드를 각각 멤버변수와 멤버메서드 라 한다. 
클래스는 설계도 역할만 수행해서, 실제로 우리가 사용할 수는 없다. 
클래스를 바탕으로 활동할 객체가 필요.
객체를 만드는 과정을 구체화 또는 객체화라고 한다. 

구체화는 프로그램의 세계 즉 메모리에 객체(인스턴스, 오브젝트(object))
를 생성하는 과정으로 new 키워드 사용.
이제 클래스를 바탕으로 메모리에 생성된 객체의 멤버 변수에 철수,20,false 
와 같은 실제 값이 할당되고 메서드도 호출 가능. 

정리, 클래스는 객체를 정의해 놓은 것으로 설계도의 역할. 
이 클래스는 직접 사용할수없고 단지 객체를 만들기 위한 틀일뿐.
객체는 클래스를 데이터 타입으로 하여 메모리에 생성되는 것으로 
프로그램에서 사용하는 것이다. 
객체
- 클래스를 구체화 한것 
- 실제로 동작하는 것 
- 메모리에 생성된 데이터 

(2)클래스 생성 
이클립스를 이용해서 클래스 생성 
패키지 탐색기에서 현재 프로젝트 src 항목에서 
마우스 우클릭 -> new -> class 
Package : ch06.person
Name : Person 

이전과 달리 이 클래스는 우리가 사용할 객체를 
생성할 틀로 사용되므로 main 메서드를 작성할 필요는 없음. 

예제처럼 
멤버변수와 멤버메서드를 작성하면 클래스 완성. 
eat(), work() 메서드는 멤버 변수인 isHungry의
값을 변경하는 것에 주목. 
클래스의 속성을 변경하는 것이 아니라,
클래스 바탕으로 생성된 객체의 상태를 변경 하는 것.
클래스는 단지 원판임. 

실습1
ex)
package ch06.person;

public class Person {
//멤버변수
	String name;
	int age;
	boolean isHungry;
	
//멤버메서드
	void eat() {
		System.out.println("냠냠.");
		isHungry = false;
	}

	void work() {
		System.out.println("열심히");
		isHungry = true;
	}
}

(3) 객체의 생성과 활용 
클래스가 준비되면, 이 클래스를 이용해 객체를 만들고 
사용할 주체를 만들어본다. 

객체 생성시 new 키워드 이용해서 생성자라는 것 호출.
생성자는 뒤에서 다루고, 일단 클래스와 이름이 동일하다는 것만.
생성자를 호출하면 메모리에 객체가 생성되고 이것 사용하기 위해서는 
그 객체를 참조할 수 있는 참조값(주소값 비슷한 것)을 
해당 클래스 타입의 변수에 할당. 
ex)
클래스명 변수명 = new 클래스명();
참조형 변수.
실제 데이터는 메모리 어딘가에 있는 객체이고, 
이 객체를 참조하는 변수라는 뜻이다. 

다음 예 Person 타입의 객체 2개를 만들고 사용하는 예 
매번 new 를 할때마다 
새로운 객체가 생성되므로 서로의 멤버 변수의 값 독립적이다. 

실습2
ex) 
package ch06.person;

public class PersonTest {
	public static void main(String[] args) {
		Person person1 = new Person();
		person1.name = "홍길동";
		person1.isHungry = true;
		System.out.println(person1.name + " : " + person1.isHungry);
		person1.eat();
		System.out.println(person1.name + " : " + person1.isHungry);

		Person person2 = new Person();
		person2.name = "임꺽정";
		person2.isHungry = true;
		System.out.println(person2.name + " : " + person2.isHungry);
		System.out.println(person1.name + " : " + person1.isHungry);
		
	}
}
//
홍길동 : true
냠냠.
홍길동 : false
임꺽정 : true
홍길동 : false


----------------------------------------------------
2.2 객체와 메모리 

JVM의 메모리는 크게 3부분 
- 클래스 영역(class area)
- 스택영역(Stack area)
- 힙 영역(Heap area)

- 클래스 영역(class area)
클래스 원형이 올라가는 곳으로 
Method Area, CodeArea , Static Area 
로 불린다. 

#Field 정보: 멤버변수의 이름, 데이터 타입 접근 제어자에 대한 정보 
#Method 정보 : 메서드 이름, 리턴 타입, 파라미터,
#접근 제어자에 대한 정보 
#Type 정보 : 타입의 속성이 클래스인지 인터페이스(interface)인지,
타입의 전체 이름, 상위 클래스 이름, 접근 제어자 정보등.
#상수 풀(Constant Pool)
:타입(클래스 또는 인터페이스)에서 사용된 상수가 저장되는 곳으로 
문자 상수도 상수 풀에 저장. 

- 스택영역(Stack area)
:메서드 호출시 마다 로컬 변수들이 쌓이는 영역으로 
스레드(thread)별로 별도의 공간을 가진다. 
이 영역은 LIFO(Last In First Out)구조로 나중에 
메모리에 생성된 데이터가 먼저 소멸된다. 
로컬 변수란 호출된 메서드의 매개변수나 메서드 내부에 
선언된 변수등으로 객체의 멤버변수가 아닌 변수.

- 힙 영역(Heap area)
:힙은 new 키워드로 생성된 객체가 저장되는 공간으로,
스택과 달리 여러 스레드가 공유한다. 
이 영역에 생성된 객체들은 프로그램 코드로 임의로 삭제할 수 없고 
자동으로 G.C(Garbage Collection)가 실행될 때 
삭제되어 사용하던 메모리 공간이 반환된다. 

클래스 영역 #########
class Person
- name
- age
- isHungry

-eat()
-work()

class PersonTest
- main()

스택 영역 #########
Person person2
0x300
Person person1
0x100

힙 영역 ########
0x300 
0x400 :name ----> 0x400 임꺼정 
0 : age 
true : isHungry

0x100 
0x200 :name ----> 0x200 홍길동 
0 : age 
false : isHungry

코드 다시 살펴보기

실습3
ex)
package ch06.person;

public class PersonTest {
	public static void main(String[] args) {
		Person person1 = new Person();
		person1.name = "홍길동";
		person1.isHungry = true;
		System.out.println(person1.name + " : " + person1.isHungry);
		person1.eat();
		System.out.println(person1.name + " : " + person1.isHungry);

		Person person2 = new Person();
		person2.name = "임꺽정";
		person2.isHungry = true;
		System.out.println(person2.name + " : " + person2.isHungry);
		System.out.println(person1.name + " : " + person1.isHungry);
		
	}
}
//
홍길동 : true
냠냠.
홍길동 : false
임꺽정 : true
홍길동 : false

----------------------------------------------------
3. 변수의 종류 

3.1 선언 위치에 따른 변수의 종류 

멤버 변수(Member Variable)와 로컬변수(Local Variable)
로 나눈다. 
멤버 변수 : 클래스 영역에 선언된 변수.
static 키워드 사용 여부에 따라 
클래스 멤버 변수, 인스턴스 멤버 변수로 나눈다. 

로컬 변수 : 메서드나 생성자, 초기화 블록처럼
클래스 영역 내에 있는 또 다른 블록 내부에 선언된 변수.
메서드 등의 선언부에 파라미터로 선언된 변수를 틀별히 
파라미터 변수라 부른다. 

구분 : 선언위치 : 변수 종류 : 특징 
멤버변수 : 클래스 영역 : 클래스 멤버변수: static 키워드 사용 
멤버변수 : 클래스 영역 : 인스턴스 멤버변수: static 키워드 없음 

로컬변수 : 함수 등 내부 : 로컬변수 
로컬변수 : 함수 등 내부 : 파라미터 변수 : 메서드 파라미터

실습4
ex)

package ch06.variable;

public class VariableTypes {
	int instanceVariable; // 인스턴스 멤버 변수
	static int classVariable; // 클래스 멤버 변수

	public static void main(String[] args) {// 파라미터 변수

		int localVariable = 10; // 로컬 변수
		for (int i = 0; i < 100; i++) { // 로컬 변수
			System.out.println(i);
		}

	}

}
//


----------------------------------------------------
3.2 인스턴스 멤버 변수의 특징 

인스턴스 멤버 변수는 클래스 영역에 static 키워드 없이 
선언된 변수. 
인스턴스 멤버 변수는 객체가 만들어질 때 객체별로 생성된다. 
생성되는 위치는 객체 내부이기 때문에 힙 영역.
생성 시점에 타입별로 초기화가 된다. 
초기값은 배열에서 각 요소의 타입별 초기값과 동일 .

자료형 : 기본값 : 비고 
boolean : false
char : '\u0000' : 공백문자
byte,short,int : 0
long : 0L
float : 0.0f
double : 0.0 
참조형 변수 : null : 아무 것도 참조하지 않음 

인스턴스 멤버변수는 객체 내부에 생성되기 때문에 각 객체의 소속이다. 
따라서 변수를 사용 할려면 , 객체를 생성 메모리에 올린 후,
객체 이름으로 접근한다. 
인스턴스 멤버변수의 값은 객체마다 생성되기 때문에 객체별로 
고유한 값, 즉 상태를 가질 수 있다. 
ex)
Person person1 = new Person();
person1.name = "홍길동";
Person person2 = new Person();
person2.name = "임꺽정";


인스턴스 멤버변수가 메모리에서 삭제되는 시점은 객체가 없어지는 
가비지 컬렉션이 일어나는 시점. 따라서 프로그램에서 이 변수를 
임의로 삭제할 수는 없다. 


----------------------------------------------------
3.3 클래스 멤버 변수의 특징 

클래스 멤버변수는 static 멤버변수라고도 한다. 
ex)
public class Person {
static String scientficName = "Homo Sapiens";
String name;
}

클래스 멤버변수는 클래스 영역에 클래스가 로딩되는 시점에 메모리에 생성되므로 
개별 객체의 생성과는 무관. 이 변수는 소속이 객체가 아니라 클래스다.
클래스 멤버변수는 같은 클래스를 통해 만들어진 모든 객체가 공유하게 
되므로 공유 변수라고도 불린다. 
클래스 멤버변수 역시 생성시 타입별로 기본 초기화가 된다. 

클래스 멤버 변수에 접근시 클래스 이름으로 접근하자. 
객체를 생성하고 객체 이름으로 접근도 가능 하지만,
적절한 방법은 아님.
컴파일러는 "The static field[클래스이름.변수명]
should be accessed in a static way"
라는 경고 메시지를 보낸다. 

ex)
Person p = new Person();
p.scientficName = "객체를 통한 부적절한 변경";
//The static field Person.scientficName 
should be accessed in a static way
Person.scientficName = "클래스를 통한 적절한 변경";
}

static 멤버변수가 소멸되는 시점은 프로그램이 종료되는 시점.

----------------------------------------------------
3.4 로컬 변수 (지역변수)의 특징 

클래스의 영역 이외의 모든 중괄호 안에 선언되는 변수.
메서드나 생성자의 내부 또는 파라미터 그리고 초기화 블록의 내부에 
선언된 변수들. 
ex)
void call(String to) {//파라미터 변수 
String beep ="띠"; // 로컬변수 
for (int i = 0; i<3 ; i++) { //로컬변수 
System.out.println(beep);
}
//System.out.println(i); 
//이제 i는 메모리에서 삭제된 상태
}

변수가 선언된 행이 실행될 때 스레드별로 생성된 메모리의 스택 영역에
생성되고 해당 영역(중괄호)이 끝나면 자동으로 삭제된다. 
예제에서 call() 메서드가 호출되는 시점에서 파라미터인 로컬변수
to가 생성되고 이후 변수 beep가 생성된다. 

for 문이 실행되면서 변수 i가 메모리에 추가되고 반복문 내부에서 
사용할 수 있게 된다. 이 시점에 beep 역시 아직 스택 영역에 남아
있고 사용가능. for 문을 벗어나면, 변수 i는 삭제되고 사용할수 
없게 되고 메서드가 종료되면서 로컬 변수 beep, to 의 순서로
스택에서 삭제된다. 

주의.
자바의 로컬변수는 멤버변수와 달리 자동으로 초기화가 이뤄지지 않는다. 
따라서, 로컬 변수는 사용하기전에 반드시 명시적인 초기화가 필요하다. 
다음 처럼 변수 localVariable을 선언만 하고 값을 할당하지 않은
상태에서 출력할 경우 오류가 발생한다. 
ex)
int localVariable;
System.out.println(localVariable);
//The loca variable localVariable may 
not have been initialized .
----------------------------------------------------

4. 메서드 

4.1 메서드 정의와 필요성 

객체가 하는 동작을 프로그래밍 에서는 메서드라고 부른다. 
어떤 작없을 수행하는 명령문(코드)의 집합으로 표현. 
메서드 작성 이유
반복적으로 사용되는 코드의 중복을 방지하고
코드의 양을 줄여 유지 보수성을 향상하기 위함. 

실습5
ex) 
class Person {

//메서드의 선언 
void printInfo(){
System.out.println(name + ":" + age);
}
} //Person

//호출 
Person p = new Person();
p.printInfo();

//메서드의 선언 (name -> userName 한번만 변경하면된다. )
void printInfo(){
System.out.println(userName + ":" + age);
}

----------------------------------------------------
4.2 메서드 작성 

파라미터, 실행문, 리턴 값 

선언부, 구현부로 나눈다. 
ex)
//선언부
제한자 리턴_타입 메서드이름(타입변수_명, 타입변수_명...)
//구현부
{
// do something
}

(1)선어부:리턴_타입
리턴_타입은 메서드 호출의 결과로 메서드를 호출한 곳으로 
돌려주는 값의 타입을 지정한다. 
결과 받는 곳 묵시적형변환이 가능. 
예)
add() 메서드는 int를 리턴하는데 이 메서드를 호출한 곳에서 
int 받거나, int 보다 큰 타입인 double로 받을 수 있다. 
ex)
//add 메서드가 호출되면 int 타입의 값이 반환됨 
public int add(int a , int b) {
return a+b;
}

//add 호출 결과를 int 타입의 result1에 할당 
int result1 = add(100,200);
//add 호출 결과를 double 타입의 result2에 할당 
double result2 = add(100,200);
System.out.println(result1 + ":" + result2);
//300 : 300.0 

메서드의 호출 결과 아무것도 리턴하지 않을 경우는 리턴_타입
void 라고 쓴다. 이 경우는 아무런 값이 없으므로 메서드 
호출 결과를 변수에 값을 할당한다거나 출력할수 없다. 

ex)
//sayHello 메서드는 아무런 값을 반환하지 않음.
public void sayHello(){
System.out.println("Hello");
}
//System.ou.println(sayHello());
//메서드 호출 결과가 없으므로 출력할 수 없음. 

메서드는 호출 결과로 리턴_타입에 해당하는 하나의 데이터만을 
리턴한다. 

다음 예는 Coffee[] 타입에 여러 개의 Coffee 객체를 
담아서 리턴하는 모습. 
ex)
//하나의 Coffee 객체를 리턴함
public Coffee getCoffee(){
return new Coffee();
}

public Coffee[] getCoffee(){
// 두 개의 Coffee 객체가 담긴 Coffee[] 배열 하나를 리턴함 
return new Coffee[] {
new Coffee(),new Coffee()};
}

다른 문제 , 동일 타입의 데이터만 리턴 가능하다. 
커피와 케이크를 주문 한다면?
타입이 달라 배열로 대체 안된다. 
이 때, 클래스 타입을 리턴 가능. 
클래스에 여러 개의 멤버 변수를 선언할 수 있음 기억.
다음 예 
Coffee 와 Cake 타입을 멤버 변수로 갖는 CoffeeSet 클래스 
정의하고, getCoffeeSet() 메서드에서 CoffeeSet을 리턴하는 형태 

ex)
class Coffee{}
class Cake {}
class CoffeeSet {
Coffee coffee;
Cake cake;
}

public CoffeeSet getCoffeeSet(){
return new CoffeeSet();
}

CoffeeSet set = getCoffeeSet();
System.out.println(set.coffee + ":" +set.cake);

이를 응용하여 로그인 시스템 만들어 보기.
아이디와 비밀번호를 사용자로부터 입력받아 로그인 성공 여부를 
true/false의 boolean 값으로 리턴한다. 
로그인에 실패 실패 이유를 String으로 리턴.
리턴 데이터는 boolean과 String으로 두가지.
아이디가 admin이고 비밀번호가 1234이면 로그인 성공.

로그인 시스템은 LoginResult , LoginSystem, 
LoginTest 3개의 클래스로 구성. 

먼저, LoginResult 클래스 만들기. 
이 클래스는 로그인 결과를 담아서 리턴한다.
로그인 결과는 성공여부(boolean)와 실패이유(String)
가져야 한다. 
클래스는 boolean 타입의 result와 String 타입의 
message를 멤버 변수로 갖는다. 
추가로 로그인 정보를 출력할 수 있는 메서드 
printResult()를 만들자. 
!

실습6
ex1)
package ch06.login;

public class LoginResult {
	boolean result;
	String message;

	public void printResult() {
		System.out.println(this.result + " : " + this.message);
	}
}

두번째 클래스는 LoginSystem.
로그인을 처리하는 doLogin() 메서드를 작성한다. 
doLogin() 에서는 String 타입의 id와 pass를 
파라미터로 받아서 각각 admin, 1234 와 비교 후 결과를 
LoginResult에 설정해서 리턴한다. 
    리턴되는 LoginResult 객체의 상태 
상황 : result : message
아이디/비밀번호 모두 맞음 : true : 반갑습니다.
아이디가 잘못된 경우 : false(기본값) : 아이디를 확인하세요.
비밀번호가 잘못된 경우 : false(기본값) : 비밀번호를 확인하세요. 

실습7
ex2)
package ch06.login;

public class LoginSystem {
	public LoginResult doLogin(String id, String pass) {
		LoginResult result = new LoginResult();
		if(id=="admin" && pass=="1234" ) {
			result.result = true;
			result.message=id+"님 반갑습니다.";
		}else if(id!="admin") {
			result.message = "아이디를 확인하세요.";
		}else {
			result.message="비밀번호를 확인하세요.";
		}
		return result;
	}
}

마지막 이 시스템을 사용하는 주체 LoginTest 클래스 
main() 메서드에서 LoginSystem 타입의 객체를 만들고 doLogin()
메서드를 사용 

실습8
ex3)
package ch06.login;

public class LoginTest {
	public static void main(String[] args) {
	    LoginSystem login = new LoginSystem();
	    LoginResult result = login.doLogin("hong", "1234");
	    result.printResult();
	    //false : 아이디를 확인하세요.

	    result = login.doLogin("admin", "12345");
	    result.printResult(); // false : 비밀번호를 확인하세요.

	    result = login.doLogin("admin", "1234");
	    result.printResult();// true : admin님 반갑습니다.
	  }
}

(2) 선언부 : 메서드 이름 
메서드 이름은 메서드를 호출할 때 사용하며 메서드에서 수행하는 
작업의 내용을 한눈에 파악하기 쉽게 의미 있는 단어를 이용하는게 좋다. 
기본적인 명명규칙은 변수의 명명규칙과 동일 

(3) 선언부: 파라미터 목록 
일반적인 변수를 선언하는 것처럼 변수의 타입과 변수명을 나열해서 
파라미터를 설정.
단, 선언만 가능하고 값 할당은 안됨.
파라미터값 전달은 호출되는 시점에

메서드가 호출되기 위해서는 선언된 파라미터와 동일한 개수의 파라미터가
제공되어야 하고, 묵시적형변환이 가능. 

ex) 
//메서드를 호출하기 위해 long과 long이 필요 
public long add(long a, long b){
return a + b;
}

add(10L, 20L); //적절 
add(100, 200); //적절 :묵시적형변환이 진행 
add(1.1, 2.2); //부적절 : long 에 double 할당 불가
add(100, 200 , 300); 
//부적절 : 파라미터의 개수가 다름 
add(100); 
//부적절 : 파라미터의 개수가 다름 

(4) 선언부:가변인자(Variable arguments)
메서드는 호출될 때 파라미터가 일치 해야 한다. 
만약, 더해야 하는 숫자의 개수가 다양한 경우,
파라미터 개수에 맞춰 메서드를 작성한다. 
대안 
배열을 파라미터로 받는다면 배열의 크기에 따라 더하기 가능.
하지만, 배열은 초기화하고 값을 할당하기 번거롭다.

이때 가변인자를 사용하면 이런 불편함을 해소해줄수 있다. 
내부적으로 사용하는데 별도의 초기화 과정이 필요 없고 
값을 할당할 때 단순히 나열해주기만 하면 된다. 
가변인자 표현 방식은 파라미터 타입과 변수명 사이에 
... 으로 표시.
의미 선언한 데이터 타입의 변수가 0개 이상 올수 있다. 

실습9
ex)
package ch06.method;

public class VariableArgsTest {

	public void add(int... params) {
		int sum = 0;
		for (int i : params) {
			sum += i;
		}
		System.out.printf("파라미터 개수: %d, 총 합: %d%n",params.length,sum);
	}
	
	public static void main(String[] args) {
		VariableArgsTest vt = new VariableArgsTest();
		vt.add(1, 2, 3, 4, 5);
		vt.add(1, 2, 3);
		vt.add();
	}

}
//
파라미터 개수: 5, 총 합: 15
파라미터 개수: 3, 총 합: 6
파라미터 개수: 0, 총 합: 0

(5)구현부 
중괄호{ } 내에서 처리해야 할 내용 즉 비즈니스 로직을 구성. 
구현부의 맨 마지막에는 선언된 리턴 타입에 해당하는 값을 return
문장과 함께 반환해야 한다. 
단 반환할 값이 없는 경우, 즉 리턴 타입이 void 인 경우는 
return 문장을 생략한다. 
값을 반환할때는 묵시적 형변환이 적용된다. 
즉 int를 리턴하기로 했을 때 int 보다 작은 byte,short,char
타입의 값도 리턴 가능하다.

예) int 리턴하도록 작성된 getNumber()에서 char 타입을 
리턴하는 예.
public int getNumber(){
return 'A';
}

메서드 수행 도중 return 문장을 만나거나 메서드의 마지막 문장을 
실행하면 메서드는 종료한다. 조건문 내에서 return을 사용하는 경우 
모든 조건에서 return 될수 있도록 주의.
각각의 조건에 따라 return 문장을 작성할수도 있지만,
조건에 맞게 값을 수정한 후 맨 마지막에 한 번만 반환하는 것도 
좋은 방법. 
예) 상황에 따라 매번 리턴하는 경우와 
상황에 따라 값만 바꾼 후 한번 리턴하는 형태 
비교

ex)
public double calc(double a, double b, char oper){
if (oper == '+'){
return a+b; // 조건별 결과값 반환 
}else if (oper == '-'){
return a-b;
}else{
return 0;
}
}

public double calc2(double a, double b, char oper){
double result = 0; //기준값 설정 
if (oper == '+'){
return a+b; // 로직에 따라 기준값 변경 
}else if (oper == '-'){
return a-b;
}
return result; // 기준값 반환 
}
}

----------------------------------------------------
4.3 메서드 호출

static 과 non-static 멤버 비교 
비고	:	static 멤버 : non-static 멤버 
소속	:	클래스		: 객체 
접근방법 같은 클래스 : 바로호출 : 바로호출 
접근방법 다른 클래스 : 클래스_이름.멤버_이름 : 객체_이름.멤버_이름 

중요한 점 : 호출하려는 멤버가 메모리에 있는가?
메모리에 있는 멤버는 소속(클래스 또는 객체)을 통해 
호출할 수 있고, 그렇지 않으면 먼저 객체를 생성해 메모리에 로딩 후 
사용한다 

static 붙은 메서드 : 클래스 메서드, 정적 메서드 
항상 메모리에 있다. 
같은 클래스 내에서 호출시 클래스 이름도 필요 없다. 

다음 예 두개의 클래스에서 서로의 멤버를 호출하는 다양한
상황을 보자 
ex)
public class First{
static int cv; //(1)
int iv; // (2)
static void cMethodA() {}//(3)
static void cMethodB() {}//(4)
void iMethodA() {} //(5)
void iMethodB() {} //(6)
void iMethodC() {} //(7)
void iMethodD(Second s){}//(8)
}

class Second{
static void cMethod() {} // (9)
void iMethod() {} // (10)
}
보기 
a: Second.cMethod(); s.iMethod();
b: cv = 100; cMethodB();
c: First f = new First(); f.iv=10; f.iMethodA();
d: iv = 100; iMethodA();
e: cv = 100; cMethodA();
f: Second.cMethod(); Second s = new Second();
s.iMethod();

문1) (3)의 구현부에서 (1)과 (4)를호출 할려면?
답: b: cv = 100; cMethodB();
문2) (4)의 구현부에서 (2)과 (5)를호출 할려면?
답: c: First f = new First(); f.iv=10; f.iMethodA();
문3) (5)의 구현부에서 (1)과 (3)를호출 할려면?
답: e: cv = 100; cMethodA();
문4) (6)의 구현부에서 (2)과 (5)를호출 할려면?
답: d: iv = 100; iMethodA();
문5) (7)의 구현부에서 (9)과 (10)를호출 할려면?
답: f: Second.cMethod(); Second s = new Second();
s.iMethod();
문6) (8)의 구현부에서 (9)과 (10)를호출 할려면?
답: Second.cMethod(); s.iMethod();

주의 문4) (6) 문6) 파라미터 값 주의 

(1) 메서드 호출 스택 
스택? 순차적으로 데이터를 쌓는 구조.
입구 = 출구 같다. FILO(First In Last Out) 
LIFO(Last In First Out ) 

메서드 호출 과정에서 메서드 호출 스택을 구성.
메서드를 쌓는다는 개념. 

모든 메서드는 호출 할 때마다 메서드 동작을 위한 메모리 상자를
하나씩 할당 받음.
상자 내부에는 메서드에서 사용되는 파라미터 변수 등 로컬 변수들이 저장. 
외부에서 상자에 접근 못함. 로컬변수들은 메서드 내부에서만 접근.

만약 A 메서드가 최초 호출. 스택 메모리영역에 A를 위한 상자 생성.
A에서 새로운 B 메서드 호출시 B 실행을 위한 메모리 상자를 A위에 
쌓는다. 
항상, 맨 위에 있는 상자만 동작한다는 점을 기억. 
이 때 A는 잠시 정지. 만약, B 메서드가 종료(return)하게 되면 
B 메서드를 위한 메모리 상자가 제거되고 메모리를 반납한다. 
다시 A가 최상위 메서드가 되어서 나머지 동작을 수행. 

실습10
ex)
package ch06.method;

public class MethodCallStack {
	public static void main(String[] args) {
		MethodCallStack mcs = new MethodCallStack();
		mcs.aMethod();
	}

	public void aMethod() {
		System.out.println("aMethod start");
		int age = 10;
		bMethod(age); // 새로운 메서드 상자 요청
		System.out.println("aMethod end");
	}

	public void bMethod(int age) {
		System.out.println("bMethod start");
		System.out.printf("나이는: %d%n", age);
		System.out.println("bMethod end");
	}
}
//
aMethod start
bMethod start
나이는: 10
bMethod end
aMethod end

(2) 기본형 변수와 참조형 변수의 전달 차이 

변수의 값이 파라미터로 전달될 때 기존의 값이 복사되어 전달. 
기본형 변수는 변수에 저장되는 것이 값 자체이고 
참조형 변수는 실제 객체가 아니라 객체에 대한 참조값이다. 

실습11
ex)
package ch06.method;

public class CallByTest {
	int memberVar = 10;

	static void change1(int var) {
		var += 10;
		System.out.printf("change1 : %d%n", var);
	}

	static void change2(CallByTest cbtl) {
		cbtl.memberVar += 100;
		System.out.printf("change2 : %d%n", cbtl.memberVar);
	}

	public static void main(String[] args) {
		CallByTest cbt = new CallByTest();
		cbt.memberVar = 5;
		System.out.printf("change1 호출 전 memberVar: %d%n", cbt.memberVar);
		
		change1(cbt.memberVar);
		System.out.printf("change1 호출 후 memberVar: %d%n", cbt.memberVar);

		change2(cbt);
		System.out.printf("change2 호출 후 memberVar: %d%n", cbt.memberVar);
	}
}
//
change1 호출 전 memberVar: 5
change1 : 15
change1 호출 후 memberVar: 5
change2 : 105
change2 호출 후 memberVar: 105



----------------------------------------------------
4.4 메서드 오버로딩

(1) 메서드 오버로딩이란?
단순 의미: 동일한 기능을 수행하는 메서드를 추가로 작성. 
메서드 오버로딩과 뒤에 나올 메서드 오버라이딩 구분하기.

메서드의 파라미터 값이 다른 메서드는 각각 다른 메서드이다. 
ex)
println 메서드 
System.out.println(1);
System.out.println('C');
System.out.println("hi");
각각 다른 메서드 
public void println(int x)
public void println(char x)
public void println(String x)

(2)메서드 오버로딩 방법 
동일 메서드에 파라미터의 개수 또는 파라미터의 타입을 다르게 작성. 

ex1)
add 메서드를 오버로딩 경우. 
//기본메서드 
int add(int a, int b) {
return a+b;
}
double add(double x, double y) {
return x+y;
}
int add(byte a, byte b){
return a + b;
}

ex2)
//파라미터의 이름만 다른 것은 의미 없음
int add(int x, int y) {
return x+y;
}
//리턴타입만 다른 것은 의미 없음
long add(int a, int b) {
return a+b;

ex3)
long add(long a, int b) {
return a+b;
long add(int a, long b) {
return a+b;

add(3,4)로 호출 하면 , 어떻게 되나?
중복 되어 오류 발생. 각각 자동 형변환이 일어남. 

(3) 메서드 오버로딩과 코드의 재사용 

예)
walk() 메서드.
walk(int distance) 오버로딩 
walk(int distance, String unit) 오버로딩 

실습12
ex)
package ch06.overloading;

public class WalkTestBad {
	void walk() {
		System.out.println("100cm 이동");
	}

	void walk(int distance) {
		System.out.println(distance + "cm 이동");
	}

	void walk(int distance, String unit) {
		switch (unit) {
		case "cm":
			break;
		case "inch":
			distance *= 2.54;
			break;
		default:
			System.out.println("unknown");
			distance = 0;
		}
		System.out.println(distance + "cm 이동");
	}
	public static void main(String[] args) {
		WalkTestBad wtb = new WalkTestBad();
		wtb.walk();
		wtb.walk(100);
		wtb.walk(100,"cm");
	}
}
//
100cm 이동
100cm 이동
100cm 이동

중복 코드 제거 System.out.println

실습13
ex2)
package ch06.overloading;

public class WalkTestGood {
	void walk() {
		walk(100, "cm");
	}

	void walk(int distance) {
		walk(distance, "cm");
	}

	void walk(int distance, String unit) {
		switch (unit) {
		case "cm":
			break;
		case "inch":
			distance *= 2.54;
			break;
		default:
			System.out.println("unknown");
			distance = 0;
		}
		System.out.println(distance + "cm 이동");
	}

	public static void main(String[] args) {
		WalkTestGood wtg = new WalkTestGood();
		wtg.walk();
		wtg.walk(100);
		wtg.walk(100,"cm");

	}

}
//
100cm 이동
100cm 이동
100cm 이동

메서드 안에서 또 메서드 호출 했음.

----------------------------------------------------
5. 생성자 

5.1 생성자의 형태 

생성자란 객체를 생성할 때 호출하는 메서드 비슷한 것을 말하는데
지금까지 new 키워드와 함께 호출했었다.
생성자에서는 주로 일반 멤버 변수의 초기화나 객체를 생성할 때
실행하는 작업을 정리한다. 

생성자는 메서드처럼 선언부와 구현부로 나뉘지만 선언부에서 
리턴타입 없고 이름은 클래스 이름과 똑같이 써야 한다. 

ex)
//선언부
제한자 클래스_이름(타입변수_명, 타입변수_명...)
{
//멤버 변수 초기화 작업 구현부
}

class Person{
String name;

public Person(){
name = "홍길동";
}
// 생성자에서는 주로 일반 멤버 변수의 초기화

----------------------------------------------------
5.2 생성자의 종류 

파라미터 유무에 따라 기본 생성자 , 파라미터 생성자 

(1) 기본생성자
파라미터가 없고, 구현부가 비어 있는 형태.
생성자 만든적 없는데 어떻게 호출?
만들지 않았을 때, 컴파일러에 의해 컴파일 타임에 자동으로 삽입.
주의. 별도의 생성자를 만들지 않을 때 생성.!!
일단 빈 객체를 생성 후 객체의 멤버 변수들을 별도로 설정.

실습14
ex)
package ch06.constructor;

public class DefaultPerson {
	String name;
	int age ;
	boolean isHungry;
	
	//public DefaultPerson() {} -- 생략된 기본 생성자

	public static void main(String[] args) {
		DefaultPerson person = new DefaultPerson();
		person.name = "홍길동";
		person.age = 10;
		person.isHungry = false;
	}
	
	void test() {
		new DefaultPerson();
	}
}

(2)파라미터 생성자
생성자가 파라미터 받는 형태.
주로 멤버변수 초기화에 사용.

ex)
package ch06.constructor;

public class ParameterPerson {
	String name;
	int age;
	boolean isHungry;

	// 생성자의 역할 : member 변수의 초기화..
	ParameterPerson(String n, int a, boolean i) {
		name = n;
		age = a;
		isHungry = i;
	}

	public static void main(String[] args) {
		ParameterPerson person = new ParameterPerson("홍길동", 10, true);
		//ParameterPerson p2 = new ParameterPerson();
		//파라미터 값 없는 생성자가 없어서 , 객체 생성 안됨.
		//기본생성자가 없을 때, 시스템에서 자동으로 만들어줌. 
	}
}


----------------------------------------------------
5.3 this의 용법 
this. this()
알아보기.

(1)객체를 참조하는 this 

현재 객체를 참조하기 위한 용도.
ex)
ParameterPerson(String name, int age, boolean isHungry) {
		name = name;
		age = age;
		isHungry = isHungry;
		
파라미터 이름을 멤버변수의 이름과 동일. 오류는 아니지만,
이것을 구분 하기 위해 this 사용. 
this는 참조변수로 나중에 메모리에 생성되는 객체 자신을 가리킴.

실습15
ex2)
package ch06.constructor;

public class ThisPerson {
	String name;
	int age;
	boolean isHungry;


	
	ThisPerson(String name, int age, boolean isHungry) {
		this.name = name;
		this.age = age;
		this.isHungry = isHungry;
	}

	String getPersonInfo() {
		return String.format("name: %s, age: %d, isHungry: %b", this.name, this.age, isHungry);
	}
	
	public static void main(String[] args) {
		ThisPerson person = new ThisPerson("홍길동", 20, true);
		System.out.println(person.getPersonInfo());
	}
}
//
name: 홍길동, age: 20, isHungry: true

this 는 객체에 대한 레퍼런스(참조값)이기 때문에 객체가 생성되기
전에는 사용할수 없다. 
static 영역에서는 this 키워드 사용 못함. 

(2) 다른 생성자를 호출하는 this 

파라미터를 다르게 해서 여러개의 생성자를 정의하는 것을 생성자 오버로딩.
오버로딩 에서 중복 코드 발생하여 다른 메서드 호출.
생성자에서도 중복 코드를 제거하기 위해 다른 생성자 호출 할 때 사용 this 

실습16
ex)
package ch06.constructor;

public class OverloadConstructorPerson {
	String name = "아무개";
	int age = 0;
	boolean isHungry = false;

	OverloadConstructorPerson(String name, int age, boolean isHungry) {
		this.name = name;
		this.age = age;
		this.isHungry = isHungry;
	}
	OverloadConstructorPerson(String name, int age){
		this(name, age, false);
	}

	OverloadConstructorPerson(String name) {
		this(name, 0, false);
	}

	OverloadConstructorPerson() {
		//System.out.println("first line");
		this("홍길동", 100, false);//Constructor call must be the first statement in a constructor 
	}
}
//
주의 
this 를 통한 생성자 호출은 생성자의 맨 처음 행에서만 가능. 


----------------------------------------------------
5.4 이클립스 에서 위저드를 이용한 파라미터 생성자 작성 

코드 편집창에서 우클릭- Source->Generate Constructor
Using Fields] 메뉴 선택.


----------------------------------------------------
6. 초기화블록

6.1 초기화블록의 특징  

객체의 초기화에 초기화 블록이 사용.
클래스 영역에 중괄호를 이용해 작성되며 이름이 없다. 
코드에 의해 호출 될수 없다. 
목적 멤버변수 초기화.
객채 생성 할수 없고, 파라미터를 받을수 없다.
외부에서 값을 받아서 멤버 변수에 할당도 못한다. 
초기화 과정에서 복잡한 로직이 들어가는 경우 사용한다. 

ex)
int iv;
static int cv;
static{
System.out.println("클래스 초기화 블록: static 멤버변수 초기화");
cv = 100;
}
{
System.out.println("인스턴스 초기화 블록: 인스턴스 멤버변수 초기화");
iv = 100;
}

----------------------------------------------------
6.2 초기화블록의 종류 

클래스 초기화 블록, 인스턴스 초기화 블록 
클래스초기화블록은 static 키워드가 추가된 초기화블록으로 
클래스 멤버 변수의 초기화에 사용. 클래스가 로딩될 때 JVM에 의해 
1회만 호출. 특정 객체 상관 없다. 

인스턴스 초기화블록 static 키워드가 없으며 인스턴스 멤버변수의 
초기화에 주로 사용. 
객체를 생성할 때마다 한 번씩 호출된다.
주의 생성자 보다 먼저 호출. 
ex)
객체생성 -> new 사용 -> 인스턴스 초기화블록 -> 생성자 코드. 

실습17
ex2)
package ch06.initializer;

public class InitializerTest {
	int iv;
	static int cv;

	static {
		System.out.println("static initializer");
		cv = 100;
	}

	{
		System.out.println("instance initializer");
		iv = 100;
	}

	public InitializerTest() {
		System.out.printf("constructor iv: %d, cv: %d%n", iv, cv);
		this.iv = 300;
	}

	public static void main(String args[]) {
		InitializerTest it = new InitializerTest();
		System.out.printf("객체 1 생성 후- cv: %d, iv: %d%n",InitializerTest.cv, it.iv);
		InitializerTest it2 = new InitializerTest();
		System.out.printf("객체 2 생성 후- cv: %d, iv: %d%n",InitializerTest.cv, it2.iv);
	}
}
//
static initializer
instance initializer
constructor iv: 100, cv: 100
객체 1 생성 후- cv: 100, iv: 300
instance initializer
constructor iv: 100, cv: 100
객체 2 생성 후- cv: 100, iv: 300


----------------------------------------------------
7 JavaDoc 주석 작성

자바의 도큐멘테이션 형태의 문서를 만드는데 사용하는 주석을 말한다. 
프로젝트 수행하면 대부분 메서드, 클래스의 용도가 무엇인지 설명을
문서로 남기는데 아주 번거롭다.
JavaDoc 주석을 이용해서 평소에 주석을 작성해 놓으면, 
편하게 문서를 생성할수 있다. 
Javadoc 주석은 클래스, 멤버변수, 메서드, 생성자에 대해 
/** 와 */ 사이에 주석 내용을 작성한다. 
ex)
package ch06.javadoc;
/**
 * 이 클래스는 자바의 도큐멘테이션 주석을 테스트하기 위한 클래스이다.
 * @author itsme
 *
 */
public class JavaDocTest {
	/**
	 * 멤버 변수에 대한 주석
	 */
	public int memberVar;

	/**
	 * 기본 생성자이다.
	 */
	public JavaDocTest() {
		System.out.println("기본 생성자");
	}
	
	/**
	 * 멤버 메서드에 대한 주석
	 * @param num	memberVar에 곱해지는 수
	 * @return		num과 memberVar의 곲을 리턴한다.
	 */
	public int multiPlyMemberVar(int num) {
		return memberVar * num;
	}
}

아직 생성된 것은 아니다. 

Java 가 설치된 경로의 bin 디렉터리에 있는 javadoc.exe 사용. 

1
해당 폴더 이동 .
ex)git이 할당이 된 폴더 위치
cd C:\Users\pc\git\java-kame
2
javadoc -encoding utf-8 -sourcepath ./src -subpackages ch06.javadoc -d ./mydoc

-encoding 옵션은 한글 데이터 처리를 위해 추가 
-sourcepath 옵션은 소스 파일의 위치를 나타내고 
-subpackages는 javadoc 을 생성할 패키지를 나열 
-d 옵션은 결과물을 출력할 디렉토리를 의미.

mydoc 디렉토리 생성되고, 그 안에서 여러 html 파일들이 있다. 
그중 index.html 더블 클릭하면 클래스 목록이 나오고 
JavaDocTest 클릭하면 소스코드에 대한 입력한 주석들을 문서로 확인 가능. 

3 이클립스를 통해서 간편하게 javaDoc 만들기 

이클립스 메뉴 - Project - Generate Javadoc 선택.

기본 선택하고 ,
옵션에서 
-encoding UTF-8
입력.


----------------------------------------------------
8. UML을 이용한 클래스 표현 

8.1 UML 소개 

Unified Modeling Language 의 약자.
표준화된 모델링 표기 체계를 이야기한다. 

클래스를 만들기 전에 이렇게 만들면 어떻까?
모델링 단계에서 사용.
클래스 이름, 속성의 이름, 타입, 메서드 이름,
파라미터, 리턴타입등 글보다는 그림을 그리는 방식 
표준화.

특징 
-가시화: 설계 내용을 가시적인 그래프 형태로 작성해서
이해 관계자 간의 의사소통 자료로 사용. 
-명세화: SW 개발 단계의 각 과정에 필요한 모델을 정확하고 완전하게
명세 
-구축화: 다양한 객체지향 프로그래밍 언어로 변환 가능 
(순공학, 역공학 적용)
-문서화 : 프로젝트 참여자들 간의 통제, 평가 및 
의사소통에 필요한 문서화 가능. 

순공학(Forward Engineering)
요구사항 정의 -> 분석 -> 설계 -> 구현 의 단계 
개발하는 것으로 일반적인 개발 절차를 말함. 
반대로 
역공학(Reverse Engineering)
구현->설계->분석->요구사항 정의 
만들어진 시스템을 역추적해서 처음의 문서, 
설계기법 등의 자료를 얻어내는 과정. 

----------------------------------------------------
8.2 클래스 다이어그램 

클래스의 구성 요소와 클래스 간의 관계를 묘사하는 
다이어그램.
클래스의 구성요소를 나타낼 때는 박스 모델을 이용해 
클래스 이름 및 멤버 변수, 멤버 메서드를 작성. 
클래스 간의 관계를 표현할 때는 선을 이용해 상속이나 
구현, 포함 등을 표시. 
하나의 클래스를 어떻게 클래스 다이어그램으로 표현하는지 보고,
나머지는 7장에서. 

클래스를 표현할 때 최상단의 박스에 클래스 이름을 표기.
필요에 따라 패키지 이름까지 표기.
멤버변수를 표시할 때 가시성(visibility), 변수의 
이름과 타입, 기본값을 정의.
가시성은 접근 제어자로 
public(+), protected(#),default(생략)
private(-) 4가지 레벨로 조절. 
용도는 7장에서 보기.

ex) ParameterPerson 클래스 에 대한 다이어그램으로
작성. 
ParameterPerson
name:String
age:int
isHungry:boolean
ParameterPerson(n:String, a:int, i:boolean)
+main(args: String[]):void 
!
@
설치 해보기.
StarUML Setup 3.0.2.exe 


===================================
[자바 해바라기 정리] 7 클래스의 관계
실습 27

1. 상속 

상속, 데이터 은닉과 보호, 다형성의 개념을 통해 어떻게 
클래스 간의 관계를 맺고 프로그램의 유지보수성을 향상 
시킬수 있는지 알아보자. 

1.1 상속의 정의와 구현 

Inheritance 상속, 중요한 개념.
ex) 부모의 재산을 상속,

자바에도 상속. 프로그램에서 상속은 기존 클래스의 재산을 
다른 클래스에서 재사용하기 위한 것.
재산: 기존 클래스에 있던 멤버(변수와 메서드)를 이야기.
생성자와 초기화블록은 상속의 대상 아니다. 

상속 물려주는 클래스 , 조상클래스, 부모클래스, 상위클래스,슈퍼클래스
라고 한다. 
상속 받는 클래스를 자식클래스, 자손클래스, 하위클래스, 서브클래스
라고 한다. 
상속의 관계를 UML 표시 하기 위해서는 실선의 화살표를 이용. 

ex) Person class, 를 상속받은 SpiderMan class 표현 

SpiderMan class -> Person class 

상속 관계 이야기 할 때, "is ~ a 관계"라 함. 
SpiderMan 은 Person의 모든 멤버를 가지고 있어서,
'SpiderMan is a Person'의 관계가 성립한다. 

상속받은 클래스는 물려받은 멤버들을 자신의 것처럼 
사용할 수 있고, 코드의 절감 효과.
부모코드를 변경하면 모든 자식 클래스들에게도 
적용되므로 유지보수성이 좋다. 

문법 
자식클래스 선언부에서 extends 키워드와 함께 조상클래스 이름 표시.
ex) class child_class_name extends super_class_name 

UML을 코드로 옮겨 보기. 
기본 Person class, 하나의 멤버 변수(name), 두개의 method (eat(), jump())
선언. 

실습1
ex)
package ch07.extend;

public class Person {
	String name;
	
	public void eat() {
		System.out.println("밥 먹기");
	}
	public void jump() {
		System.out.println("뛰기");
	}
}

Person을 상속받은 SpiderMan class ,
SpiderMan 은 추가로 boolean 타입의 변수 
isSpider와 fireWeb() 메서드를 작성한다. 

실습2
ex2)
package ch07.extend;

public class SpiderMan extends Person {
	boolean isSpider;

	public void fireWeb() {
		System.out.println("거미줄 발사");
	}
}

Person을 상속 받아서 SpiderMan이 가질 수 있는 멤버의
개수는 총5개.
부모클래스 Person에서 물려받은 멤버3개, 자식인 SpiderMan
에 선언된 고유 멤버 2개.

----------------------------------------------------
1.2 다양한 관계

(1)상속과 Object class
멤버를 확인하기 가장 좋은 방법은 객체를 만들고,
'.'(dot)을 통해서 객체가 접근 할수 있는 요소 확인방법.

SpiderManTest 라는 class 만들고 main 메서드에서 
SpiderMan 타입의 객체(sman)을 만든후 ,  어떤
멤버에 접근하는지 확인.
'sman.'까지 입력후 ctrl+space 입력.
Code Assist 동작. 팝업 표시 .

▲ fireWeb() : void - SpiderMan
▲ :접근 제한자 
fireWeb()  : 멤버이름 
void : 타입 또는 리턴_타입 
SpiderMan : 소속 class

접근 제한자는 뒤에서.

boolean 을 리턴하는 equals() method는 소속이 
느닷없이 Object로 나옴. 의외?

Object는 자바에서 아주 중요한 class. 
모든 class의 조상 class , 만약 class 선언부에 
명시적인 extends 선언이 없는 경우 무조건 
extends Object 코드 생략된거다. 
Person 도 별도의 extends가 없어서 생략 되었음. 

UML 로 표현. 

SpiderMan class -> Person class -> Object class
Person은 Object를 상속 받아서 Object의 모든 
멤버를 물려 받았고, 
SpiderMan은 Person을 상속 받아서,
Person , Object 의 멤버를 모두 가지고 있다. 
Object를 뒤에서 

(2) 단일 상속 지원 
SpiderMan class -> Person class-> Object class
Employee class-> Person class-> Object class

SpiderMan 과 Employee 는 형제? 그런거 없음. 

하나의 class를 여러 class가 상속받는 것 문제 안됨.
다중 상속은 안됨.

만약, 다중 상속을 받는 다 하면, 두 class의 같은 method
를 호출시 문제.
이런 문제를 극복하기 위해, 나중에 interface 포함 관계 사용. 

(3)포함관계
연관 관계 또는 'has a' 관계로 불린다. 
상속 이외의 클래스를 재활용하는 방법. 
상속 받고, 나머지 class들은 멤버 변수로 처리해서 
사용하는 것.
UML 로 실선이 포함관계.
ex)
Spider class --- SpiderMan class -> Person class

멤버변수로 다른 객체를 갖게되면 필요할 때 
해당 객체의 속성과 기능을 사용할 수있다. 
즉 거미줄 발사하고 싶으면 Spider 타입의 멤버변수가 
가지고 있는 fireWeb() 메서드를 호출하면된다. 

실습3
ex2)
package ch07.extend;

public class Spider {
	public void jump(){
		System.out.println("키 * 1000만큼 엄청난 점프");
	}
	
	public void fireWeb(){
		System.out.println("거미줄 발사");
	}
}

실습4
ex3)
package ch07.extend;

public class SpiderMan2 extends Person {
	Spider spider = new Spider();
	boolean isSpider;

	public void fireWeb() {
		if (isSpider) {
			spider.fireWeb();
		} else {
			System.out.println("Person은 거미줄 발사 불가");
		}
	}

	@Override
	public void jump() {
		if (isSpider) {
			spider.jump();
		} else {
			//System.out.println("뛰기");
			super.jump();
		}
	}
}

SpiderMan2는 Spider를 'has a' 관계로 포함하면서
Spider class 에 있는 기능, 속성들을 사용가능.
Spider의 코드를 수정하면 자동으로 SpiderMan2도
변경된 코드를 사용하므로 유지보수성이 좋다. 

어떤 class를 포함하는게 좋을까? 상속?
'is a', 따져보고, 프로젝트 관점에 따라 다르다.

----------------------------------------------------
1.3 메서드 오버라이딩

ex) 3대 걸친 맛집.
조상이 물려준 방식대로만 요리 안한다. 
자식들이 새로운 요리법을 만든다.

조상클래스에 정의된 기능을 자식클래스에 적합하게
수정해서 재정의하는 것을 메서드 오버라이딩
overriding: 재정의 

오버로딩 추가 적재(메서드 추가)
오버라이딩 기존 메서드 재정의 개념.
기존 메서드위에 덮어쓰기 개념.

메서드 오버라이딩 5개 규칙
1) 메서드 이름은 조상클래스의 메서드 이름과 같아야한다.
2) 매개변수 개수,타입, 순서는 조상클래스의 메서드와 같아야한다.
3) 리턴타입은 조상클래스의 메서드와 같아야한다
4) 접근제한자는 조상클래스의 메서드보다 범위가 같거나
넓어야 한다. 
5) 조상클래스의 메서드보다 더 상위의 예외를 던질수없다.

4),5) 잠시 보류.
선어부 동일하고, 구현부만 다시 작성하는 것.

Person class 에 jump 기능을 정의.
SpiderMan은 처음부터 jump 할수 있었다.
그러나, Person의 jump는 두 다리로 뛰는 것.
SpiderMan이 멤버로 가진 Spider는 키의 1000배 만큼 뛰다.
이것을 활용. 

따라서  SpiderMan2는 과감하게 조상인 Person이 물려준 
jump()를 재정의해서 평상시에는 사람처럼 뛰다가,
isSpider가 true인 상황에서는 Spider의 jump()를 사용. 

SpiderMan2의 jump() 동작을 보자.
main()에서 SpiderMan2 객체를 만들고 jump를 호출 .

실습5
ex)
package ch07.extend;

public class SpiderManTest2 {

	public static void main(String[] args) {
		SpiderMan2 sman = new SpiderMan2();
		System.out.println("거미 모드로 변신:");
		sman.isSpider=true;
		sman.jump();
		System.out.println("사람 모드로 변신:");
		sman.isSpider=false;
		sman.jump();
	}
}
//
거미 모드로 변신:
뛰기
사람 모드로 변신:
뛰기


코드를 작성하는 중에 'sman.' 까지 입력후 ctrl +space
확인. 
jump()는 Person class에서 정의된 class
실행 결과를 보면 isSpider의 값과 상관없이 
언제나 Person에 정의된 대로 살짝 뒤는 수준. 

SpiderMan2에서 jump() 오버라이딩

실습6
package ch07.extend;

public class SpiderMan2 extends Person {
	Spider spider = new Spider();
	boolean isSpider;

	public void fireWeb() {
		if (isSpider) {
			spider.fireWeb();
		} else {
			System.out.println("Person은 거미줄 발사 불가");
		}
	}

	@Override
	public void jump() {
		if (isSpider) {
			spider.jump();
		} else {
			//System.out.println("뛰기");
			super.jump();
		}
	}
}
거미 모드로 변신:
키 * 1000만큼 엄청난 점프
사람 모드로 변신:
뛰기

다시, SpiderMan2Test2 를 에서,
sman.jump 를 보면 SpiderMan2에서의 메서드이다. 
SpiderMan2가 상속받아 가지고 있던 jump()가
재정의 된것. 

애노테이션
컴파일러등을 위한 주석으로 8장에서 상셓.
@Override는 이 메서드는 재정의한 메서드이니까,
메서드 오버라이딩 규칙에 맞지 않으면 오류를 발생 
시켜라. 정보를 컴파일러에게 전달. 

잠시,
jump() 구현부를 보면 isSpider가 false일 경우의 동작인 
System.out.println("뛰기")
라는 부분이 Person의 그것과  동일하다. 코드 중복. 

어떻게 조상클래스의 메서드를 호출?

----------------------------------------------------
1.4 super 키워드

(1) 조상의 멤버를 참조하는 super 
this를 통해서 객체의 멤버에 접근 하듯이 
super를 통해서 조상의 멤버에 접근. 
this 는 현재 객체 참조.
super는 조상 객체 참조. 
전 
	public void jump() {
		if (isSpider) {
			spider.jump();
		} else {
			System.out.println("뛰기");
			//super.jump();
		}
	}
후
	public void jump() {
		if (isSpider) {
			spider.jump();
		} else {
			//System.out.println("뛰기");
			super.jump();
		}
	}
3개의 jump 메서드를 가지게 되었고,
SpiderMan 입장에서 각각을 참조하는 방법. 

super 와 this는 아주 유사. 
멤버참조 역할. static 영역에서는 사용 목함. 
둘다, 어떤 객체에 대한 참조 인데 static 영역은 
객체가 없는 상태에서도 호출될수 있어야 하므로.

조상의 조상 메서드에 접근 불가.
super.super.jump() 안됨.
1촌까지만.

변수는 자신이 선언된 곳에서 부터 점점 영역을 확장해가며
최초로 만난 선언부에 연결된다는 점.
즉,
메서드 내부에서 사용된 변수는 
메서드 내부의 로컬변수-> 해당 클래스 멤버 변수 ->
부모클래스 멤버변수->조상클래스 멤버변수로 확장해 가며
선언된 곳을 찾아간다. 
그러나, 최상위 객체인 Object까지 찾아봤지만, 선언된 
변수가 없으면 오류가 발생. 
this 로 접근할 때는 로컬 변수에서 찾는 것은 생략하고 
해당 클래스의 멤버변수 부터 검색한다. 
물론, 
super 로 접근할 때는 부모 class의 멤버변수 부터 찾는다. 

다음 예 
조상클래스와 자식클래스, 메서드 내부에 동일한 이름의 
변수가 선언되어 있을때 실제로 어떤 변수를 찾아가는지 확인 
하는예.

실습7
ex)
package ch07.extend;

class Parent {
	String x = "parent";
}

class Child extends Parent {
	String x = "child";

	void method() {
		String x = "method";
		System.out.println("x : " + x);
		System.out.println("this.x : " + this.x);
		System.out.println("super.x : " + super.x);
	}
}

public class ScopeTest {

	public static void main(String[] args) {
		Child child = new Child();
		child.method();
	}
}
//
x : method
this.x : child
super.x : parent

만약, 11행 주석	
//	String x = "method";
//
x : child
this.x : child
super.x : parent

만약, 8행 주석	
//String x = "child";
x : parent
this.x : parent
super.x : parent

부모를 찾아 간다. 

(2) 조상의 생성자를 호출하는 super 
this가 자신의 다른 생성자를 호출 했던것처럼 
super는 조상의 생성자를 호출할수있다. 

어떤 코드에서 자식 class 타입 객체를 만들때 초기화 파라미터
를 넘겨주게된다. 
이 파라미터 중에는 자식 class가 선언한 멤버 변수도 있지만,
조상 class에서 선언된 멤버 변수들도 포함될 수 있다. 
조상 클래스에 선언된 멤버 변수들은 조상 클래스의 생성자에
의해 초기화가 이루어지므로 조상 클래스의 생성자를 
호출해서 초기화하고 
자식클래스에서는 자식이 선언한 멤버변수들만 초기화를 진행하면된다. 
이때 조상클래스의 생성자를 호출하기 위해 super()가 사용된다.

실습8
ex)
class Phone {
String number;

public Phone(String number){
this.number = number; //-->위에 String number 가리키고
}
}

class HandPhone extends Phone {
int price;
public HandPhone(String number, int price) {
super(number); // class Phone의 생성자 public Phone(String number)가리킴.
this.price = price; // class HandPhone의 int price 가리킴. 
}
}

this()의 호출은 언제나 생성자의 첫번째 행에만 올수 있다. 
super()도 마찬가지로 생성자의 첫번째 행에만 올수 있다. 

또, 명시적으로 this() 또는 super()를 이용해서 다른 생성자를 
호출하는 코드가 없다면 컴파일러는 언제나 조상의 기본 생성자를
호출하는 super()를 생성자의 첫 행에 삽입하게 된다. 

실습9
ex)
class Person2 {
String name;

Person2(String name){
// super(); // 자동 삽입된 super() --> Object의 기본 생성자 호출.
this.name = name;
}
}

this(), super() 호출에 따라 코드 검토하고 어떻게 동작하는지 보기.

실습10
ex)
package ch07.extend;

class Person2 {
	String name;
	Person2(String name) {
		// super();		// --> Object의 기본 생성자 호출
		this.name = name;
		System.out.println("Person2(String name) 끝");
	}
}

public class SpiderMan3 extends Person2 {
	Spider spider;
	boolean isSpider;

	SpiderMan3(String name, Spider spider, boolean isSpider) {
		super(name);
		this.spider = spider;
		this.isSpider = isSpider;
		System.out.println("SpiderMan3(String name, Spider spider, boolean isSpider) 끝");
	}

	SpiderMan3(String name) {
		this(name, new Spider(), true);
		System.out.println("SpiderMan3(String name) 끝");
	}

	public static void main(String[] args) {
		SpiderMan3 sman = new SpiderMan3("피터 파커");
	}
}
//
Person2(String name) 끝
SpiderMan3(String name, Spider spider, boolean isSpider) 끝
SpiderMan3(String name) 끝

----------------------------------------------------
2. 패키지(package)와 임포트(import)

2.1 패키지(package)

예)윈도우즈 많은 파일 관리 디렉터리이용.

많은 클래스들을 체계적으로 관리 필요. 
자바는 디렉터리 대신 패키지라는 것을 사용. 
패키지이름 포함된 클래스들의 용도를 유추할수 있는 의미 
있는 이름으로 작성. 
패키지는 필요에 따라 하위 패키지를 둘수있고, 
각 단계는 '.' dot 를 이용해 구분한다. 
ex)
package ch06.method.call;

ch06->method->call 하위 폴더 로.

선언 package 키워드 쓰고, 뒤에 . dot 로 연결해서 표시. 
package 키워드는 주석,공백을 제외하고 소스파일의 
첫번째 문장에 단 한번만 등장. 
패키지를 선언하지 않으면 기본 패키지에 속한다. 
이것은 바탕화면에 마구 파일을 저장하는 것과 같다. 

만들때 규칙. 
맨처음에는 회사등 소속. 도메인을 거꾸로 사용. 
예)
example.com 회사이면 
com.example 형태 
인사관리(Human Resource Management) 프로그램이라면 
hrm 정도. 
공통적인 내용을 담는다. common. 
서비스 로직 service
ex)
package com.example.hrm.common;
package com.example.hrm.service;
 ----------------------------------------------------

2.2 임포트 (import)

다른 패키지에 선언된 클래스를 사용하기 위해 필요한 키워드 .
import는 package 선언과 class 선언사이에 위치하며
package 선언과 달리 필요한  클래스가 있을 때마다 사용 

import 선언시 , 키워드 뒤에 package 이름을 포함한 class명까지 
모두 입력하거나, 해당 package의 모든 클래스를 포함할 때, '*'
를 사용한다. 
단, '*'를 사용한다고 해도 하위 패키지에 있는 클래스까지 
import 하지는 않는다. 
ex)
import package_name.[package_name.]class_name;
import package_name.[package_name.]*;

임포트시 중복되는 경우 
ex)
java.util , java.awt 패지에 List 클래스가 각각 있다. 
만약, 두개의 List 클래스를 동시에 사용하기 위해서는 
둘다 import하고 클래스 내부에서 List라고만 쓰면 
구분이 안된다. 
둘중 하나의 클래스만 import 하고,
다른 클래스는 이름 앞에 전체 패키지명을 입력해서 사용. 

실습11
ex) 
package ch07.imp;

import java.io.InputStream;	// 특정 클래스 import
import java.util.*;			// java.util 패키지의 모든 클래스 import

public class ImportTest {
	Date date;	// java.util 패키지의 클래스
	List list;	// java.util 패키지의 클래스
	
	InputStream input;
	
	java.awt.List list2;	//동일한 이름의 List를 위해 패키지 이름 사용
}
//

작성한 소스들 중 만들지 않은 클래스가 많다. 
System , String, Object 와 같은 클래스들. 
이 모두 java.lang 패키지에 속해 있다. 
그리고, 자주 쓰여서 자동으로 import되어 있다. 

자동 import 기능 
프로젝트의 클래스 패스에 포함된 클래스 중에서 이름 기반으로 
원하는 클래스를 찾아서 자동으로 import 문장을 만들어 준다. 
사용법 
클래스를 import 없이 쓰고 "ctrl + shift + O" 입력 

(1)정적 임포트 (static import)

static import는 static으로 설정된 멤버에 대해 바로 import처리.
이런 멤버들을 호출할 때 클래스 이름을 생략하고 바로 사용. 

실습12
ex)
package ch07.imp;

import static java.lang.Math.random;
import static java.lang.System.out;


public class StaticImportTest {

	public static void main(String args[]) {
		out.println(random());
	}
}

실습13
ex2)
package ch07.structure; //패키지 선언부

import java.io.*; //외부 패키지 import 

public class ClassStructure { // 클래스 선언부
	String name;  //멤버 변수 
	int age; 
	
	{
		name="andy";   //초기화블록 
	}
	
	public ClassStructure(String name, int age) {  //생성자 
		this.name = name;
		this.age = age;
	}
	
	public void setName(String name) {  //멤버 메서드 
		this.name = name;
	}
	
	public String getName() {  //멤버 메서드 
		return this.name;
	}
	
	public static void main(String [] args) {
		ClassStructure cs = new ClassStructure("hong", 10);
	}
}


----------------------------------------------------
3. 제어자 

3.1 제어자(modifier)

클래스, 변수, 메서드의 작성 시 같이 사용. 부가적인 의미를 부여해주는 
키워드. 종류는 2가지.

접근 제어자
접근 제어자는 멤버 변수등을 사용할 수 있는 범위를 지정하는 키워드.
 public, protected, (default = package), private 
 
 그외의 제어자
 static, final, abstract, synchronized , 이절에서는 final 에 대해서.
 abstract 는 추상클래스에서 
 synchronized는 14장에서 
 
 하나의 대상에 여러 제어자를 조합해서 사용 가능하지만, 
 하나만 사용.  순서는 무관.
접근제어자를 앞에 쓰고 , 뒤에 나머지 제어자 사용. 

ex) 클래스 생성할 때 , New Java Class 대화상자에서
Modifiers 에서 접근제어자는 라디오 버튼 적용돼,
하나만 선택, 나머지는 체크 박스라 동시에 여러개 사용 가능. 

(1) final 
마지막, 더는 바뀔수 없음. 
class, 메서드, 변수에 사용 가능. 
final 선언된 class는 더는 확장 못함. 
클래스 레벨에서의 확장이란 상속을 의미.
final 클래스는 상속 받을 수 없는 클래스.

어떤 경우에 사용? final 클래스 

상속을 하면 메서드를 오버라이딩해서 원하는 형태로 변경 가능.
그래서, 최초 의도했던 메서드의 방향과 다른 방향으로 바꿀수 있다. 

그러면, Math 클래스, random() 메서드 를 오버라이딩 한다고 하면,
기존 메서보다 더 좋게, 또는 잘못 재정의 할수 있다는 말. 
그래서, final를 String, Math 같은 클래스에 지정해서, 
완변한 클래스로 생각하고 사용. 

 final , 상속 안되니, 오버라이딩도 안됨. 
 
 final 메서드는 final 클래스의 제한을 메서드 레벨에서 설정한 것. 
클래스 자체는 상속받도록 허용하지만, 특정 메서드만 오버라이딩
못하게 하는 것. 

final 변수는 더이상 값 변경 불가. 
변수를 상수화해서 읽기 전용으로 사용.

final 변수는 초기화 과정에 주의. 
final  변수는 선언과 동시에 초기화하는 경우가 많다. 
만약, 만들면서 초기화를 진행하지 않는 경우가 발생.
이를 blank final 변수라 함. 
blank final 변수  를 사용할 경우, 객체마다 다른 값을 가져야 하는데,
객체 내에서 값을 바꿀 수 는 없게 하려는 경우. 
초기화를 위해서는 생성자를 이용하는 수밖에 없다. 
생성자에서 초기화를 처리 하지 않으면 오류 발생. 
참고,
로컬변수는 초기화하지 않고 사용하면 오류가 발생.

실습14
ex) 
public class BlankFinalTest {
// The blank final field name may not have been initialized 
final String name; // 초기화 해주는 생성자가 없으므로 오류 발생. 
} 

ex2) 
package ch07.modifier;

class FinalMemberClass {
	final String name;  
	// name 변수가 final 인데 값이 할당되지 않은 blank final 형태. 

	// 생성자를 통해서 blank final 변수에 값 할당. 
	public FinalMemberClass(String name) {
		this.name = name;
	}
}

public class BlankFinalTest {
	public static void main(String[] args) {
		FinalMemberClass fmc1 = new FinalMemberClass("hong");
		FinalMemberClass fmc2 = new FinalMemberClass("lim");

		System.out.printf("name: fmc1 - %s, fmc2 - %s%n", fmc1.name, fmc2.name);
		//The final field FinalMemberClass.name cannot be assigned
		//fmc1.name = "kim";  
	}
}
//
name: fmc1 - hong, fmc2 - lim



----------------------------------------------------
3.2 접근 제어자

멤버등에 사용 해당요소를 외부에서 사용할수 있게 할 것인지를 제어. 
종류 
public, protected, default(=package), private
default 는 별도의 키워드 없이 접근 제어자를 생략 하는 것. 
클래스, 생성자, 멤버에 사용 가능. 
클래스 레벨에서는 public과 default만 사용 가능. 

구분   :클래스 :  생성자  :  멤버 
public : 가능 		: 가능  : 가능 
protected :불가능:가능	:가능
default:  가능 		: 가능  : 가능 
private :불가능	:가능	:가능

접근 가능한 범위. 
public : 어디서든 다 접근 가능. 
protected : 같은 클래스나 같은 패키지, 패키지가 달라도 
자손클래스에서 접근 가능. 
default : 같은 클래스나 같은 패키지에서만 접근 가능. 
private : 같은 클래스만 가능. 

구분  : 같은 클래스 :  같은 패키지 :  다른패키지자손클래스 : 전체 
public:  가능: 가능: 가능:가능 
protected:  가능: 가능: 가능:불가능
default(package):  가능: 가능: 불가능:불가능 
private:가능:불가능:불가능:불가능

ex) 접근 여부 확인 해보기. 
같은 패키지 
package ch07.modifier.p1

class Parent 

SamePackageChildClass

SamePackageSomeClass


다른  패키지 
package ch07.modifier.p2

OtherPackageChildClass

OtherPackageSomeClass

실습15
ex) 
package ch07.modifier.p1;

public class Parent {
	public int publicVar;
	protected int protectVar;
	int defaultVar;
	private int privVar;
	
	public void useMember() {
		this.publicVar = 10;
		this.protectVar = 10;
		this.defaultVar = 10;
		this.privVar = 10;
	}
}

실습16
ex2)
package ch07.modifier.p1;

public class SamePackageChildClass extends Parent {
	public void useMember() {
		this.publicVar = 10;
		this.protectVar = 10;
		this.defaultVar = 10;
		//The field Parent.privVar is not visible
		//this.privVar = 10;
	}
}

실습17
ex3)
package ch07.modifier.p1;

public class SamePackageSomeClass {
	public void method() {
		Parent p = new Parent();
		p.publicVar = 10;
		p.protectVar = 10;
		p.defaultVar = 10;
		//The field Parent.privVar is not visible
		//p.privVar = 10;
	}
}

실습18
ex4)
package ch07.modifier.p2;

import ch07.modifier.p1.Parent;

public class OtherPackageChildClass extends Parent {
	public void useMember() {
		this.publicVar = 10;
		this.protectVar = 10;
		// The field Parent.privVar is not visible
		//this.defaultVar = 10;
		// this.privVar = 10;
	}
}

실습19
ex5)
package ch07.modifier.p2;

import ch07.modifier.p1.Parent;

public class OtherPackageSomeClass {
	public void method() {
		Parent p = new Parent();
		p.publicVar = 10;
		//The field Parent.privVar is not visible
		//p.protectVar = 10;
		//p.defaultVar = 10;
		//p.privVar = 10;
	}
}

멤버를 만들고 사용 못하게 할까?
신뢰도?
실생활 예)
부모님만 간직하고 싶은 비밀 (private)
같은 집(package) 사는 사람들(default)까지.
같은 집에 안 살아도 자식들(protected) .
모든 이가 다 아는 public
!
메서드 오버라이딩 조건,
부모 메서드의 접근 제어자와 같거나 넓어야 한다. 규칙.
ex)
부모 클래스 메서드가 protected 로 선언돼 있다면 
자식 클래스에서는 public, protected 제한. 

private < default < protected < public

실습20
ex)
package ch07.modifier;

class Parent{
	protected void method() {}
}

public class OverrideRule extends Parent{
	@Override
	// Cannot reduce the visibility of the inherited method from Parent
	//void method() {}
	protected void method() {}
	//public void method() {}
}

----------------------------------------------------
3.3 데이터 은닉과 보호

Encapsulation 

실생활로 
우리가 가진 멤버 변수에 은행 잔고도 있다. 
만약, 이 멤버변수를 모두가 접근할 수 있다면 (public)
어떻게 될까?
잔고도 얼마나 있는지 조회가 되고, 심지어 깡통 계좌로
만들수 있다. 

실습21
ex)
package ch07.modifier.encapsulation;

class UnbelievableUserInfo {
	//이름은 null이 될 수 없음.
	public String name = "홍길동";
	// 계좌는 0보다 커야 함.
	public int account = 10000;
}

public class UnbelievableTest {
	public static void main(String[] args) {
		UnbelievableUserInfo info = new UnbelievableUserInfo();
		System.out.printf("사용자 정보:%s, %d%n", info.name, info.account);
		info.name = null;
		info.account = -1000;
		System.out.printf("사용자 정보:%s, %d%n", info.name, info.account);
	}
}
//
사용자 정보:홍길동, 10000
사용자 정보:null, -1000

이름 변경, 마이너스 통장으로 됨. 
이유? 외부에서 변수에 직접 접근하기 때문.
할당되는 과정에서 무언가 보호장치가 개입될 여지가 없어서,

직접 접근 막기. 접근 제어자 이용.
소중한 데이터인 멤버 변수들 모두 private 접근 제어자를 
갖는다. 이제 멤버변수가 선언된 클래스에서만 해당 멤버변수에 직접 
접근이 가능.
그럼 외부에서 변수를 사용하는 방법?
직접적으로는 접근할 수 없다. 
대신 public 등으로 공개되는 메서드를 제공해서 private
멤버에 접근할 수 있는 통로로 활용한다. 
값을 조회하는 메서들의 이름은 get으로 시작하고
이런 부류를 getter라고 부르고, 값을 설정하는 메서드들의
이름은 set으로 시작하며 setter라고 한다. 
통로로 활용되는 메서드 내에는 정보 보호를 위한 필요한 로직을 넣을 
수 있으므로 부적절한 값의 설정을 방지 할수있다.
getter 에서는 필요에 따라 권한 정보를 요구해서 권한이
있는 사용자가 값을 조회하게 할수있다
setter에서는 설정되는 값이 처음 의도한 범위내에 있는지 확인한 후 
안전한 값만 설정할수 있도록 처리한다. 

이과정을 데이터 은닉과 보호, 즉 Encapsulation이라한다. 

실습22
ex)
package ch07.modifier.encapsulation;

class BelievableUserInfo {
	private String name = "홍길동";
	private int account = 10000;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		if(name!=null) {
			this.name = name;
		}else {
			System.out.println("부적절한 name 할당 시도 무시: "+name);
		}
	}
	
	public int getAccount() {
		return this.account;
	}
	
	public void setAccount(int account) {
		if(account>0) {
			this.account = account;
		}else {
			System.out.println("부적절한 account 할당 시도 무시: "+account);
		}
	}
}

public class BelievableTest {
	public static void main(String[] args) {
		BelievableUserInfo info = new BelievableUserInfo();
		//System.out.printf("사용자 정보:%s, %d%n", info.name, info.account);
		System.out.printf("사용자 정보:%s, %d%n", info.getName(), info.getAccount());
		//info.name = null;
		info.setName(null);
		//info.account = -1000;
		info.setAccount(-10000);
		System.out.printf("사용자 정보:%s, %d%n", info.getName(), info.getAccount());
	}
}
//
사용자 정보:홍길동, 10000
부적절한 name 할당 시도 무시: null
부적절한 account 할당 시도 무시: -10000
사용자 정보:홍길동, 10000

생성자 코드와 마찬가지로 getter , setter 의 기본 형태도 
단순하고 반복되는 코드들이다.
이클립스 위저드를 이용해 코드들을 자동으로 생성할 수 있는 기능을 
알아보자. 
편집 창 우클릭 -> Source -> Generate Getters and 
Setters] 메뉴 클릭. 생성할 멤버 변수들을 체크하여 선택. 
개별 선택 가능. 
이미 소스 코드 가 표시된 부분은 안보임. 
필요한 경우 하단의 접근제어자 변경 가능. 


----------------------------------------------------
3.4 객체의 생성 제어와 Singleton 디자인 패턴 

주변에 객체를 마구 만들 수 없거나, 만들 필요가 없는 상황이 존재한다. 
비싼집 마음대로 new 해서 가질수 없고,
편의점에 나에게만 서비스할 직원도 필요 없고,
단지 그 직원을 모든 손님이 공유하고,
자신의 정보를 직원에게 줄 필요도 없다. 

프로그램도 마찬가지.
객체가 여러개 필요한 경우는 객체마다 가지는 멤버변수의 값이 다를 
경우.
그래서, 멤버변수가 없거나, 같은 값만 사용된다면 굳이 
여러 객체를 만들어 사용할 필요가 없다. 

자바에서 데이터베이스를 사용하기 위해서는 
java.sql.Connection 타입의 객체가 필요한데,
이 객체는 네트워크를 통해 애플리케이션과 데이터베이스를 연결
하는 비싼 자원이다. 프로그래밍에서 비싸다라는 말은 
시간이 오래 걸리거나 메모리등의 시스템 리소스가 많이 드는 것을 이야기 한다. 
따라서 계속 연결과 반환을 반복하는 것 보다는 하나 또는 몇개를 
미리 만들어 놓고 재사용하는 것이 유리.

개념은 정의했지만, 막상 구현이 어려움. 
이럴 때 프로그래밍에서 선배들이 미리 정의해 놓은 것을 
디자인 패턴이라고 한다. 

디자인 패턴이란 같은 상황에 부딪쳤던 많은 개발자가 이뤄낸 작업의
정리 결과로 반드시 따라야하는 법칙은 아니지만,
어떤 목적을 달성하기 위한 프로그래밍 가이드 정도로 생각. 
디자인 패턴을 이용하면 특정 목적의 작업을 효율적으로 처리 가능. 

이 문제를 처리하기 위한 디자인 패턴에는 싱글턴 디자인 패턴이 있다. 
Singleton class 구현해보자. 

싱글턴 디자인 패턴의 출발점은 대상 객체를 외부에서 직접 생성할 수 
없었다 한다. 그래서 생성자에는 private 접근제어자를 
사용해서 외부에의 노출을 차단한다. 

private SingletonClass() {}

이제 이 생성자에 접근할 수 있는 것은 이 클래스 내부만 가능. 
따라서 내부에서 자신의 객체를 생성하고 멤버변수에 저장. 
소중한 멤버변수이므로 private 접근제어자를 적용한다. 

private SingletonClass instance = new SingletonClass();

다음은 private 멤버변수에 접근할수 있는 setter 와 getter
가 필요한데, 외부에서는 어차피 객체를 만들수 없기 때문에
setter는 필요없고 getter만 충분. 

public SingletonClass getInstance() {
return instance;
}

그런데 막상 위의 getter를 쓰려고 보니 메서드에 접근할 수 있는 
객체가 없다. 따라서 마지막으로 객체 없기 메서드를 사용하기 위해 
메서드와 멤버변수에 static 선언이 필요해진다. 

private static SingletonClass instance 
= new SingletonClass();

public static SingletonClass getInstance() {
return instance;
}

이제 Singleton 디자인패턴이 완성. 
SingletonClass의 객체가 필요할 때는 객체를 생성하는 것이 
아니라 getInstance() 메서드를 호출하면 되고 이 메서드의 
리턴은 언제나 하나의 객체일 것이다. 

실습23
ex)

package ch07.modifier;

class SingletonClass{
	private static SingletonClass instance = new SingletonClass();
	private SingletonClass() {}
	
	public static SingletonClass getInstance() {
		return instance;
	}
	
	public void sayHello() {
		System.out.println("Hello");
	}
}

public class SingletonTest {
	public static void main(String[] args) {
		SingletonClass sc1 = SingletonClass.getInstance();
		SingletonClass sc2 = SingletonClass.getInstance();
		System.out.printf("두 객체는 같은가? %b%n", sc1==sc2);
		sc1.sayHello();
	}
}
//
두 객체는 같은가? true
Hello


----------------------------------------------------
4. 다형성 

4.1 다형성 (Polymorphism)

많을 다에 형태 형을 사용. 형이란 타입.
4대특징 중 P에 해당 Polymorphism.

붕어빵 이야기, 황금잉어빵. 상속이야기. 
어떤 때는 붕어빵이라고, 어떤 때는 황금잉어빵이라고, 
이것을 다형성이라고 한다. 

상속관계에 있을 때 조상클래스타입으로(붕어빵)으로 
자식클래스객체(황금잉어빵)를 레퍼런스 할수 있는 성질.

SpiderMan의 상속 관계로 다시 다형성 설명. 

ex)
Venom-->SpiderMan-->Person-->Object
상속 구조 

SpiderMan 타입 객체가 하나 있다. 

SpiderMan onlyOne = new SpiderMan();

onlyOne은 SpiderMan인가? 질문.
이 말은 SpiderMan 타입으로 onlyOne을 참조할수 있는가?
와 같다. 코드는 이렇게도 표현 가능. 

SpiderMan sman = onlyOne

다시 질문.
onlyOne은 Person 타입인가?
상속은 is a 관계이고, SpiderMan은 Person을 상속 
받았으므로 맞는말이다. 코드로 보자. 

Person person = onlyOne 

마지막 질문. 
onlyOne은 Object 타입인가? 모든 객체의 최상위에는 
Object 클래스가 있기 때문에 역시 맞는 말. 

Object obj = onlyOne

조상클래스 타입으로 자식 클래스 타입의 객체를 참조하는 것은 
프로그래밍에서 매우 당연. 

실습24
ex)
package ch07.poly;

import ch07.extend.Person;
import ch07.extend.SpiderMan;

public class PolymorphismTest {

	public static void main(String[] args) {
		SpiderMan sman = new SpiderMan();
		Person person = sman;
		Object obj = sman;

		System.out.printf("sman==person? %b%n", sman == person);
		System.out.printf("sman==obj? %b%n", sman == obj);
	}
}
//
sman==person? true
sman==obj? true

----------------------------------------------------
4.2 다형성 의 활용 

어디에 사용할까? 
자바의 개념 전반에 넓게 깔려 있어서 특정 분야가 아니라 
어디에서나 적용되고 있다. 
다형성이 잘 작용된 애플리케이션은 황금잉어빵을 붕어빵이라고
팔수있을 만큼 유연하게 동작한다. 

배열의 예.
같은 타입의 데이터를 묶어서 관리하는 것이 특징.
Person 타입의 배열을 만들면 Person 타입의 객체들만 
담을 수 있다. 만약, Person 타입 10개와 SpiderMan 
타입 10개를 관리해야 한다면 Person 타입의 배열과 SpiderMan
타입의 배열로 두개의 배열이 필요하다 

ex)
void beforePoly(){
Person [] persons = new Person[10];
persons[0] = new Person();
//Person 전용 
SpiderMan [] spiderMans = new SpiderMan[10];
spiderMans[0] = new SpiderMan();
// SpiderMan 전용 
}

그러나, 이제 다형성을 배웠고, 이를 적용한다면 SpiderMan은 
Person이기 때문에 Person의 배열에 SpiderMan을 담을 수 
있다. 

ex2)
void afterPoly() {
Person [] persons = new Person[10];
person[0] = new Person();
person[1] = new SpiderMan();
// Person 하위 클래스용 
}

더 나아가 Object의 배열을 만들게 되면 어떤 타입의 객체라도 
다 저장할수 있게 된다. 자바의 자료구조가 간단해질 수 있는 것은 
다형성 덕분이다.  이 특징을 이용해서 나중에 학습할 
Collection API 가 등장. 

다형성의 또 다른 예로 매개변수에서의 다형성 활용에 대해서 알아봄. 

System.out.println() 을 이용해 다양한 객체를 출력.
System.out.println( new Person());
System.out.println( new SpiderMan());

메서드가 호출될 때는 이름과 함께 메서드에서 요청하는 적절한 
파라미터를 제공 해야한다. 

설마 이런 메서드가 Java 기본 라이브러리에 있을까?ㅋ
public void println(Person p){...}
public void println(SpiderMan sm){...}
물론 없다. 

실제 동작한 메서드의 API 
ex)
public void println(Object x) {
String s = String.valueOf(x);
synchronized(this) {
print(s);
newLine();
}
}

비밀은 파라미터 타입이 Object인 점. Object는 모두의 
조상이므로 어떤 객체가 들어오더라도 모두 연결할 수 있는 것.
자바 API를 보면 다수의 범용적인 메서드들이 Object를 파라미터
로 받도록 작성되었는데 다형성을 이용해 어떤 객체든 처리하기 위해서.

(1) 다형성과 참조형 객체의 형변환 

메모리 동작 살펴보기

이 코드는 다형성을 적용해 Person 타입으로 SpiderMan 타입의 
객체를 참조한 것. 

ex)
Person person = new SpiderMan();

등호의 오른쪽은 힙 영역에 있는 SpiderMan 타입의 객체이다. 
이 객체는 거미줄도 쏘고(fireWeb) 스파이더 모드(isSpider)
에 대해서 설정 가능. 
하지만 등호의 왼쪽은 아무리 봐도 Person 타입이다. 
이 person이 거미줄을 발사할 수 있을까?
person이 할수 있는 일 Code Assist 기능을 이용해 보기 

person. 보면 , Object와 Person에서 선언했던 내용만 파업이
되고 , SpiderMan에서 선언했던 내용은 보이지 않는다. 

비록 실제 메모리에 있는 객체가 SpiderMan 이여도 참조하는 
타입이 Person이므로 SpiderMan의 고유한 기능을 모르는 것. 
물론, 만약 Object 타입으로 참조하고 있다면 Object의 영역만 
사용 할수 있을 것이다. 

그림 Object obj 위에   // Object 고유영역
Person person 위에  // Person 고유영역
SpiderMan sman 위에 // SpiderMan 고유영역
= new SpiderMan() 

그림을 보면 다형성이 왜 가능한지도 알수있다. 
메모리에 있는 내용이 언제나 참조하는 타입(Object, Person, SpiderMan)
의 내용을 다 가지고 있는 충분조건을 만족하기 때문이다. 

메모리에 있는데도 불구하고 사용할수 없다는 점 아쉽다.
어떻게 하면 전체 내용을 사용할수 있을까?

단순히 참조하는 변수의 타입에 관한 문제이기 때문에 타입을 바꿔주면 된다. 
바로 변수에서 배웠던 형변이다. 
달라진점, 기본형이 아니라 참조형이라는 점. 

기본형에서의 형변환 규칙. 작은집에서 큰 집으로 이동할 때는 값이 
잘릴 염려가 없기 때문에 묵시적형변환이 발생하고,
나머지 경우는 명시적형변환 필요.
묵시적형변환이 연산자(괄호)를 생략가능.
명시적형변환에서는 반드시 사용. 
참조형에서도 동일.
작은 집 = 자손클래스
큰 집 = 조상클래스

형변환이 되면 변환된 타입으로 선언된 기능들을 사용할수 있다. 

실습25
ex)
package ch07.poly;

import ch07.extend.Person;
import ch07.extend.SpiderMan;

public class CastingTest {
	public void primitive() {
		byte b = 10;
		// 묵시적 형변환: 작은 집 --> 큰집
		int i = b;
		// 명시적 형변환: 큰집 --> 작은 집
		byte b2 = (byte) i;
	}

	public void reference() {
		// 묵시적 형변환: 작은 집 --> 큰집
		Person p = new SpiderMan();
		// p.fireWeb(); -- 메모리에 있지만 사용할 수 없다.
		// 명시적 형변환: 큰집 --> 작은 집
		SpiderMan sman = (SpiderMan) p;
		sman.fireWeb();// 이제는 SpiderMan 타입이므로 fireWeb을 사용할 수 있다.
	}
}
묵시적형변환 하고 명시적 형변환 
묵시적형변환 작은 -> 큰 : 업캐스팅
명시적형변환 큰 -> 작 : 다운캐스팅

(2)instnaceof 연산자 p260~

참조형 객체의 형변환 처리시 주의점. 
다음의 예 
먼저, Person 타입의 객체 person을 만든 후 SpiderMan 타입으로 
형변환 처리한 예.

ex) 
Person person = new Person();
SpiderMan sman = (SpiderMan)person;

이 코드는 문법적으로 전혀 문제가 없다. 하지만 실제 프로그램이 동작 
할 때, 문제 발생. 여기서 메모리에 있는 객체는 Person 타입.
SpiderMan이 되기 위한 충분조건( fireWeb 메서드등)을 갖추지 못한 상태.
무늬만 SpiderMan.

따라서 런타임 시의 메모리 구성상 형변환을 할수 없다. 
이렇게 동작시키면 형변환을 처리하다가 java.lan.ClassCastException
을 발생시키고 종료.

결론적으로 부모 타입을 언제나 형변환 연산자를 통해 자식 타입으로는 
변경할수는 없다는 이야기.
먼저, 메모리에 있는 객체가 형변환을 위한 충분조건을 갖추고 있는지 확인. 
이때 사용하는 연산자 : instanceof 이다. 

instanceof 연산자는 실제 메모리에 있는 객체가 특정 클래스 타입인지를 
boolean 타입으로 리턴. 


ex)
Person person = new Person();
if (person instanceof SpiderMan) {
SpiderMan sman = (SpiderMan) person;
}
여기서는 형변환이 발생하지 않는다. 


실습26
ex)
package ch07.poly;

import ch07.extend.Person;
import ch07.extend.SpiderMan;

public class InstanceOfTest {
	public void badCasting() {
		Person person = new Person();
		SpiderMan sman = (SpiderMan) person;
		sman.fireWeb();
	}

	public void goodCasting() {
		Person person = new Person();
		if (person instanceof SpiderMan) {
			SpiderMan sman = (SpiderMan) person;
			sman.fireWeb();
		}else {
			System.out.println("SpiderMan에 적합하지 않은 객체");
		}
	}
	
	public static void main(String[] args) {
		InstanceOfTest iot = new InstanceOfTest();
		// 아래 메서드 호출은 runtime 오류를 발생시킨다.
		// iot.badCasting();
		iot.goodCasting();
	}
}
//
SpiderMan에 적합하지 않은 객체

형변환과 다형성이 적용된 메서드의 파라미터를 함께 적용하는것에
대해 생각. 
equals() 나 println() 메서드의 예에서 메서드의 파라미터에 
상위 타입을 적용하면 그만큼 처리할수 있는 범위가 넓어진다는 것 
확인. 
그럼 언제나 Object를 파라미터로 받는다면 메서드가 
그만큼 유연해질까?

만약 Object, Person, SpiderMan 객체가 하나씩 있는 상태에서 jump 라는 
동작을 시키고 싶을 때 가장 적절한 메서드는 어떤 것일까?
(jump()는 Person에서 처음 정의된 메서드.)

ex)
public void useJump1(Object obj) { }
public void useJump2(Person person) { }
public void useJump3(SpiderMan spiderMan) { }

첫번째 메서드는 어떤 객체가 할당되던지 다처리 가능.
아주 활용도가 높아 보이지만, 전달받은 객체인 Object에는 
jump() 가 없기 때문에, 내부에서는 별도의 형변환 절차가 필요.
물론 형변환 전에 instanceof를 이용해 obj가 Person 타입인지 
확인해야 하는 것도 필수이다. 
활용도는 최고지만 번거로움도 만만치 않다. 

ex2)
public void useJump1(Object obj) {
if ( obj instanceof Person) {
Person casted = (Person)obj;
casted.jump();
}
}
public void useJump1(Object obj) { }
public void useJump2(Person person) { }
public void useJump3(SpiderMan spiderMan) { }

두번째 메서드는 Person 또는 SpiderMan만 처리 가능. 
하지만 호출할 jump() 메서드는 어차피 Person에서 처음 
등장한 메서드니 파라미터로 들어온 객체들은 모두 jump()가
가능할 것이고 형변환도 필요 없다. 
필요한 객체만 할당될 수 있으니 형변환의 절차도 필요 없어진다. 

ex3)
public void useJump2(Person person) {
person.jump();
}
public void useJump1(Object obj) { }  //사용불가
public void useJump2(Person person) { }
public void useJump3(SpiderMan spiderMan) { }

세번째 메서드는 SpiderMan만 처리 가능. 
별도의 형변환 절차는 필요 없겠지만,  Person은 이 메서드를 사용 
할수 없기 때문에 활용도가 떨어진다. 

ex4)
public void useJump3(SpiderMan spiderMan) {
spiderMan.jump();
}
public void useJump1(Object obj) { }  //사용불가
public void useJump2(Person person) { }   //사용불가
public void useJump3(SpiderMan spiderMan) { }

정리, 다형성을 이용해 메서드의 파라미터를 구성할때는 가급적
상윕 타입을 잡는것이 좋다. 하지만, 최상위의 Object까지 
올라가면 별도의 형변환 절차가 필요해서 번거롭다.
Object 를 파라미터로 받는 메서드들은 대부분 자바 API 처럼 
광범위하게 사용되는 경우이다. 
프로젝트 진행할때는 프로젝트 내에서 작성한 객체 중 적절한 
상위 객체를 사용하는 것이 바람직.

(3) 참조 변수의 레벨에 따른 객체의 멤버 연결 

상속 이용시, 조상의 멤버들을 그대로 물려받아서 
필요할때 자손은 그 멤버들을 재정의 할수있다.
이 상황에서 실제 메모리에 있는 객체와 이를 참조하는 변수의 
타입이 다를 때 어떤 현상이 일어나는지 확인해보자. 

SuperClass 클래스와 이를 상속받은 SubClass 클래스가 정의.
두개의 클래스에는 각각 x라는 변수가 선언 되었고,
각 각 내용은 super, sub 이다. 
SuperClass 에서 선언된 method()가 SubClass에서 재정의.

ex)
class SubClass {
String x = "super";
public void method() {
System.out.println("super class method");
}
}

class SubClass extends SubClass {
String x = "sub";
public void method() {
System.out.println("sub class method");
}
}
이 클래스들을 사용하는 예 보기.
먼저, SubClass 객체를 만들고 SubClass로 참조한 후 
멤버 x의 값을 출력해보고 method()도 호출해보자.
어떤 값이 출력되는가?

ex2)
SubClass subClass = new SubClass();
System.out.println(subClass.x);
subClass.method(); 

메모리에 있는 객체는 SubClass 타입이고 참조하는 클래스의 
타입도 SubClass이므로 메모리에 있는 모든 내용을 다 볼수 있다. 
따라서 예상되는 출력 결과는 'sub'와 'sub class method' 이다. 

이제는, 
다형성을 이용해서 SuperClass 타입으로 객체를 참조하고 
동일한 작업을 해보자. 
어떤 값이 출력될까?
SuperClass superClass = subClass;
System.out.println(superClass.x);
superClass.method();

실제 메모리의 객체는 SubClass 타입이지만 참조하는 객체의 타입은 
SuperClass 이므로 superClass 객체가 볼수 있는 부분은 
SuperClass 부분으로 한정된다. 
그럼 출력되는 값은 'super'와 'super class method' 일까?

반은 맞고 반은 틀렸다. 
연결되는 멤버 변수는 선언된 객체의 타입에 따라 달라진다. 
따라서 x의 값은 'super'가 출력되고,
하지만, method()의 경우는 예상과 달리 'sub class method'가 출력된다.

상속관계에서 객체의 멤버 변수가 중복될때,
참조변수의 타입에 따라 연결이 달라진다. 
즉, SuperClass로 참조할때는 SuperClass의 멤버변수로,
SubClass로 참조할때는 SubClass의 멤버변수가 사용된다.

하지만, 상속관계에서 메서드가 오버라이딩 되었을 때는 
무조건 자식 클래스의 메서드가 호출된다. 이것을 가상 
메서드 호출(virtual method call)이라고 한다. 
메서드 재정의는 부모가 물려준 메서드를 자식 입장에 
맞게 최적화시킨다고 할 때, 실제 메모리에 있는 객체가 
가진 가장 최적화된 메서드가 동작한다고 보자.
이런동작은 프로그래밍하면서 아주 유용하고 중요하다. 

이해하기 위해서 객체가 출력되는 과정을 예로 들어보자. 

실27
ex)
package ch07.poly;

class UserInfo {
	String name = "홍길동";

	/*@Override
	public String toString() {
		return "이름: " + this.name;
	}*/
}

class MemberInfo extends UserInfo {
	String grade = "정회원";

	/*@Override
	public String toString() {
		return super.toString() + ", 등급: " + grade;
	}*/
}

public class PrintObject {

	public static void main(String[] args) {
		Object member = new MemberInfo();
		System.out.print("객체 정보: " + member);
	}
}
//
객체 정보: ch07.poly.MemberInfo@368239c8

메모리의 객체는 MemberInfo 타입이고 Object 타입의 member
로 참조하고 있다. 

print() 메서드를 이용해 객체를 출력할수있다. 
출력결과를 보면 조금 아쉽다. 이 주소값으로 할수 있는 일이 없다. 
오히려 객체 멤버들의 name이나 grade 같은 내용이 출력되는 
것이 조금 의미 있지 않을까?

어떻게 객체가 출력되는지 살펴보자. 
먼저, print라는 메서드의 소스 코드를 분석하자. 

System 클래스에 선언된 static 변수인 out의 타이은 
PrintStream이다. 
이 클래스의 print 메서드는 다음과 같다. 

ex)
public void print(Object obj) {
write(String.valueOf(obj));
}

파라미터로 선언된 변수의 타입이 Object이므로 어떤 객체가 
들어오더라도 다 출력 가능. 
내부에서 처음 진행되는 일은 String 클래스가 가진 valueOf라는 
static 메서드에 이 객체를 넘겨준다. 

다시, String 클래스의 valueOf 를 살펴보자. 
valueOf는 파라미터가 obj가 null인지 확인해서 null이면 
문자열 'null'을 출력하고 그렇지 않으면 Object가 가지고 있는 
toString의 결과를 리턴한다. 

ex)
public static String valueOf(Object obj) {
return (obj == null ) ? "null" : obj.toString();
}

마지막으로, 최종적인 출력의 형태는 Object 클래스가 
가진 toString 메서드가 결정한다. 
toString 메서드에서는 클래스 이름과 hashCode를 이용해 
객체의 출력 내용을 결정한다. 

ex)
public String toString() {
return getClass().getName() + "@" + Integer.toHexString(hashCode());
}

이제 MemberInfo 객체가 왜 ch07.poly.MemberInfo@368239c8
로 출력 되는지 확인 되었다. 

모든 클래스는 Object를 상속받고 있으므로 모든 객체는 
Object로 부터 물려받은 toString() 메서드를 가지고 있다. 
따라서 모든 객체는 출력된다.
하지만, 출력내용은 우리가 원하는 방향은 아닌듯.
이상황에 필요한 것?
메서드 오버라이딩이다. UserInfo에서 Object로부터
물려받은 toString 메서드를 오버라이딩해서 이름 정보를 
출력하도록 수정하고 다시 실행. 

ex)
class UserInfo {
String name = "홍길동";

public String toString() {
return "이름: " + this.name;
}
}
현재 메모리에 있는 객체가 toString 메서드를 오버라이딩
했으므로 가장 최적화된 메서드는 UserInfo에서 재정의된
toString이 되고 이를 이용해서 출력 내용이 결정된다. 
이로써 PrintObject를 수정하지 않아도 UserInfo의
수정 내용이 최종 결과에 반영된다. 

MemberInfo도 자신의 입맛에 맞게 toString 메서드를 
오버라이딩하면 다시 MemberInfo에 적합하게 출력결과가
변경될것이다.

ex)
class MemberInfo extends UserInfo {
String grade = "정회원";

@Override
public String toString() {
return super.toString() + ".등급: " + grade;
}
}
정리, Object의 toString() 메서드 덕에 어떤 
객체라도 출력될수 있다. 하지만 그 출력 내용은 객체의 
특성을 충분히 반영하지는 못한다.
출력되는 내용을 변경하려면 자식 클래스에서 toString()
메서드를 오버라이딩해야 한다. 
이 경우 가상 메서드 호출(Virtual Method Call)에
의해 언제나 마지막에 재정의된 메서드가 동작해서 출력 내용이
결정된다. 

(4) 공변(Covariant) 리턴타입
공변: 하나가 변하면 다음 것이 따라서 변하는 것.

원래 메서드 오버라이딩 시 자식 메서드의 리턴타입은 조상 
메서드의 리턴타입과 같아야한다.
하지만, 조상메서드의 리턴타입을 서브클래스 범위 안에서 
다양하게 사용할수 있다는 것이 공변 리턴타입이다.
JDK 1.5 버전에서 추가.

다음 예,
Phone을 상속받는 HandPhone 클래스.
Phone에는 Phone을 리턴하는 aboutMe() 메서드가 있고,
HandPhone이 이 메서드를 오버라이딩하고 있다. 
이 때 배운 대로 조상 메서드가 반환하는 타입을 그대로 사용한다. 

ex)
class Phone {
public String number;
public Phone aboutMe() {
return this;
}
}

class HandPhone extends Phone {
public int weight = 100;
@Override
public HandPhone aboutMe() {
return this;
}
}

이제 이 클래스를 사용해보자. HandPhone 객체를 
만들고 aboutMe 를 호출하면 Phone 타입을 
반환받게 된다. 따라서 HandPhone의 특성을 사용하려면 
다시 HandPhone으로 형변환을 해야 하는 번거로움 발생.

HandPhone hp = new HandPhone();
Phone aboutMe = hp.aboutMe();
if ( aboutMe instanceof HandPhone) {
System.out.println(((HandPhone) aboutMe).weight);
}

HandPhone에서 aboutMe()를 재정의할 때 공변 반환
타입을 사용한다면 다음과 같이 반환 타입을 Phone 의 
하위 타입인 HandPhone으로 바꿔볼 수 있다.

ex)
class HandPhone extends Phone {
public int weight = 100;
@Override
public HandPhone aboutMe() {
return this;
}
}
다시 aboutMe()의 반환 값을 사용한다면 별도의 
형변환 없이 쉽게 사용할수 있다.
HandPhone aboutMe2 = hp.aboutMe();
System.out.println(aboutMe2.weight);

공변 반환 타입을 이용하면 형변환의 번거로움을 많이 
줄일수 있다. 



===================================
[자바 해바라기 정리] 8 나머지 주요 구성요소
실습35
1. 추상 클래스 (Abstract Class)

자바를 구성하는 가장 기본적인 요소는 클래스이다.
기본 클래스 이외에 자바 애플리케이션을 구성하는 요소들에 대해 보자.
이들은 클래스가 아닐 뿐 전체적으로 많이 사용되므로, 각 요소의
정확한 사용법을 알고 유연한 자바 애플리케이션을 작성하자.

----------------------------------------------------
1.1 추상 클래스의 정의 

회사 차량 관리 프로젝트. 처음 관리할 자동차는 디젤연료를 사용하는 SUV 차량.
이 차의 관리 포인트는 현재의 위치를 보고하는 기능(reportPosition)과 
연료를 주입하는 기능(addFuel)이다. 
간단한 클래스 작성 

실습1
ex)
package ch08.abs.bad;

public class DieselSUV {
	private int curX, curY;
	
	public void reportPosition() {
		System.out.printf("현재 위치: (%d, %d)%n", curX, curY);
	}
	
	public void addFuel() {
		System.out.printf("주유소에서 급유");
	}
}

사업 번창, 전기차(ElectricCar) 추가.
전기차 관리 포인트는 DieselSUV와 동일. 
차이점은 addFuel() 메서드를 구현할때 '주유소에서 급유'라는 내용 
대신 급속 충전이라고 구현부만 변경.
기존 클래스 복사,붙여넣기 한 뒤에 변경된 부분만 바꿔주면 쉽다. 

실습2
ex2)
package ch08.abs.bad;

public class ElectricCar {
	private int curX, curY;
	
	public void reportPosition() {
		System.out.printf("현재 위치: (%d, %d)%n", curX, curY);
	}
	
	public void addFuel() {
		System.out.printf("급속 충전");
	}
}

만약, 사업이 계속 잘되면 이런식으로 관리해야 할 클래스들은 계속해서 늘어난다. 
만약, 위치를 보고하는 기능이 바뀐다면 모든 클래스에서 수정해야 함. 
상속 구조를 사용한다면 어떨까?
공통 모듈들은 뽑아서 조상클래스로 넘겨주고 자식들은 변경된 부분만 재정의 
또는 추가하면 간단히 해결된다. 

실습3
ex3)
package ch08.abs.middle;

class Vehicle {
	private int curX, curY;

	public void reportPosition() {
		System.out.printf("현재 위치: (%d, %d)%n", curX, curY);
	}

	public void addFuel() {
		System.out.println("모든 운송 수단은 연료가 필요");
	}
}

class DieselSUV extends Vehicle {
	@Override
	public void addFuel() {
		System.out.println("주유소에서 급유");
	}
}

class ElectricCar extends Vehicle {
	@Override
	public void addFuel() {
		System.out.println("급속 충전");
	}
}

class HorseCart extends Vehicle{}

public class VehicleTest {

	public static void main(String[] args) {
		Vehicle[] vehicles = { new DieselSUV(), new ElectricCar() };
		for (Vehicle v : vehicles) {
			v.addFuel();
			v.reportPosition();
		}
	}
}
//
주유소에서 급유
현재 위치: (0, 0)
급속 충전
현재 위치: (0, 0)

전체적으로 상속을 통한 소스 코드의 재사용, 다형성을 이용한 관리를 이용한 잘 
작성된 애플리케이션이다. 
그런데, 이 38행짜리 애플리케이션에서 전혀 동작하지 않는 코드가 한줄 있다. 
어디?
답, 11행 즉 Vehicle 클래스의 멤버인 addFuel() 메서드의 구현부이다. 
addFuel() 메서드는 하위 클래스들에 의해 재정의되어 있다. 
따라서 실제로 호출되는 메서드는 17행과 24행처럼 각 클래스별로 재정의한 메서드다.

이상황에서 10행의 addFuel() 메서드를 힘들게 구현한 개발자는 고민이다.
힘들게 구현한 메서드가 정작 사용되지는 않는다고 실망한 개발자가 10~12행을 삭제
한다면 어떻게 될까?

addFuel()가 조상클래스라는 공통 코드에서 사라지게 되므로 34행처럼 
Vehicle을 통해 addFuel()를 호출할수 없다. 
Vehicle을 DieselSUV나 ElectricCar로 형변환 후 비로소 
addFuel()를 사용할수 있게 된다. 오히려 처리할 일들이 늘어남. 

좀더 보면, Vehicle 입장에서는 연료주입(addFuel)이 필요하지만, 
아직 차의 종류가 확정되지 않았기 때문에 어떤 연료를 주입할지는 모르는 상황.
그래서 메서드의 선언부까지는 작성이 가능하지만 구현부는 작성할수 없는 것.

이렇게 자손클래스들에서 어차피 재정의해서 사용되기 때문에 조상 입장에서는 
구현 할 필요가 없거나 조상 레벨에서 아직 작성할 수 없는 메서드에 대해 
선언부만 작성하고 구현부를 세미콜론(;)으로 대체하고 구현부가 없다는 의미로
abstract 키워드를 선어부에 추가한다. 
또한, 클래스가 abstract 메서드를 포함하고 있는 경우 반드시 클래스 
선언부에도 abstract 키워드를 추가해야 한다. 이런 형태의 프로그래밍
기법을 abstract method design pattern 이라 한다. 

실습4
ex)
package ch08.abs.good;

abstract class Vehicle {
	private int curX, curY;

	public void reportPosition() {
		System.out.printf("현재 위치: (%d, %d)%n", curX, curY);
	}

	public abstract void addFuel();
}

class DieselSUV extends Vehicle {
	@Override
	public void addFuel() {
		System.out.println("주유소에서 급유");
	}
}

class ElectricCar extends Vehicle {
	@Override
	public void addFuel() {
		System.out.println("급속 충전");
	}
}
//he type HorseCart must implement the inherited abstract method Vehicle.addFuel()
/*class HorseCart extends Vehicle{
	@Override
	public void addFuel() {
		System.out.println("건초 공급");
	}
}*/

public class VehicleTest {


	public static void main(String[] args) {
		Vehicle[] vehicles = { new DieselSUV(), new ElectricCar() };
		for (Vehicle v : vehicles) {
			v.addFuel();
			v.reportPosition();
		}
		// Vehicle v = new Vehicle(); // abstract 클래스는 객체를 생성할 수 없다.
		Vehicle v = new DieselSUV();  // 자식을 참조하는 것은 문제 없음

	}
}
//
주유소에서 급유
현재 위치: (0, 0)
급속 충전
현재 위치: (0, 0)



----------------------------------------------------
1.2 추상 클래스의 특징과 용도 

메서드의 구현부가 없는 메서드가 호출되면 어떻게 될까?
당연히 동작할 내용이 없기 때문에 프로그램 코드를 실행해야 하는 JVM으로서는 
당혹스러움. 따라서 abstract 클래스는 객체를 생성 못함. 
하지만, 상속 전용의 클래스가 되어 자식을 참조할수 있다. 

// Vehicle v = new Vehicle(); // abstract 클래스는 객체를 생성못함. 
Vehicle v = new DieselSUV(); // 자식을 참조하는 것은 문제 없음. 

만약, 자손클래스에서 abstract 메서드를 재정의 하지 않는다면 어떻게 되나?
자식클래스 입장에서 abstract 메서드를 물려받아서 가지고 있는 형태가 되기 
때문에 자식클래스 역시 abstract로 선언되어야 하고,
자식클래스도 객체를 생성 못한다. 

바로 여기에 추상클래스를 사용하는 이유가 등장. 
바로 구현의 강제를 통해서 프로그램의 안정성을 향상할수 있다. 

차량관리 프로젝트가 규모가 더 커져서 말이 끄는 HorseCart를 추가로 
관리한다. 이때 회사에 초급 프로그래머가 입사했고 , 그 직원에게 
HorseCart에 대한 관리 모듈을 작성하도록 지시하면서,
기존의 Vehicle이 있으니 이를 상속받아서 하면 편리할 것이라고 이야기함. 

abstract를 사용하지 않은 상태인 ch08.abs.middle.VehicleTest.java
에 있는 Vehicle을 상속 받는고 가정. 긴장한 초급 개발자가 Vehicle을 
상속받아보니 일단 프로그램이 잘 동작하는 것 같아서 addFuel()을 재정의를 
깜박함. 

class HorseCart extends Vehicle{}

결과, HorseCart 타입 객체의 addFuel() 메서드를 호출하면 
"모든 운송 수단은 연로가 필요"라늠 모호한 말만 되풀이 되며 실제 연료 
주입은 안된다. 

다시, abstract 가 적용된 상태인 
ch08.abs.good.VehicleTest.java 에 있는 Vehicle을
상속받아서 처리하는 경우를 가정. 
HorseCart가 Vehicle을 상속받으면 addFuel() 메서드를 
재정의하지 않고 서는 컴파일을 할수가 없다. 
결국, 아무리 초급개발자라고 하더라도 addFuel() 메서드를 재정의
할수 밖에 없을것.
물론, abstract class로 선언하는 방법이 있겠지만, 
이는 객체를 생성할수 없으니 원래의 의도를 벗어나게 된다. 

실습5
ex)
class HorseCart extends Vehicle {
@Override
public void addFuel() {
System.out.println("건초 공급");
}
}
// addFuel() 메서드를 오버라이딩하지 않았을 때 오류 메시지
//The type HorseCart must implement the inherited abstract
method 
//Vehicle.addFuel()

UML에서 기울여서 작성된 부분은 abstract를 의미한다. 
p276 그림에서 
오른쪽 Vehicle 클래스 와 addFuel();void 가 기울져 있다. 

abstract 클래스를 사용하는 두번째 이유는 인터페이스에 선언된 메서드중 일부 
구현 할수있는 메서드를 구현해서 개발의 편의를 제공하기 위함에 있다. 
이 부분은 인터페이스를 학습하고 다시 살펴보자. 



----------------------------------------------------
2. 인터페이스 (interface)

2.1 인터페이스의 정의

사전적으로 두 시스템 간에 만나는 접점이라는 의미.
자주 사용하느 인터페이스에는 GUI(Graphic User Interface)
가 있따. 

ex)
실습도구로 사용하는 이클립스에는 [저장] 버튼이 있다. 
이 버튼은 이클립스를 사용하는 사용자와 이클립스 사이의 인터페이스이다. 

이 버튼을 바라보는 사용자의 관점은 아마도 " 이 버튼을 클릭하면 저장이 되겠지?"
정도 일것이다. 어떤 과정을 거쳐서 저장이 이뤄지는지는 사실 별로 안궁금.
이 과정을 프로그래밍의 관점에서 생각.

어떤 일이 일어나는 것은 기능 즉 메서드에 대한 이야기.

"버튼을 클릭한다"는 것은 메서드를 호출한다는 것.
"저장된다"라는 것은 메서드의 동작 결과 즉 리턴값에 해당. 
"어떻게 저장되는지 잘 모르는 것"은 구현부가 없는 즉
abstract 상태라는 뜻. 
따라서 사용자의 현 상황을 코드로 구현하면 
"abstract void save();" 정도가 된다. 

[저장] 버튼을 가지고 있는 이클립스의 입장에서는 어떨까?
어떻게 이 버튼이 클릭되는지는 관심 밖의 사항이다. 
이클립스 내부에서는 버튼이 클릭되었을 때의 동작인 메서드의 
구현부가 작성되어 있다. 

ex)
public void save() {
// 1. 변경 정보 확인 
// 2. OutputStream을 통해 내용 저장 
// 3. 화면상에 변경 완료 표시 
}

즉 이클립스는 abstract 메서드에 대한 구현체 클래스를 가지고 있다. 
만약, 이클립스의 저장 로직이 변경되었다고 생각해보자. 
사용자 입장에서 변경될 부분은 무엇일까?
정답, 없다.!
사용자는 공개된 인터페이스를 통해 간접적으로 저장 기능을 이용하고 있었으므로
내부적인 변경과 무관하게 원래처럼 사용이 가능하다. 따라서 도구가 
업데이트되더라도 대부분은 사용법은 유지 된다. 

----------------------------------------------------
2.2 인터페이스의 작성 

인터페이스는 클래스가 아니다. 
선언부에 class 대신 interface라고 작성한다. 
인터페이스 자체로는 객체가 될 수 없기 때문에 생성자나 초기화 블록도 존재하지 않고 
멤버 변수와 메서드로만 구성된다. 
인터페이스의 멤버 변수와 메서드를 작성할 때는 지켜야 할 규칙 있다. 

인터페이스의 모든 멤버변수는 반드시 public static final 이어야 한다. 
모든 변수에 이속성들이 적용되어야 하므로 이 3개의 제어자는 생략 가능. 
멤버변수의 접근 제어자를 protected 등으로 제한 못함. 
또한, 생성자가 없기 때문에 blank final 형태로 구성 못함. 

인터페이스에 선언된 모든 메서드는 public abstract 이어야 한다. 
멤버변수와 마찬가지로 이두개의 제어자는 생략가능.

이클립스 대화상자에서 인터페이스를 작성할 때는 이클립스의 메뉴 
File -> New -> Interface를 선택. 

이 대화상자에서 보면, Modifiers 항목을 보면,
인터페이스에 사용할수 있는 접근 제어자는 클래스와 같이 public 또는 
default(package)이고 다른 제어자는 사용 못함.
Extended interfaces 항목을 보니 인터페이스는 다른 인터페이스를 
상속 받을수 있는데 개수의 제한은 없다. 

실습6
ex)
package ch08.inter;

public interface MyInterface {
	public static final int MEMBER1 = 10;
	int MEMBER2 = 10;

	public abstract void method1(int param);

	void method2(int param);
}


----------------------------------------------------
2.3 인터페이스 간의 관계 

인터페이스 간에도 클래스 사이의 관계에서 처럼 'is a'와 
'has a'관계가 존재한다. 
상속 받을 때 클래스처럼 extends 키워드를 사용.
상속에서의 차이점은 클래스 상속과 다르게 다중 상속이 지원.

클래스가 단일 상속만을 지원하는 이유는 여러 클래스에서 
상속받았을 때 메서드의 구현이 중복되는 경우 복잡도가 올라가서.
하지만, 인터페이스는 메서드 선언이 중복되더라도 구현부가 
없기 때문에 복잡도가 올라가지 않는다. 
따라서 인터페이스는 여러 개의 다른 인터페이스를 상속 가능.

실습7
ex)
package ch08.inter;

interface Fightable{
	int fire();
}

interface Transformable{
	void changeShape(boolean isHeroMode);
}

public interface Heroable extends Fightable, Transformable{
	void upgrade();
}


----------------------------------------------------
2.4 인터페이스의 구현과 객체 참조 

인터페이스는 최고 수준의 추상화 단계로 모든 메서드가 abstract 형태로 
구성되어 있으며, 이 메서드들은 클래스를 통해서 구현되어야 한다.

클래스에서 인터페이스를 구현하기 위해서는 implements 키워드를 사용함. 
인터페이스를 구현(implements)하는 클래스는 인터페이스에 선언된 
메서드를 물려받는 형태가 된다. 
abstract 클래스에서 살펴봤듯이 물려받은 abstract 메서드를 재정의하지 
않으면 컴파일 오류가 발생한다. 
또는 클래스 자체를 abstract로 표시해서 객체에 대한 생성을 포기하고 
상속 전용의 클래스로 활용할 수도 있다. 

실습8
ex)
package ch08.inter;

public class IronMan implements Heroable {
	int weaponDamage = 100;

	@Override
	public int fire() {
		System.out.printf("빔 발사: %d만큼의 데미지를 가함%n");
		return this.weaponDamage;
	}

	@Override
	public void changeShape(boolean isHeroMode) {
		if (isHeroMode) {
			System.out.println("장갑 장착");
		} else {
			System.out.println("장갑 제거");
		}
		String status = isHeroMode?"장착":"제거";
		System.out.printf("장갑 %s%n", status);
	}

	@Override
	public void upgrade() {
		int before = weaponDamage;
		weaponDamage+=weaponDamage*0.1;
System.out.printf("무기 성능 개선: %d --> %d%n",before, weaponDamage);
	}

}

참고, 
인터페이스의 메서드 
이클립스에서 인터페이스를 implements하고 메서드를 재정의하지 않으면 
오류가 표시되는데 이때 오류가 발생한 클래스 위에 커서를 살짝 올리고 
있으면 오류를 수정할수 있는 2가지 옵션을 제공. 
처음 옵션은 구현되지 않은 메서드들에 대한 stub을 추가해주고,
두번째 옵션은 클래스 자체를 abstract로 처리 해준다. 

다형성은 조상클래스의 타입으로 자식 타입의 객체를 참조할수 있는 성질. 
클래스 뿐 아니라 인터페이스 역시 조상의 타입으로 사용될 수 있다. 
따라서 위 예에서 IronMan 타입의 객체는 Object 뿐 아니라
Heroable, Fightable, Transformable로 참조된다. 

실습9
ex)
package ch08.inter;

public class IronManTest {

	public static void main(String[] args) {
		IronMan iman = new IronMan();
		Object obj = iman;
		Heroable hero= iman;
		Fightable fight = iman;
		Transformable trans = iman;
	}
}


----------------------------------------------------
2.5 인터페이스의 필요성 

인터페이스를 사용해야 하는 이유.

1) 구현의 강제로 표준화 
2) 인터페이스를 통한 간접적인 클래스 사용으로 손쉬운 모듈 교체 지원 
3) 서로 상속의 관계가 없는 클래스들에게 인터페이스를 통한 관계 부여로 
다형성 확장 
4) 모듈 간 독립적 프로그래밍으로 개발 시간 단축 

(1) 구현의 강제 
abstract 클래스에서 봤듯이 abstract 메서드는 자손 클래스들이 
반드시 재정의해서 구현해야 하는 메서드들이다. 인터페이스에 선언된 
모든 메서드들은 abstract이기 때문에 인터페이스를 구현하는 하위 클래스들은 
모두 이 메서드를 구현해야 한다. 
따라서, 실수로 필요한 기능을 빼먹는 경우가 발생하지 않는다. 

(2) 손쉬운 모듈 교체 지원 
인터페이스를 통한 간접적인 클래스 사용으로 손쉬운 모듈 교체가 가능하다.
인터페이스는 구현을 가지고 있지 않고 필요한 기능에 대해 선언만을 갖는다. 
그리고 그 인터페이스에 대한 구현체 클래스가 실제적으로 동작하게 된다. 

인터페이스를 통해서도 다형성이 적용될수 있기 때문에 프로그래밍 과정에서 
객체를 클래스로 참조하지 않고 인터페이스를 사용하게 된다면 
뒤에서 동작하는 구현 클래스가 바뀌더라도 인터페이스를 사용하는 
코드는 변경되지 않아도 된다. 
어차피 기능은 인터페이스에 선언되기 때문이다. 

예)
프린터를 사용한다 가정. 
실제로 여러 프린터 제품이 존재하지만 대부분 기능은 유사하다. 
이런 유사한 기능들은 묶어서 Printer 인터페이스를 만들고 
이 인터페이스를 구현한 LaserPrinter, DotPrinter 와 같은 제품이 존재.
만약, 평소 LaserPrinter에 대한 사용법만 알고 있다가 
DotPrinter로 변경해야 한다면 새롭게 DotPrinter에 대한 
사용법을 학습해야 한다. 

실습10
ex) 
class LaserPrinter {
public void print(String filName){
System.out.printf("LaserPrinter로 출력중:%s%n", filName);
}
}
class DotPrinter {
public void printf("DotPrinter로 출력 중 : %s%n", filName);
}
}
LaserPrinter IPrinter = new LaserPrinter();

DotPrinter dPrinter = new DotPrinter();

하지만 Printer 인터페이스를 통해 LaserPrinter를 사용하고 있었다면 
코드상에서 LaserPrinter에 대한 내용이 등장하지 않기 때문에 DotPrinter 로
변경하는데 부담이 줄어든다.

실습11
ex)
package ch08.inter.printer;

interface Printer{
	void print(String fileName);
}

class LaserPrinter implements Printer{
	@Override
	public void print(String fileName) {
		System.out.printf("Laser Printer로 출력 중: %s%n", fileName);
	}
}

class DotPrinter implements Printer{
	@Override
	public void print(String fileName) {
		System.out.printf("Dot Printer로 출력 중: %s%n", fileName);
	}
}

class PrintClient{
	private Printer printer;

	public void setPrinter(Printer printer) {
		this.printer = printer;
	}
	
	public void printThis(String fileName) {
		printer.print(fileName);
	}
}


public class PrintClientTest {

	public static void main(String[] args) {
		PrintClient pc = new PrintClient();
		pc.setPrinter(new DotPrinter());
		pc.printThis("Hello.java");
		pc.setPrinter(new LaserPrinter());
		pc.printThis("Hi.java");
	}
}
//
Dot Printer로 출력 중: Hello.java
Laser Printer로 출력 중: Hi.java

이런 특성은 자바에서 아주 많이 사용된다.
자바에서 데이터베이스를 사용하기 위해서는 JDBC(Java Database Connectivity)
라는 기술을 사용하는데 여기에도 인터페이스가 등장.  
JDBC에서 인터페이스의 역할에 대해 살펴보자. 

자바와 데이터베이스, 두개의 진영이 있다고 보자. 
자바의 개발자 입장에서는 데이터베이스를 잘 알지 못한다. 
따라서, 자바에서 데이터베이스를 사용하기 위해 어떤 내용이 
필요한지 필요한 기능의 목록 정도만 작성할 수 있다. 
이것이 자바가 제공하는 JDBC 인터페이스다. 

데이터베이스 엔지니어들은 데이터베이스에 대해 잘 알기 때문에 자바가 제공한 
JDBC 인터페이스를 구현해서 드라이버(driver)라는 것을 제공 해준다. 
Oracle이나 MySQL등 회사별로 자기 회사의 제품에 적합한 드라이버가 있다. 

이제 자바 개발자는 JDBC 인터페이스를 통해 데이터베이스 회사에서 제공하는
드라이버를 사용한다. 

프로젝트 초기에 MySQL을 이용해 프로젝트를 진행하고 있다고 가정.
하지만 코드에서는 인터페이스를 사용할 뿐이므로 MySQL 드라이버에 대한 
내용이 등장할 필요가 없다. 
따라서, 나중에 데이터베이스를 Oracle로 변경한다고 할 때 우리 코드의 변경사항은 
거의 없을 것이다. 

(3) 다형성 확장 

세번째로 서로 상속 관계가 없는 클래스들에게 인터페이스를 통한 관계를 맺어서 
다형성을 확장할수 있다. 자바에서 클래스들에게 상속이란 단 한번만 사용할 수 있는 
매우 소중한 자원이다. 자바는 단일 상속만 지원. 

다음은 HandPhone 계열과 DigitalCamera 계열의 상속 관계도이다. 
두 클래스 모두 클래스의 상속을 통해서만 관계가 맺어졌고 각각 charge()
메서드를 통해 충전가능. 

여러 대의 HandPhone과 DigitalCamera를 관리하기 위해 배열을
쓴다고 가정. 
각각 최초 Object를 상속받은 것을 제외하고는 중간에 연결 고리가 없기 
때문에 현재는 Object의 배열을 사용할 수밖에 없다. 
묶는 것은 지장이 없지만, Object에는 일반적으로 필요한 기능
(여기서는 charge)이 없다. 
따라서, 배열에서 빼낸후 별도로 HandPhone 또는 DigitalCamera로 형변환 후 
사용해야 한다. 

실습12
ex)
Object [] objs = {new HandPhone(), new DigitalCamera()};
for(Object obj: objs){
if(obj instanceof HandPhone) {
HandPhone phone = (HandPhone)obj;
phone.charge();
} else if (obj instanceof DigitalCamera) {
DigitalCamera camera = (DigitalCamera)obj;
camera.charge();
}
}

하지만 인터페이스는 필요하다면 몇번이고 사용할수 있다. 
위 구조는 다음과 같이 변경 해볼수 있다. 

HandPhone과 DigitalCamera는 모두 Chargeable 인터페이스
를 구현한다. 따라서 Object를 통한 관계가 아닌 Chargeable 
인터페이스를 통해 둘을 묶을수 있게 되었다. 

ex)
Chargeable [] objs = {new HandPhone(), new DigitalCamera()};
for (Chargeable obj:objs) {
obj.charge();
}

이 짧은 코드는 앞의 긴 코드를 대체한다. 
인터페이스 타입으로 배열을 만들어서 객체를 관리함으로써 굳이 charge를 
호출하기 위해 형변환을 할 필요도 없어졌다. 

실습13
ex)
package ch08.inter.relation;

class Phone{}
class HandPhone extends Phone  implements Chargeable{
	public void charge() {
		System.out.println("HandPhone 충전 중...");
	}
}

class Camera{}
class DigitalCamera extends Camera implements Chargeable{
	public void charge() {
		System.out.println("BlackBox 충전 중...");
	}
}

interface Chargeable{
	void charge();
}

public class RelationTest {
	void badCase() {
		Object [] objs = {new HandPhone(), new DigitalCamera()};
		for(Object obj: objs) {
			if(obj instanceof HandPhone) {
				HandPhone phone = (HandPhone)obj;
				phone.charge();
			}else if(obj instanceof DigitalCamera) {
				DigitalCamera camera = (DigitalCamera)obj;
				camera.charge();
			}
		}
	}
	
	void goodCase() {
		Chargeable [] objs = {new HandPhone(), new DigitalCamera()};
		for(Chargeable obj: objs) {
			obj.charge();
		}
	}
	public static void main(String[] args) {
		RelationTest lct = new RelationTest();
		lct.badCase();
		lct.goodCase();
		
	}
}
//
HandPhone 충전 중...
BlackBox 충전 중...
HandPhone 충전 중...
BlackBox 충전 중...

(4) 모듈 간 독립적 프로그래밍

모듈 간 독립적 프로그래밍으로 개발 기간이 단축된다.
회사에서 계산기를 만드는 새로운 프로젝트를 시작했다고 가정. 
사용자가 두개의 숫자를 입력하면 내부 로직을 통해 두수의 합이 
계산되고 결과가 다시 화면에 출력돼야 한다. 

이 프로젝트는 두개의 팀이 진행하기로 했다. 
한 팀은 클라이언트를 위한 UI를 개발하는 팀(이하 A팀)이다. 
또 다른 한팀은 계산기의 내부 로직을 작성하는 팀 (B팀).

어느 팀의 작업이 먼저 진행돼야 할까? A팀은 당장 입력을 받을 수는 있겠지만
더하기 로직은 구성할 수가 없었다. 그래서 B팀의 결과를 기다려야만 
다시 화면에 출력 부분을 작성할 수 있다. 
B팀 역시 화면에서 두개의 숫자가 넘어와야 다음 로직을 구현할수 있다. 
하지만 서로가 상대팀의 작업이 끝나기만을 기다릴수는 없는 노릇이다. 
두팀이 동시에 작업을 진행해야 비용이 절감될 텐데 방법이 없을까?

역시 이 때 사용하는 것이 인터페이스이다. A팀의 입장에서는 B팀의 정확한 
로직이 처음부터 필요하지는 않다. 단지 '숫자 두개를 넘겨주면 결과로 숫자 
하나를 넘겨받는다'는 정도만 필요하다. 
즉 파라미터와 리턴값만 필요할 뿐이다. 
따라서 두팀이 인터페이스에 메서드를 정한후 각자 구현하면된다. 
다음 코드는 두팀이 협의해서 작성한 인터페이스이다. 

ex)
package ch08.inter.cowork.common;

public interface Calculator {
	int add(int a, int b);
}

이제 각 팀은 작업을 개별적으로 동시에 진행하면 된다. 
A팀은 로직을 제대로 구현할 필요는 없으므로 리턴되는 결과값에는 
신경 쓰지 않았도 된다. 형식만 맞추는 것으로 충분하다. 
이렇게 구현한 클래스는 통상 stub이라고 부른다. 
stub은 아직 개발되지 않은 코드를 임시로 대치하는 역할을 한다. 
A팀은 이 stub 객체를 멤버 변수로 가지고 프로그램을 작성. 
물론, 인터페이스를 통해 이 객체를 사용한다. 

실습14
ex2)
package ch08.inter.cowork.ateam;

import java.util.Scanner;

import ch08.inter.cowork.bteam.CalculatorImpl;
import ch08.inter.cowork.common.Calculator;

class CalculatorStub implements Calculator {

	@Override
	public int add(int a, int b) {
		System.out.printf("파라미터 확인: %d, %d%n", a, b);
		return 0;
	}
}

class CalculatorClient{
	Calculator calcLogic = new CalculatorStub();
	//Calculator calcLogic = new CalculatorImpl();
	
	public void add() {
		System.out.println("첫 번째 정수를 입력하시오.");
		Scanner scanner = new Scanner(System.in);
		int a = scanner.nextInt();
		System.out.println("두 번째 정수를 입력하시오.");
		int b = scanner.nextInt();
		System.out.printf("결과: %d+%d=%d%n", a, b, calcLogic.add(a, b));
	}
}

public class CalculatorTest {

	public static void main(String[] args) {
		CalculatorClient client = new CalculatorClient();
		client.add();

	}
}
//
첫 번째 정수를 입력하시오.
1
두 번째 정수를 입력하시오.
2
파라미터 확인: 1, 2
결과: 1+2=0

B 팀은 인터페이스를 제대로 구현한 클래스를 만들 것이다. 
이런 클래스를 통상 impl이라고 부른다. 
B팀이 로직을 테스트할 때는 Scaner 등은 필요치 않다. 
B팀의 작업 결과물. 

실습15
ex)
package ch08.inter.cowork.bteam;

import ch08.inter.cowork.common.Calculator;

public class CalculatorImpl implements Calculator{

	@Override
	public int add(int a, int b) {
		System.out.printf("파라미터 확인: %d, %d%n", a, b);
		return a + b;
	}
	
}

실습16
ex2)
package ch08.inter.cowork.bteam;

import ch08.inter.cowork.common.Calculator;

public class CalculatorLogicTest {
	public static void main(String[] args) {
		Calculator calcLogic = new CalculatorImpl();
		int result = calcLogic.add(100, 200);
		System.out.printf("결과 확인: %d%n",result);
	}
}
//
파라미터 확인: 100, 200
결과 확인: 300

이로써 두팀은 병렬로 작업을 진행할수 있었고 각 팀의 작업 내용을 살펴보면 
전혀 다른 팀의 결과에 영향을 받지 않음을 알수 있다. 
이제 두팀의 작업 결과물을 합하기만 하면 프로젝트는 완성.
변경될 부분은 A팀의 작업 내용에서 기존에 
CalculatorTest.java 파일에 있는 
CalculatorClient에서 CalculatorStub을 사용하던 부분은 
CalculatorImpl로 변경하기만 하면된다. 
//before 
Calculator calLogic = new CalculatorStub();
//after 
Calculator calLogic = new CalculatorImpl();
그리고 다시 CalculatorTest.java 파일을 실행 
//
첫 번째 정수를 입력하시오.
1
두 번째 정수를 입력하시오.
2
파라미터 확인: 1, 2
결과: 1+2=3


----------------------------------------------------
2.6 인터페이스에 추가할 수 있는 다양한 메서드 

인터페이스의 작성에서 인터페이스에 선언되는 메서드는 모두 abstract
라 설명했다.
JDK 1.8 버전 부터 많은 것이 추가. default 메서드와, static 메서드 
default 메서드는 인터페이스에 포함된 구현부가 있는 일반 메서드.
만드는 방법 메서드 선언부에 default 키워드를 추가하고 일반적인 메서드 
만들 듯이 만든다. 단, 접근제어자는 public만 사용하고, 생략가능.

실습17
ex)
package ch08.inter.method;

interface DefaultMethodInterface {
	void abstractMethod();

	default void defaultMethod() {
		System.out.println("이것은 기본 메서드입니다.");
	}
}

public class DefaultMethodTest implements DefaultMethodInterface {

	@Override
	public void abstractMethod() {
		System.out.println("자식에서 반드시 재정의 필요");
	}

	public static void main(String[] args) {
		DefaultMethodTest dmt = new DefaultMethodTest();
		dmt.abstractMethod();
		dmt.defaultMethod();
	}
}
//
자식에서 반드시 재정의 필요
이것은 기본 메서드입니다.
default 메서드. 이미 구현이 완료되어서 구현 클래스에서 재정의할 
필요없다. 주의점은 언제나 public.

왜 이런 메서드가 추가 되었을까?

예)
사용하는 시스템이 좀 오래되었다 가정. 그동안 많은 요구사항이 발생했고
새롭게 반영하고 싶은 기능들이 생겼다. 이때 만약 기존에 있던 인터페이스에
새로운기능, 즉 메서드를 추가하려면 인터페이스에 대한 수정은 물론이고 
이 인터페이스를 구현하고 있는 모든 클래스에서도 해당 메서드에 대한 재정의가
필요하다. 
이런 경우 default 메서드를 사용하면 이미 완전한 메서드이기 때문에
해당 기능이 필요 없는 클래스에서는 별도의 재정의(override) 가 필요 없어진다. 

그런데, default 메서드가 들어오면서 문제가 생긴다. 원래 인터페이스를 여러 개 
구현할수 있는 이유는 인터페이스는 메서드의 구현부가 없기 때문에 동작이 충돌 
하지 않기 때문. default 메서드가 추가되면서 조상클래스
또는 여러개의 조상 인터페이스에 구현된 메서드가 충돌ㄹ하는 일이 발생 가능성이 생겨서
이런 경우는 다음의 규칙을 적용해 충돌을 피한다. 

1) 조상클래스의 메서드가 가장 높은 우선순위를 갖는다.
조상클래스의 메서드와 인터페이스의 default 메서드가 
충돌하면 default 메서드는 무시된다. 

2) 하나의 인터페이스에서 default 메서드를 제공되고 
다른 인터페이스에 충돌하는 메서드가 있는 경우(default가 아니더라도)
자식클래스는 반드시 조상의 메서드를 재정의해야 한다. 

인터페이스에 static 메서드도 추가할 수 있는데 이 메서드의 용법은 
일반 클래스에 static 메서드를 추가할 경우와 동일하다. 
즉 특별한 객체를 생성할 필요가 없기 때문에 

이 메서드를 호출하기 위해 구현체 클래스가 있을 필요도 없이 
바로 인터페이스 이름으로 호출.

실습18
ex)
package ch08.inter.method;

interface StaticMethodInterface{
	static void staticMethod() {
		System.out.println("Static 메서드");
	}
}

public class StaticMethodTest {

	public static void main(String[] args) {
		StaticMethodInterface.staticMethod();
	}
}
//
Static 메서드
인터페이스의 static 메서드를 호출하기 위해 단순히 인터페이스
이름으로 접근하고 별도의 구현체 클래스가 존재하지 않는다.

----------------------------------------------------
3. 열거형 데이터 타입

3.1 enum 의 정의와 작성법 
enum은 열거형 데이터타입. 단어 그대로 무언가를 나열한다는 뜻.
데이터가 몇가지 한정된 상수값으로 구성될 때 주로 사용된다. 
예) 
계절은 봄, 여름, 가을, 겨울의 4개 값으로 구성되고,
요일은 월, 화, 수, 목, 금, 토, 일의 7개 값으로 구성.
이런 형태의 값들을 한번에 관리하기 위해 사용하는 데이터타입이 
Enum, 즉 열거형이다. 

열거형 데이터 타입은 내부적으로 java.lang.Enum 클래스
를 상속받고 있다. 
따라서 별도로 다른 클래스를 상속 받을수 없다. (단일상속만)
작성할 때도 class 대신 enum 키워드를 사용한다. 

enum 내부에는 사용할 값들을 상수 형태로 나열.
이 값들은 'enum 상수'라고 불리며 상수의 이름 작성법에 따라 
일반적으로 대문자로 쓰고, 단어 연결 시는 '_'를 사용한다. 
이 enum 상수 하나하나가 enum 타입의 객체가 된다. 
각각의 enum 상수에 접근할 때는 상수 답게 " Enum_이름.상수명"
의 형태로 접근.

실습19
ex)
enum Grade {
SALES, PART_TIME_JOB, NORMAL
}
System.out.println(Grade.SALES);

이클립스에서 enum을 작성할 때는 이클립스 메뉴
File -> New -> Enum을 선택.

enum 은 일반적인 클래스와는 여러 면에서 다른 점이 있다.
일단 제어자는 접근제어자 에서 public과 default(package)만 
사용가능. 이미 java.lang.Enum 을 상속받고 있어서,
추가로 다른 클래스를 상속 받을수 없다. 
여러 인터페이스를 구현하는 것은 상관이 없다. 

enum 타입을 사용할때는 클래스와 동일하게 선언하며 할당될수 있는 값은 
enum 상수와 null 값으로 한정된다.

실습20
ex)
package ch08.enume;

enum Grade {
	SALES, PART_TIME_JOB, NORMAL
}

public class GradeEnumTest {
	private static final int SALES = 100;
	private static final int PART_TIME_JOB = 200;
	private static final int NORMAL = 300;

	private static final int SPRING = 100;

	public void calcSalNormal(int grade) {
		if (grade == SALES) {
			System.out.println("영업 실적 반영");
		} else if (grade == PART_TIME_JOB) {
			System.out.println("근무 시간 반영");
		} else if (grade == NORMAL) {
			System.out.println("근로 계약 기준");
		}
	}

	public void calcSalEnum(Grade grade) {
		if (grade == Grade.SALES) {
			System.out.println("영업 실적 반영");
		} else if (grade == Grade.PART_TIME_JOB) {
			System.out.println("근무 시간 반영");
		} else if (grade == Grade.NORMAL) {
			System.out.println("근로 계약 기준");
		}
	}

	public static void main(String[] args) {
		Grade grade = Grade.SALES;
		System.out.println(grade);
		System.out.println(grade instanceof Enum); // true
		System.out.println(grade instanceof Object); // true

	}
}
//
SALES
true
true

enum 을 선언할 때는 다른 클래스의 외부뿐 아니라 클래스 
내부에도 선언 가능. 이때 외부클래스 에서 해당 enum 상수에
접근하기 위해서는 "외부클래스_이름.내부 enum_이름.enum_상수명"
의 형태로 사용.
참고, 일반클래스도 하나의 클래스 내부에서 또 다른 클래스를 선언가능.
이것을 내부클래스 (inner 클래스)라고 부른다.
내부클래스에 대한 자세한 내용은 10장에서 다룬다. 

실습21
ex)
package ch08.enume;

public class InnerEnumTest {
	enum MyEnum {
		DATE, BIRTH_DATE
	}

	public static void main(String[] args) {
		System.out.println(MyEnum.DATE);
	}
}

class OuterClass {
	public void useInnerEnum() {
		System.out.println(InnerEnumTest.MyEnum.BIRTH_DATE);
	}
}
//
DATE

----------------------------------------------------
3.2 enum 상수의 필요성 

enum을 사용하는 이유?
예)
직군에 따라 급여를 계산하는 방식의 다른 애플리케이션이 있다.
영업직, 일반직, 아르바이트의 3가지 구분을 두고 급여를 계산할 때 
다음과 같이 상수로 직군을 구분해서 작성한다. 

ex)
public static final int SALES = 1;
public static final int PART_TIME_JOB = 2;
public static final int NORMAL = 3;
// 직군그룹 , 값 충돌 발생: 1은 누구?

public static final int SEASON = 1; //계절그룹
public void calcSalNormal(int grade) {
if(grade == SALES) {
System.out.println("영업 실적 반영");
}else if(grade == PART_TIME_JOB) {
System.out.println("근무 시간 반영");
}else if (grade == NORMAL) {
System.out.println("근로 계약 기준");
}
}

SALES, PART_TIME_JOB, NORMAL 등은 변경되지 
않을 값들이기 때문에 final이고, 어디서나 접근이 쉽도록 
public static이 추가되었다. 네번째 상수로 앞의 상수들과는 
어울리지 않는 SEASON도 있는데 값은 SALES와 동일하다.
만약, calcSalNormal() 메서드를 다음과 같이 호출하면 
어떻게 될까?
ex)
calcSalNormal(SALES);
calcSalNormal(SEASON);

둘은 모두 실제적으로는 1이라는 값을 갖기 때문에 결과는 동일.
하지만, SALES가 급여를 받는 것은 맞지만, SEASON이 급여를 
받는 것은 이해하기 어렵다.
calcSalNormal()에는 SALES, PART_TIME_JOB, NORMAL
중 하나가 들어가야 최초의 의도에 적합하다. 하지만 엉뚱한 값이 
연결되더라도 오류가 발생하지 않는다. 이로써 잠재적인 결함이 발생 할수있다. 
이런 것을 논리적 오류라고 한다. 
calcSalNormal()이 int 타입이라면 어떤 것이든 파라미터로 받을수
있기 때문에 발생하는 일이다.

위의 enum을 이용한다면 급여를 계산하는 메서드는 다음처럼 
바꿀수 있다. 

ex)
enum Grade{
SALES, PART_TIME_JOB, NORMAL
}

public void calcSalEnum(Grade grade){//SEASON 정보 할당불가
if ( grade == Grade.SALES) {
System.out.println("영업 실적 반영");
}else if ( grade == Grade.PART_TIME_JOB) {
System.out.println("근무시간반영");
} else if (grade == Grade.NORMAL) {
System.out.println("근로계약기준");
}
}

별로 달라진 점이 없어 보이기도 한다. 
눈에 보이는 차이점은 먼저 단순히 변수로 관리 되던 것들은 
모아서 enum 타입으로 관리되었다.
중요한 차이점은 enum을 이용하면 비교할때 단순히 값만을
비교하는 것이 아니라 타입까지 비교한다는 점. 

calcSalEnum() 호출할 때는 반드시 Grade에 선언된 값 중 
하나만 할당될수 있다. 
이렇게 enum을 이용하면 값과 함께 타입에 대한 체크를 동시에 
진행함으로써 안정적인 프로그래밍 가능.


----------------------------------------------------
3.3 enum 상수를 이용한 연산 

enum 상수는 주로 비교 연산에서 사용.
두개의 enum 값이 같은지 파악할때는 == 연산자 또는 
equals 메서드를 사용.
하지만 기타 부등호 연산자는 사용할수 없다.
대신 상수가 정해진 순서를 이용해서 비교할 수 있는데
이때는 객체 간 비교이므로 부등호 대신 enum 클래스에 선언된 
compareTo() 라는 메서드를 사용할 수 있다. 
각각의 enum 상수들은 선언된 순서대로 ordinal(순서)
값을 갖는데 인덱스와 유사하게 0부터 시작하는 정수값이다.
compareTo()는 이 ordinal 값의 차이를 리턴한다. 

switch ~ case 문의 비교 조건에도 enum이 많이 사용되는데 
주의할점 여기서는 타입 없이 바로 상수값만 이용한다. 

실습22
ex)
package ch08.enume;

enum Season {
	SPRING, SUMMER, FALL, WINTER
}

public class SeasonEnumTest {
	public void compareEnum(Season season) {
		if (season.equals(Season.SPRING)) {
			System.out.println("따뜻한 봄날입니다.");
		} else if (season.compareTo(Season.WINTER) < 0) {
			System.out.println("최소한 겨울은 아니잖아요.");
		} else {
			System.out.println(season.compareTo(Season.WINTER));
		}
	}

	public void enumSwitch(Season season) {
		switch (season) { // switch 문에서는 enum 이름 생략 
		case SPRING:
			System.out.println("새 잎이 나는 시기");
			break;
		case SUMMER:
			System.out.println("열매가 무르 익는 시기");
			break;
		case FALL:
			System.out.println("잎이 떨어지는 시기");
			break;
		default:
			System.out.println("겨울잠을 자는 시기");
		}
	}

	public static void main(String[] args) {
		SeasonEnumTest set = new SeasonEnumTest();
		set.compareEnum(Season.FALL);
		set.enumSwitch(Season.SPRING);
		System.out.println(Season.WINTER.ordinal());
	}

}
//
최소한 겨울은 아니잖아요.
새 잎이 나는 시기
3
----------------------------------------------------
3.4 enum 메서드 

enum 타입들은 java.lang.Enum 클래스를 기본적으로 상속받고 
있어서 java.lang.Enum 클래스에 선언된 메서드들의 사용이 가능.

java.lang.Enum의 메서드 
메서드 명 :  선언부와 설명 
name() : public final String name()
enum 상수의 이름을 문자열로 리턴.

ordinal() : public final int ordinal()
0부터 시작하는 enum 상수의 순서를 리턴.

compareTo() : public final int compareTo(E o)
enum 상수의 ordinal 차이를 리턴.

values() : public static T [] values()
enum 타입에 선언된 enum 상수를 배열로 리턴. 

valueOf() : public static < T extends Enum <T> >
T valueOf(Class<T> enumType, String name)
문자열로 매핑된 enum 상수 객체를 리턴한다. 

실습23
ex)
package ch08.enume;

enum Tea {
	COFFEE, BLACK_TEA, GREEN_TEA
}

public class EnumMethodTest {
	public static void main(String[] args) {
		Tea[] teaArray = Tea.values();
		for (Tea tea : teaArray) {
			String strName = tea.name();
			System.out.printf("이름: %s%n", strName);
			System.out.printf("등장 순서: %d%n", tea.ordinal());
			// 문자열을 다시 Enum 타입으로
			Tea reTea = Tea.valueOf(strName);
			System.out.printf("원래의 객체와 같은가?- reTea.equals(tea): %b%n", reTea.equals(tea));
		}
	}
}
//
이름: COFFEE
등장 순서: 0
원래의 객체와 같은가?- reTea.equals(tea): true
이름: BLACK_TEA
등장 순서: 1
원래의 객체와 같은가?- reTea.equals(tea): true
이름: GREEN_TEA
등장 순서: 2
원래의 객체와 같은가?- reTea.equals(tea): true


----------------------------------------------------
3.5 enum 멤버 추가 

enum에도 사용자가 원하는 멤버를 추가해서 사용가능.
enum 상수 하나하나가 객체임을 신경쓴다면 작성 및 사용법은 
일반 클래스에서의 메서드 작성과 동일하다. 
주의점은 단순히 enum 상수들만을 정의할때는 마지막에 세미콜론(';')
이 필요 없지만, 별도로 멤버를 추가하는 경우에는 세미콜론을 
추가해서 상수 선언이 끝나는 것을 표시해줘야 한다. 

실습24
ex)
package ch08.enume;

enum Greeting {
	GOOD_MORNING, GOOD_AFTERNOON, GOOD_EVENING;
	//세미콜론 주의 
	String message;
	
	public Greeting nextGreeting() {
		if(this.equals(GOOD_EVENING)) {
			return GOOD_MORNING;
		}else if(this.equals(GOOD_AFTERNOON)) {
			return GOOD_EVENING; //각각의 객체 즉 enum 상수의 멤버가된다.
		}else {
			return GOOD_AFTERNOON;
		}
	}
}

public class CustomMemberTest {
	public static void main(String[] args) {
		Greeting current = Greeting.GOOD_AFTERNOON;
		current.message = "Hello";
		Greeting next = current.nextGreeting();
		next.message = "Hi";
		System.out.printf("지금: %s, 메시지: %s%n", current, current.message);
		System.out.printf("다음: %s, 메시지: %s%n", next, next.message);
	}
}
//
지금: GOOD_AFTERNOON, 메시지: Hello
다음: GOOD_EVENING, 메시지: Hi

----------------------------------------------------
3.6 생성자를 이용한 enum 상수 초기화 

enum에 추가한 멤버변수를 enum 생성자에서 초기화해서 사용가능.
주의, enum의 생성자의 접근제어자는 언제나 private이며 생략가능.
따라서 외부에서 해당 생성자를 호출할수 없고, 내부에서 상수를 정의하면서 
바로 파라미터를 전달한다.

실습25
ex)
package ch08.enume;

enum Family {
	FATHER("아빠"), MOTHER("엄마"), SON("아들"), DAUGHTER("딸");
	private String kor;
	
	Family(String kor){ //내부에서만 호출가능
		this.kor = kor;
	}

	public String getKor() {
		return kor;
	}

	public void setKor(String kor) {
		this.kor = kor;
	}
}

public class UseConstructorTest {
	public static void main(String[] args) {
		Family current = Family.MOTHER;
		System.out.printf("값 확인: %s, kor: %s%n", current, current.getKor());
		current.setKor("어머니");
		System.out.printf("값 확인: %s, kor: %s%n", current, current.getKor());
	}
}
//
값 확인: MOTHER, kor: 엄마
값 확인: MOTHER, kor: 어머니


----------------------------------------------------
4. 애노테이션 (annotation)

4.1 애노테이션

사전적의미 '주석'. 자바의 주석 형태로는 이미 단일 행주석(//),
다중 행 주석(/*...*/), javaDoc 주석(/**...*/) 있다.
또, 주석 
애노테이션은 개발자가 읽기 위한 주석이 아니라 JVM, 컴파일러, 
프레임워크 등에게 전달되는 일종의 메타데이터 이다.
메타데이터 란 (metadata)란 다른 데이터를 설명해주는 데이터로 
속성 정보라한다. 즉, 부가적인 정보를 추가하기 위해 그 데이터와
함께 제공 되는 것이다. 예를 들어 사람은 나이라는 데이터가 있는데 
나이는 1년씩 늘어난다와 같은 설명은 메타데이터가 된다.

예)
스프링(Spring)이라는 자바 프레임워크에서 단위 테스트를 위한 
클래스에 적용된 애노테이션의 예 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations =
{"file:src/main/webapp/WEB-INF/mvc-config.xml"})
@WebAppConfiguration
public class RequestMappingTest {
..
}

클래스 선언부에 잔뜩 @로 시작하는 애노테이션들이 가득하다.
이처럼 애노테이션은 소스 코드에 라벨을 붙여 놓은 형태이며 코드에 대한 
부가적인 정보를 제공한다. 
이 정보를 JVM, 컴파일러, 프레임워크 등이 읽어서 소스 코드의
구조를 변경하기도 하고 환경설정 정보를 추가하기도 한다. 

----------------------------------------------------
4.2 JDK 에 포함된 기본 애노테이션

대부분 애노테이션은 별도의 프레임워크에서 제공된다. 따라서 
우리가 JDK를 통해 직접 사용해볼 애노테이션이 많지는 안다.
JDK에서 제공되는 대표적인 애노테이션들은 다음과 같다. 

애노테이션   :   설명 
@Override : 컴파일러에게 재정의된 메서드라고 알려준다.
@Deprecated : 앞으로 없어질수 있으니 사용을 자제하라고 알려준다.
@SupressWarnings : 컴파일러에게 특정 경고 메시지를 무시하라고 알려준다
@FunctionalInterface : 함수형 인터페이스라는 것을 알려준다.
(Lambda 참조)

@Override는 메서드 재정의에서 잠깐 언급한 바가 있다. 
컴파일러에게 ' 이 메서드는 재정의한 메서드이니 형식에 맞는지 
컴파일할 때 확인하세요.' 라는 요청을 전달한다.
따라서 @Override를 사용했는데 메서드 이름에 오타가 
있는 등 재정의 방법에 어긋나게 작성하면 오류가 발생한다.
이로써 안정적인 메서드 재정의가 가능하다.

실습26
ex)
package ch08.annotation;

class SuperClass{
	protected void someMethod() {}//오버라이드 실패 
}
public class SafeOverrideTest extends SuperClass{
	//@Override
	void someMeth0d() {}
	//The method someMeth0d() of type SafeOverrideTest must override or implement a supertype method
}

@Override가 someMeth0d에 선언되어 있고,
원래 조상메서드는 someMethod이므로 이름이 달라서 
메서드 재정의 실패. 컴파일러는 이를 파악하고 오류 메시지를 
발생시키며 컴파일이 진행되지 않는다. 
@Override 애노테이션을 주석 처리하면 오류는 없어지지만,
메서드 재정의와는 상관없이 새로운 메서드가 추가.

상속 범위 private -> default -> protected -> public

Deprecated란 원래 사용하던 메서드에 대해 앞으로 없어질 수 있으니 
더이상 사용하지 않도록 권고한다는 말. 보안적인 이슈가 발생했거나
더 좋은 성능의 메서드로 대체를 권장할때 사용된다.
메서드 선언부에 @Deprecated가 추가된 메서드를 사용하게 되면 
컴파일러가 경고 메시지를 출력한다. 

실습27
ex)
package ch08.annotation;

import java.util.Date;

class SomeClass{
	@Deprecated
	public void oldMethod() {}
}

public class DeprecatedTest {
	public static void main(String[] args) {
		SomeClass sc = new SomeClass();
		sc.oldMethod();
		
		new Date(2000, 01, 01);		
	}
}

@SupressWarnings 은 말 그대로 경고를 막겠다는 표시.
프로그래밍하다 보면 다양한 경고 메시지를 볼수 있는데 이때
경고 내용에 대해 이미 알고 있으니 보여주지 않아도 된다는 뜻.

ex)
package ch08.annotation;

public class SupressWarningTest {
	@SuppressWarnings(value="unused")
	public void method1() {
		int i = 0; // The value of the local variable i is not used
	}
	
	// @SuppressWarnings(value="unused") // 배열이지만 할당하려는 값이 하나인 경우 중괄호 생략 가능
	// @SuppressWarnings(value={"unused", "rawtypes"}) // 배열 형태의 값 할당
	@SuppressWarnings({ "unused", "rawtypes" }) // 할당하려는 속성이 하나인 경우 value 생략 가능
	public void method2() {
		int i = 0; 
		java.util.List list;
	}
}

int 타입의 변수 i를 선언했지만 사용한 적이 없다. 
이 경우 컴파일러는 값이 사용된 적이 없다는 경고 메시지를 출력.
이 경고를 보고 싶지 않다면 5행처럼 @SuppressWarnings
애노테이션에 'unused' 파라미터를 전달한다. 

@FunctionalInterface 는 함수형 인터페이스 선언에 활용되는 
애노테이션으로 10장에서 다룬다. 

----------------------------------------------------
4.3 애노테이션 구성요소

3개의 애노테이션 사용 했음. 사용법 조금씩 다름.
@Deprecated , @Override 경우 메서드 선언부에 
애노테이션 작성.
@SuppressWarnings의 경우는 로컬 변수의 위치에 작성하고 
파라미터까지 전달하고 있다. 사용법의 차이는?
그래서, @SuppressWarnings 를 좀더 살펴보자. 
중요한 애노테이션은 아니지만 사용법을 알기에 좋다. 

ex)
메타 애노테이션
@Target({TYPE, FIELD, METHOD, PARAMETER,
CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)

애노테이션 선언 
public @interface SuppressWarnings {
String[] value(); //애노테이션 속성
}

애노테이션 만들 때는 interface 선언과 유사하게 @interface
라고 선언한다. 애노테이션은 크게 선언부에 추가된 @Target, @Retention
과 같은 메타 애노테이션과 애노테이션 블록에 선언된 속성 정보로 구성.

속성 정보는 애노테이션의 바디 영역에 마치 추상 메서드 형태로 작성.
@SuppressWarnings 는 value 라는 속성이 하나 선언되어 있다. 
메서드의 이름인 value가 속성의 이름이고, 리턴 타입인 String[]이 
속성의 타입이다. 

이 속성을 사용할때 다른 속성들처럼 애노테이션을 선언할 때
'키 = 값' 형태로 전달한다. 만약 할당하려는 속성이 value 
하나뿐이면 키인 value를 생략하고 바로 값만 설정할수도 있다. 

값을 할당할때는 일반적인 자바의 자료형을 사용가능. 
다만 배열을 표현할때는 대괄호([]) 대신 중괄호({})로 
묶어서 표현하고 만약 그 값이 하나만 있으면, 즉 배열의 길이가 
1일 경우는 중괄호를 생략할수 있다. 따라서 위 
@SuppressWarnings는 다음처럼 다양하게 선언가능. 

ex)
//키 = 값 형태로 배열 할당 
@SuppressWarnings(value = {"unused","rawtypes"})
// 배열이지만 값이 하나인 경우는 중괄호 생략 가능 
@SuppressWarnings(value = "unused")
//할당하려는 속성이 value 하나인 경우 키 생략 가능 
@SuppressWarnings({"unused","rawtypes"})

또한, 속성에 기본값(default)을 설정해 놓을 수 있는데 
이런 경우 속성 설정을 생략할수있다. 
하나의 애노테이션에 여러 개의 속성이 있을수 있는데 쉼표를 이용해서 
속성들을 구분가능.

ex)
@annotationName(param1 = "value1", param2="value2")

애노테이션 선언부에는 대부분 @Target과 @Retention 같은 
메타 애노테이션(애노테이션의 정보를 표시하는 애노테이션)이 있다.
마치 상속처럼 메타 애노테이션의 속성은 대상 애노테이션에 전판된다. 
애노테이션을 잘 사용하기 위해서는 특히 @Target 정보가 중요하다.

@Target은 애노테이션을 어디에서 사용할수 있는가를 나타낸다. 
@Target의 소스코드.
ex)
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
ElementType[] value();
}

@Target은 ElementType[] 타입의 value 속성을 가지며 
모든 애노테이션은 각자 value에 지정된 ElementType에만 선언될수
있다. ElementType은 enum 타입으로 가지고 있는 enum
상수값은 다음과 같다. 

ElementType 의 종류 
상수값		:	범위
TYPE : 클래스, 인터페이스(annotation type 포함)또는 enum 타입 
FIELD : 필드 또는 enum 타입의 값 
METHOD : 메서드 
PARAMETER : 메서드의 파라미터
CONSTRUCTOR : 생성자 
LOCAL_VARIABLE : 로컬변수
ANNOTATION_TYPE : 다른 애노테이션
PACKAGE : 패키지

따라서 @Target 애노테이션은 자신의 @Target에 할당된 
value가 ANNOTATION_TYPE이기 때문에 다른 애노테이션
설정에만 올수있고, @SuppressWarnings의 경우 
@Target의 value가
{TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR,
LOCAL_VARIABLE}이기 때문에 클래스 등 타입, 멤버 변수,
메서드, 파라미터, 생성자, 로컬변수 등에 올수 있다. 

@Retention은 얼마나 오랫동안 애노테이션 정보를 유지할 것인지
나타낸다.
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
RetentionPolicy value();
}

@Retention의 @Target 정보가 ANNOTATION_TYPE 이므로 
다른 애노테이션에만 사용가능. value 속성은 RetentionPolicy가 
하나 할당될 수 있는데 이것 역시 enum 타입으로 다음의 상수들이 정의 
되어 있다. 

RetentionPolicy의 enum 상수값 

상수값  :		적용범위
SOURCE : 컴파일러가 사용하며 결과물인 클래스 파일 안에는 
포함되지 않음 
CLASS : 컴파일시 클래스 안에 포함되나 VM에서 무시하며 
리플렉션(reflection)시 정보를 얻을수 없음 
RUNTIME : 컴파일시 포함되고 VM에서 인식하며 리플렉션 시
정보를 얻을수있음. 

리플렉션은 메모리에 생성된 객체를 통해서 거꾸로 클래스의 
정보를 분석해 내는 프로그래밍 기법이다.
이를 통해서 객체가 가지는 멤버변수, 메서드 등의 정보를 알수있다. 
주로 자동화된 툴을 만드는 일 등에서 많이 사용된다. 

우리가 일반적으로 컴파일러를 건드릴 일은 없기 때문에 
대부분 사용자 정의 애노테이션은 RUNTIME 까지 정보를 유지하고 
리플렉션을 통해서 작업을 처리한다. 
리플렉션의 자세한 내용은 java.lang.reflect API를 참조. 

----------------------------------------------------
4.4 사용자 정의 애노테이션 사용 

직접 애노테이션을 만들어 사용해보자.
만들어볼 애노테이션은 멤버변수에 설정하며 멤버변수의 용도(web 또는 db)
에 따라 자동 분류되도록 지원한다. 또한, 아직 값이 할당되지 않았을 때 
기본값이 할당될수 있도록 지원하는 기능도 갖도록 할것이다. 

이클립스에서 애노테이션을 생성하는 대화상자를 이용하기 위해서는
File -> New -> Annotation 선택 
혹시, 메뉴가 나오지 않을 경우 Other 선택후 filter 
항목에서 Annotation을 검색. 

Name : MyPropLabel 
Modifiers : public
Add @Retention : Runtime
Add @Target : Field 
이름이나 패키지, 접근제어자 설정은 클래스와 동일. 
추가로 메타 애노테이션인 @Retention과 @Target에 
대한 설정이 가능.
리플렉션을 사용할 예정이기 때문에 
@Retention은 Runtime을 선택. 
멤버변수에 사용할 계획이므로 @Target에서는 Field에 체크.

ex)
package ch08.annotation.custom;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

@Retention(RUNTIME)//유효기간이 RUNTIME으로 설정되어 리플렉션 적용 가능 
@Target(FIELD)//적용대상이 FIELD라서 멤버변수에 적용가능.
public @interface MyPropLabel {
String value();//애노테이션은 String 타입의 value 속성을 갖는다.
기본값이 없으므로 애노테이션 적용시 반드시 값을 지정해야 한다. 

String strDefault() default "아직 값 설정 전";
}// strDefault는 String 타입의 속성으로 default 값을 
가지고 있으므로 반드시 설정해야 할 필요는 없다. 

정의된 애노테이션 적용 

실습28
ex2)
package ch08.annotation.custom;

public class CustomPropSet {
	@MyPropLabel("db")
	String dbHost="127.0.0.1";
	@MyPropLabel(value="web", strDefault="localhost")
	String serverHost;
	@MyPropLabel("db")	
	String dbPort;
	@MyPropLabel(value="web", strDefault="8080")	
	String serverPort;
}
애노테이션이 적용된 속성들을 어떻게 써먹을지 고민해보자. 
우리는 MyPropLabel에 얼마나 많은 멤버가 있는지 상관없이
순식간에 web 용도와 db 용도로 사용되는 변수들을 구별해 낼 것이다.
또한, 값이 할당되지 않은 변수들에 대해서 strDefault에 해당하는 
값들로 설정할 계획이다. 

다음 예는 리플렉션을 이용해 위 기능들을 구현. 

실습29
ex3) 
package ch08.annotation.custom;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class UseCustomAnnotationTest {

	public static void main(String[] args) throws Exception {
		CustomPropSet cps = new CustomPropSet();
		Map<String, Object> dbProp = new HashMap<>();
		Map<String, Object> webProp = new HashMap<>();

		Field[] fields = CustomPropSet.class.getDeclaredFields();
		for (Field field : fields) {
			MyPropLabel annotation = field.getDeclaredAnnotation(MyPropLabel.class);
			if (field.get(cps) == null) {
				field.set(cps, annotation.strDefault());
			}
			if (annotation.value().equals("web")) {
				webProp.put(field.getName(), field.get(cps));
			} else {
				dbProp.put(field.getName(), field.get(cps));
			}
		}
		System.out.printf("DB 관련 변수: %s%n", dbProp);
		System.out.printf("WEB 관련 변수: %s%n", webProp);
	}
}
//
DB 관련 변수: {dbPort=아직 값 설정 전, dbHost=127.0.0.1}
WEB 관련 변수: {serverPort=8080, serverHost=localhost}

지금까지 사용자 정의 애노테이션을 만들고 사용법에 대해 알아보았다. 
많은 경우 애노테이션은 시스템이나 프레임워크 등에서 제공하는 것을 
사용하는 정도가 일반적이다. 
더구나 위 내용은 뒤에 배울 API들을 많이 포함하기 때문에 현재 
단계에서는 이해하기 어려운 측면이 있다. 
실망하지 말고 뒷부분까지 학습한 후 다시 살펴보는 것도 좋다. 

----------------------------------------------------
5. 제너릭

5.1 제너릭의 필요성 
제너릭(Generic : 일반화)은 JDK 1.5 버전에서 등장.
당시에는 아주 획기적인 기능.
제너릭을 사용하면 컴파일 시점에 사용할수 있는 객체의 타입을 체크하기 때문에 
프로그램의 안전성이 획기적으로 향상되고 코드도 줄어든다. 
앞으로 언급하게 될 컬렉션 프레임워크, 람다식 등 API 전반에 걸쳐
사용되므로 반드시 잘 이해해야 한다. 
특히 제어자들이 적용된 복잡한 제너릭의 경우 잘 이해하지 못하면 
메서드를 사용할수 없게 된다. 

예)
마트에서 장난감과 식료품 구매 가정. 
물건을 사면 포장용 상자에 담는다.
담을 때 별다른 생각없이 아주 편리하게 담을수 있다. 
집 도착후, 열어본 상자에는 '물건'들이 담겨있고, 
하나를 빼낼 때 정확히 어떤 물건(장난감 또는 식료품)
이 나올 줄은 모른다. 물건을 정리하기 위해서는 하나씩 물건을
보고 확인해야 한다. 
과정에 필요한 것이 instanceof 연산자의 활용이고, 잘못되면 
ClassCastException이 발생. 

뭐든지 담을수있는 상자의 편리함과 번거로움.

실습30
ex)

package ch08.generic.type;

class Toy{}
class Grocery{}

class NormalBox{
	private Object some;
	public Object getSome() {
		return some;
	}
	public void setSome(Object some) {
		this.some = some;
	}
}

public class NormalBoxTest {
	
	public static void main(String[] args) {
		NormalBox nBox1 = new NormalBox();
		nBox1.setSome(new Toy());
		Object some = nBox1.getSome();
		if(some instanceof Toy) {
			Toy toy = (Toy)some;
			// toy 사용
		}else if(some instanceof Grocery) {
			Grocery grocery = (Grocery)some;
			// grocery 사용
		}else {
			System.out.println("알수 없음");
		}
		nBox1.setSome("Hello");
	}
}

이처럼 Object를 저장하는 일반적인 상자는 모든 객체를 
담을수있는 편리함이 있지만, 나중에 객체를 사용할 때에는 
어떤 객체인지 확인하고 사용해야 하는 번거로움이 있다. 

애초에 상자에 장난감, 식료품이라고 라벨을 붙였다면 어떨까?
그렇게 되면 담는 과정에서 상자별로 정확히 담아야 한다. 
장난감은 장난감 상자에, 식료품은 식료품 상자에 담길것이다. 
설마 장난감에 식료품을 담지는 않았을 것이다. 
이제 집에 와서 정리할 때 식료품 상자에서 빼낸 물건은 당연히 
식료품일 테니 확인할 필요가 없다. 
이렇게 상자에 라벨을 붙이는 개념이 바로 제너릭이다. 

제너릭은 미리 사용할수 있는 타입을 명시해서 컴파일 타임에 
타입을 체크한다. 
따라서 런타임에 발생할수 있는 ClassCastException이 
발생하지 않는다. 또한, 나중에 찾아서 쓸 때 형변환을 하지 않아도 
되도록 한다. 즉 instanceof를 이용해 객체의 타입을 비교할 
필요가 없어서 소스 코드가 간단해진다. 

이제 제너릭은 클래스 또는 인터페이스, 메서드의 파라미터, 메서드의 
리턴타입에 사용된다. 

---------------------------------------------------- 
5.2 제너릭 타입 

(1) 제너릭 타입의 작성과 객체 사용 
클래스와 인터페이스에 제너릭이 적용된 타입을 제너릭 타입이라고 한다. 
제너릭 타입은 클래스 및 인터페이스 이름 뒤 '<>'를 쓰고
내부에 타입 파라미터를 명시한다. 

ex)public class Class_Name<T> {}
public interface Interface_Name <T> {}

제너릭 타입과 상대적으로 제너릭을 사용하지 않은 상태를 원시 타입(Raw Type)
이라고 한다. 

위에서 T라고 쓰인 부분이 타입 파라미터 선언이다. 
일반적으로 타입 파라미터는 상징성을 나타내는 대문자 알파벳 하나를
사용하는데 여기서는 타입(Type)의 의미로 사용했다. 
작성자가 임의로 지정하는 것이기 때문에 꼭 T라고 써야 하는 것은 아니다. 
일반적으로 참조 타입을 말할때 T(Reference Type),
요소를 말할때 E(Element),
키를 이야기할 때 K(Key),
값을 나타낼 때 V(Value)를 쓰지만, 딱히 정해진 것은 아니다. 

예) 컬렉션 프레임워크의 클래스인 ArrayList와 HashMap 클래스에 
선언된 타입 파라미터의 예이다. 

ex)
public class ArrayList<E> extends AbstractList<E>
implements List<E>, RandomAccess, Cloneable,
java.io.Serializable{..}

public class HashMap<K,V> extends AbstractMap<K,V>
implements Map<K,V>, Cloneable, Serializable{..}

타입 파라미터는 클래스를 작성하는 시점에서는 무엇인지 알수없다.
나중에 그 클래스를 이용해서 객체를 만들 때 타입 파라미터가 전달되고 
형식이 결정된다. 

제너릭 타입의 객체를 만들때는 타입 선언시 타입 파라미터 부분에 실제 사용할 
객체 타입을 적는다. 사용하는 생성자 쪽에는 타입 파라미터를 적을수도 있고
생략할수도 있다. 
단, 타입을 적을 때는 클래스에 선언한 타입 파라미터와 같은 타입을 적는다. 
ex)
Class_Name<String> generic = new class_Name<String>();
Class_Name<String> generic2 = new class_Name<>();
Class_Name generic3 = new Class_Name();

위의 예에서 세번째 경우처럼 제너릭 타입의 클래스를 선언할때 제너릭 타입을
사용하지 않고 원시 타입을 사용하면 이클립스에서 경고를 출력.
가급적 제너릭 타입을 사용하자. 

앞의 NormalBoxTest 예제를 변경한 GenericBoxTest를 보자.

실습31
ex)
package ch08.generic.type;

import java.util.ArrayList;

class Toy2 {}
class Grocery2 {}

class GenericBox<T> {
	private T some;
	public T getSome() {
		return some;
	}
	public void setSome(T some) {
		this.some = some;
	}
}

public class GenericBoxTest {
	public static void main(String[] args) {
		GenericBox<Toy2> gBox1 = new GenericBox<>();
		gBox1.setSome(new Toy2());
		//Toy2만 할당가능
		Toy2 toy = gBox1.getSome();
		// toy 사용
		GenericBox<Grocery2> gBox2 = new GenericBox<>();
		gBox2.setSome(new Grocery2());
		Grocery2 grocery = gBox2.getSome();
		// grocery 사용
		// gBox1.setSome(new Grocery2()); // Grocery2만 할당 가능
	}
}

이처럼 타입 파라미터를 사용하면 클래스에 넘겨줄수 있는 타입을 제한 가능.
그런데 잠깐 고민해보면 상자에 아무거나 담을 때가 편하기도 했던 것 같다. 
이처럼 모든 타입의 객체를 수용하고 싶을 때는 타입 파라미터에 Object를
넘겨주면된다. 

ex)
GenericBox<Object> objBox1 = new GenericBox<>();
objBox1.setSome(new Toy2());
objBox1.setSome("Hello");

이제는 기존의 NormalBox처럼 모든 객체를 다 사용할수 있게 되었다. 

(2) 타입 파라미터 사용시 주의점 
제너릭은 객체마다 생성될 때 전달된 타입 파라미터를 독립적으로 사용하게 된다. 
따라서 타입 파라미터는 언제나 인스턴스 변수로 간주한다.
그런데 만약 이 타입 파라미터를 static 멤버에 적용하면 어떻게 될까?
static 멤버는 모든 객체가 공유하는 특성이 있고 
static 멤버에서 인스턴스 멤버를 직접 사용할수 없다. 
따라서 static이 붙은 멤버에는 타입 파라미터를 적용할수 없다. 

ex)
public class Test<I> {
static I item;
//Cannot make a static reference to the 
non-static type I
static void method(I item) {}
}

또한, 타입 파라미터를 이용해서 객체를 생성할 수 없다. 
new 연산자는 컴파일 타입에 정확한 타입을 알아야 하는데
클래스 내부에서 파라미터만 보아서는 타입을 알 길이 없기 
때문이다. 비슷한 이유로 instanceof의 피연산자로 
타입 파라미터가 사용될수도 없다. 

ex)
public class Test<I>{
I i = new I(); //Cannot instantiate the type I
Object obj = new Object();
{
if(obj instanceof I) {
//Cannot perform instanceof check against type parameter I
}
}
}

마지막으로 클래스 내부에서 사용할수 있는 타입 파라미터의 메서드는 
Object에 선언된 것으로 한정된다. 아직 타입이 정해지지 않은 상태에서 
누구의 메서드도 가져다 쓸수 없을 것이다. 단, 모든 클래스는 최소한 
Object이기 때문에 Object에 선언된 메서드들은 사용할수있다.

(3) 제너릭 타입의 상속과 구현 
제너릭 타입도 다른 클래스와 마찬가지로 상속을 적용할 수 있다.
이때 부모 클래스에 적용된 타입만을 그대로 사용할 수도 있고 
필요에 따라 타입 파라미터를 추가할 수도 있다. 
단 부모가 선언한 타입 파라미터는 반드시 자식에도 선언되어야 한다. 

실습32
ex)
package ch08.generic.type;

import java.util.Date;

class Fruit{}
class Company{}

class Market<P>{
	protected P product;
}
interface Useable<D>{}

class Mart<C, P, D> extends Market<P> implements Useable<D>{
	private C coworker;
	
	public Mart(C coworker, P product) {
		this.coworker = coworker;
		this.product = product;
	}

	@Override
	public String toString() {
		return "Mart [coworker=" + coworker + ", product=" + product + "]";
	}
}

public class MartTest{
	public static void main(String[] args) {
		Mart<Company, Fruit, Date> mart = new Mart<>(new Company(), new Fruit());
		System.out.println(mart);
		
		Market<Fruit> market = new Mart<>(new Company(), new Fruit());

	}
}
//
Mart [coworker=ch08.generic.type.Company@16f65612, product=ch08.generic.type.Fruit@311d617d]

제너릭 타입의 상속을 배웠는데 다형성을 사용하면서 자주 혼선이 오는 부분을 
짚고 넘어가자.
GenericBox<Object> 와 GenericBox<String>은 어떤 관계가 
있을까? 잘못 생각하면 Object는 모든 객체의 조상이므로 GenericBox<Object>
가 GenericBox<String>의 조상으로 오인하는 경우가 많다. 
하지만 둘은 전혀 상관없는 타입이다. 둘 모두 GenericBox 타입으로 전자는 
Object를 후자는 String을 담을 수 있을 뿐이다. 

타입 파라미터의 관계는 제너릭의 상속 관계와 무관하다. 
다음 처럼 Market과 Mart 가 상속 관계가 있는 것이다. 

ex)
class Mart extends Market {}
Market<Fruit> market = new Mart<Fruit>(new Company(), new Fruit());

(4) 사용 가능한 파라미터 타입의 제한 

타입 파라미터가 선언되면 Object와 그 자식들이 (따라서 모든 객체)
타입 파라미터에 대입될수있다. 하지만, 필요에 따라 대입되는 파라미터의 
타입을 제한할 필요가 있는데 이때 extends 키워드를 사용할수 있다. 

extends가 적용되면 대입할수 있는 타입은 해당 클래스와 그 자식클래스로 한정.
또한, 대입될수있는 객체의 최소 타입이 Object에서 extends에 사용된 
클래스로 변경되기 때문에 타입 파라미터를 통해 사용할수 있는 멤버도 
그 클래스에 선언된 멤버로 확대된다. 

실습33
ex)
package ch08.generic.type;

class NumberBox<T extends Number> {
 // T 는 최소한 Number
	public void addSomes(T... ts) {
		double d = 0;
		for (T t : ts) {
			d += t.doubleValue();
		} // Number의 멤버 사용 가능 
		System.out.println("총 합은: " + d);
	}
}

class TypeRestrict1<T extends Cloneable>{}
class TypeRestrict2<T extends Number & Cloneable>{}

public class ExtendsTest {

	public static void main(String[] args) {
		NumberBox<Number> numBox = new NumberBox<>();
		numBox.addSomes(1.5, 5, 4L);
		
		NumberBox<Integer> intBox = new NumberBox<>();
		intBox.addSomes(1,2,3);

		//NumberBox<String> strBox = new NumberBox<>();//Bound mismatch
	} //Number의 하위 클래스만 사용 가능 
}
//
총 합은: 10.5
총 합은: 6.0

타입 파라미터로 받을 수 있는 타입을 인터페이스로 제약해야 할 
경우에도 implements가 아니라 extends 를 사용함을 주의하자. 
추가로 클래스와 함께 인터페이스를 동시에 제약 조건에 명시하기위해서는 
&를 사용한다. 

ex)
class TypeRestrict1< T extends Cloneable> {}
class TypeRestrict2< T extends Number & Cloneable> {}


----------------------------------------------------
5.3 제너릭 메서드 

(1) 메서드에 선언된 제너릭 
제너릭 선언은 클래스뿐 아니라 메서드에서도 이뤄짐.
메서드의 리턴 타입 앞에 타입 파라미터 변수를 선언하고 
리턴 타입 또는 파라미터로 사용가능.

ex)
[제어자] <타입_파라미터, [...]> 리턴_타입 메서드_이름(파라미터){
//do something
}

물론 메서드에 선언된 타입 파라미터의 사용 범위는 해당 메서드로 
국한되며 메서드가 호출될때 확정된다. 타입 파라미터의 타입은 
두가지 방식으로 결정되는데 코드를 통해서 명시적으로 
사용할 타입을 지정하거나 컴파일러가 파라미터의 값을 보고 
타입을 추정하게 할수있다. 

실습34
ex)

package ch08.generic.method;

public class TypeParameterMethodTest<T> {

	T some;
	
	public TypeParameterMethodTest(T some){
		this.some = some;
	}
	
	public <P> void method1(P p) {
		System.out.println("클래스 레벨의 T"+some.getClass().getName());
		System.out.println("파라미터: " + p.getClass().getName());
	}
	
	public <P> P method2(P p) {
		System.out.println("클래스 레벨의 T"+some.getClass().getName());
		System.out.println("파라미터: " + p.getClass().getName());
		return p;
	}
	
	public static void main(String[] args) {
		TypeParameterMethodTest<String> tpmt = new TypeParameterMethodTest<>("Hello");
		tpmt.method1(10);
		tpmt.<Long>method2(20L);
	}
}
//
클래스 레벨의 Tjava.lang.String
파라미터: java.lang.Integer
클래스 레벨의 Tjava.lang.String
파라미터: java.lang.Long

다음과 같은 코드는 읽을 때 약간 혼돈이 올수 있다. 

public <P> TypeParameterMethodTest<T> ambigious (P p){
}
//<P> : 메서드 타입 파라미터
//TypeParameterMethodTest<T> : 리턴타입 

메서드 선언부에 <P>와 <T>가 선언된 것처럼 보이지만 <P>는 
메서드에 선언된 타입 파라미터가 맞고 <T>는 제너릭 클래스로 
TypeParameterMethodTest<T> 자체가 리턴 타입이다. 

또한, 클래스에 선언된 타입 파라미터는 static 멤버에서 사용할수 없지만,
static 멤버에서 선언되는 타입 파라미터를 사용하는 데는 전혀 지장이 
없다. 

ex)
public class StaticMethodTest<t>{
public static void method(T t) { //오류발생
// do something
}

public static <P> p method ( P p ) {
//do something
return p;
}
}

(2) 와일드카드의 사용 
제너릭 메서드에서는 사용되는 타입 파라미터에 제한을 두기 위해
와일드카드로 '?'를 사용한다. 와일드카드는 단독으로 사용될수 있고
extends나 super와 함께 사용될수 있다. 

1) <?> : 타입의 제한이 없으며 <? extends Object>와 동일 
2) <? extends T> : 와일드카드의 상한을 제한한다. 
이 타입 파라미터에는 T와 T를 상속받은 자손만 대입 가능. 
3) <? super T> : 와일드카드의 하한을 제한.
이 타입 파라미터에는 T와 그 조상 타입만 대입할수 있다. 

실습35
ex)
package ch08.generic.method;

class Person {}
class SpiderMan extends Person {}
class PersonBox<T> {}

public class WildTypeTest {
	public void method1(PersonBox<?> some) {}
	public void method2(PersonBox<? extends Person> some) {	}
	public void method3(PersonBox<? super Person> some) {}

	public static void main(String[] args) {
		WildTypeTest wtt = new WildTypeTest();

		wtt.method1(new PersonBox<Object>());
		wtt.method1(new PersonBox<Person>());
		wtt.method1(new PersonBox<SpiderMan>());
		
		//wtt.method2(new PersonBox<Object>());	
		wtt.method2(new PersonBox<Person>());
		wtt.method2(new PersonBox<SpiderMan>());
		
		wtt.method3(new PersonBox<Object>());
		wtt.method3(new PersonBox<Person>());
		//wtt.method3(new PersonBox<SpiderMan>());
	}
}
//


	

===================================
[자바 해바라기 정리] 9 예외처리와 디버깅

1. 예외(Exception)와 오류 

이클립스에서 프로그램을 작성하다 보면 자주 콘솔 창에 
빨간색의 글씨가 나오면서 당혹스럽게 한다. 
이런 경우 프로그램은 정상 동작 안하고 바로 종료한다.
예)
다형성에서 형변환이 잘못되는 경우 ClassCastException
이라는 예외가 발생하면서 프로그램은 종료된다.

프로그램이 어떤 원인에 의해 비정상 종료되는 상황에서 발생 
하는 것을 예외 또는 오류라고 한다. 

예외와 오류는 일반적으로 심각도에 따라 분류된다. 

먼저 오류(Error)는 메모리가 부족하거나 메서드끼리 호출을 
무한반복 하는것처럼 일단 발생하면 복구하거나 되돌릴수 없는 
심각한 상황이다. 
이 상황에 대한 처리방법은 오류를 발생하는 요인을 찾아서 
없애는 디버깅 뿐이다.
즉, 프로그램을 잘 짜는 것만이 대안이기 때문에 이 장의 목적인 
예외처리와 무관하다

반면, 예외(Exception)는 오류와 비교하면 심각도가 낮으며
프로그램의 정상적인 흐름을 방해하는 상황이다.
예)
파일을 읽으려고 할때 해당 파일이 없거나, 
네트워크 프로그램 동작 중 네트워크연결이 끊기는 상황들.
이런 상황들은 최초 프로그램의 작성 의도에서는 벗어난다.
읽을 파일없거나, 네트워크가 끊기는 경우는 프로그램이 
잘못 작성된 경우라고 보기 어렵고, 그냥 종료된다면 
매우 아쉽다. 
차라리 파일이 없다는 경고 메시지를 보여주면 어떨까?
종료할 필요 없이 다른 파일을 선택할수 있게 도와주면 
사용자의 불편을 최소화할수 있다. 

네트워크가 끊겼을때 연결이 안된다는 메시지를 보여주고 
잠시후 다시 시도하게 하는 것이 좋다. 
예외가 발생시 비정상적인 종료를 막고 계속해서 사용할수 있게
처리하는 것을 예외처리(Exception Handling)라 한다.
이를 위해 예외를 감지하는 코드와 예외가 발생했을때 동작하는 
코드가 필요하다.

배열의 예는 intArray는 1개의 데이터를 가지고 있는 배열.
그런데 2번 인덱스의 자료를 출력하고 있다.
ex)
int [] intArray = {10};
System.out.println(intArray[2]);

당연히 비정상적으로 종료된다.
종료되는 대신에 '배열의 길이를 확인하세요'라는 
오류 메시지를 보내준다면 좋지 않을까?

자바는 잘 짜인 상속 계층구조로 예외 관련 클래스 제공함.
예외와 관련된 최상위 클래스는 Throwable 이다.
하지만, 직접 사용하기보다는 Throwable 를 상속받은
Exception이나 Error가 주로 사용됨.
또한, Error는 예외 처리의 대상으로 보지 않기 때문에
제외하면 나머지 Exception 클래스와 그 하위 클래스가 
주요 처리 대상이다.

예외 클래스의 계층 
Object 하위 
Throwable 하위
1)Exception, 2)Error
1)
Exception의 하위 
SQLException 
IOException의 하위 
FileNotFoundException

Checked exception 계열 

1)
Exception의 하위 
RuntimeException의 하위 
ArithmeticException

UnChecked exception 계열 

2)
Error의 하위
OutOfMemoryError 

Error 계열 

Exception은 다시 RuntimeException 계열과
그외의 Exception 계열로 나뉜다.
차이는 컴파일 시점에 예외 상황에 대한 대비 코드 (try ~ catch)
가 있는지를 체크하는지 여부에 있다.
각각 unchecked exception과 checked exception.

RuntimeException의 하위 클래스들은 모두 
unchecked exception으로 예외에 대한 처리 코드가 
없어도 컴파일 오류가 발생하지 않는다. 
물론, 대비 코드를 작성하지 않은 상태에서 예외가 발생하면 
프로그램은 비정상 종료된다. 
하지만, 나머지 checked exception의 경우 예외에 
대한 처리 코드가 없을 경우 컴파일 오류가 발생하므로 
반드시 작성해야 한다. 

checked exception, unchecked exception 모두 
일단 발생하면 해당 예외에 대한 처리 코드가 있어야 
프로그램의 비정상 종료를 막을수 있다. 

----------------------------------------------------
2. 예외 처리 기법 

2.1 try - catch 구문 

예외를 거창하게 설명했지만 처리하는 방식은 사실 매우 간단하다. 
예외처리에는 try~catch 블록을 이용한다. 

먼저,try 블록에는 예외가 발생할 수 있는 코드를 작성한다. 
catch의 파라미터에는 try 블록에서 발생할수 있는 예외를 
설정한다. 마지막으로 catch 블록에서는 해당 예외가 발생했을 때
처리할 코드를 작성한다. 

ex) 
try {
// 예외가 발생할수 있는 코드 -> 이때 JVM 의 동작 
} catch (XXException e ) { // 던진 예외를 받음
//예외가 발생했을때 처리할 코드 
}
이때 JVM 의 동작 에서 
try 블록 모니터링 -> exception 발생 ->
new XXException() 후 던짐(throw)

작성된 코드는 나중에 JVM 에 의해 실행될 것이다. 
try 블록에 들어서면 JVM은 해당 블록을 유심히 
모니터링한다. 그리고 어떤 문제가 발생하면 그 문제에 해당하는 
예외객체를 생성(new XXXException())해서 던져버린다.(throw).
이 예외를 잡아채는 것이 catch이다. 
catch의 파라미터에 JVM이 던진 예외가 할당되면 catch 블록이 동작. 

다음 예 배열의 특정 위치에 있는 자료를 출력하고, '프로그램 종료합니다'
라는 메시지를 출력하고 종료하는 것이다. 
하지만, 배열이 가진 index 범위를 벗어난 위치에 있는 자료를 참조하려 
하기 때문에 java.lang.ArrayIndexOutOfBoundsException
이라는 예외가 발생하고 프로그램은 바로 종료.

ex)
package ch09.exception;

public class SimpleException {

	public static void main(String[] args) {
		int[] intArray = { 10 };
		System.out.println(intArray[2]); //예외발생하면
		System.out.println("프로그램 종료합니다."); //이 행은 동작안함.
	}
}
//
Exception in thread 
"main" java.lang.ArrayIndexOutOfBoundsException: 
Index 2 out of bounds for length 1
at ch09.exception.SimpleException.main
(SimpleException.java:7)

위 코드에서는 컴파일에는 문제가 없었지만, 실행 결과를 보면
알수 있듯이  ArrayIndexOutOfBoundsException 이발생.
따라서 프로그램은 비정상적으로 종료되었고, 8행의 메시지는 
출력되지 않았다. 이처럼 컴파일에는 지장이 없지만, 
프로그램 동작 중 발생하는 예외가 바로 runtime 
계열의 예외(unchecked exception)이다. 

위에서 발생한 예외를 try ~ catch 블록을 이용해서 처리.

ex)
package ch09.exception;

public class SimpleTryCatch {

	public static void main(String[] args) {
		int[] intArray = { 10 };
		try {
			System.out.println(intArray[2]);
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("예외가 발생했지만 처리함: 배열 크기 확인 필요");
			System.out.printf("예외 처리: 배열 크기 확인 필요:%s%n", e.getMessage());
			e.printStackTrace();
		}
		System.out.println("프로그램 종료합니다.");
	}
}
//
예외가 발생했지만 처리함: 배열 크기 확인 필요
예외 처리: 배열 크기 확인 필요:Index 2 out of bounds 
for length 1
java.lang.ArrayIndexOutOfBoundsException:
Index 2 out of bounds for length 1
프로그램 종료합니다.
at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)


//e.printStackTrace();
예외가 발생했지만 처리함: 배열 크기 확인 필요
예외 처리: 배열 크기 확인 필요:Index 2 out of bounds for length 1
프로그램 종료합니다.

예외가 발생할 수 있는 코드 즉 8행을 try블록으로 감싼다. 
이 블록에서 
ArrayIndexOutOfBoundsException이 발생하고 JVM에 의해 던져짐.
JVM이 던진 예외객체가 e 변수에 할당되고 catch 블록이 동작한다. 
예최 처리가 끝났으므로 예외가 사라졌다. 이제 프로그램은 정상적으로 
종료된다. 

----------------------------------------------------
2.2 Exception 객체의 정보 활용 

catch 블록에 전달되는 예외 객체의 상위 객체는 Throwable이다. 
Throwable은 다양한 메서드로 예외에 대한 정보를 전달할 수 있는데,
주요 메서들은 다음과 같다. 

메서드명   : 선언부와 설명 
getMessage() : public String getMessage()
:발생된 예외에 대한 구체적인 메시지를 반환한다. 사용자 정의 예외를 
만들때 생성자를 통해 message를 공급할 수 있다. 

getLocalizedMessage() : public String getLocalizedMessage()
:예외의 메시지를 수정할때 오버라이드하며 별도로 오버라이드 하지 
않을 때는 getMessage()와 같다. 

getCause() : public Throwable getCause()
:예외의 원인이 되는 Throwable 객체 또는 null을 반환한다. 

printStackTrace() : public void printStackTrace()
:예외가 발생된 메서드가 호출되기까지의 메서드 호출 스택을 출력한다. 
디버깅의 수단으로 주로 사용된다. 

getMessage()는 발생한 예외에 대한 구체적인 메시지를 반환하므로
간단히 예외에 관한 내용을 확인시 좋다. 

printStackTrace()는 예외에 대한 자세한 디버깅을 위해 
주로 사용되는 메서드이다. 예외가 발생한 메서드가 호출되기 전까지
거쳐 온, 즉 그때 당시 구성된 메서드의 호출 스택을 추적해서 모두 
출력해준다. 정보가 많아서 부담스러울수 있지만, 전체적인 메서드들의
동작과 함께 예외의 발생 원인, 지점을 파악할때 아주 유용한 메서드이다. 

앞의 catch 블록을 다음처럼 수정 후 다시실행 

ex)
catch (ArrayIndexOutOfBoundsException e) {
System.out.printf("예외 처리: 배열 크기 확인 필요:%s%n", e.getMessage());
e.printStackTrace();
}
//결과 
예외 처리: 배열 크기 확인 필요:2
java.lang.ArrayIndexOutOfBoundsException:
Index 2 out of bounds for length 1
at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)
프로그램 종료합니다.
(SimpleTryCatch.java:8) //클릭시 SimpleTryCatch.java 8행으로 이동 

e.getMessage()의 결과는 2이다. 즉 배열에서 2번째 인덱스에 
접근하려 했기 때문에 발생한 예외이다. 
그 이후는 printStackTrace() 의 동작 결과다. 
이클립스에서 실행하면 빨간색으로 내용이 출력돼서 긴장하게 되는데 
일반적인 출력이 System.out을 이용하는 반면 예외 정보 출력에는 
System.err 가 사용되는 것일 뿐 정상적인 처리의 결과이니 
걱정할 필요 없다.
java.lang.ArrayIndexOutOfBoundsException이 
2번 인덱스에 접근하므로 인해 발생했고 SimpleTryCatch의
main() 메서드 즉 SimpleTryCatch.java 의 8행에서 
발생했음을 알려주고 있다. 
이클립스 콘솔에서 해당하는 행번호를 클릭하면 소스 파일로 편하게 이동. 

참고,
이클립스에서 앞의 소스 코드를 실행하다 보면 출력결과가 매번 좀 다르게 
나타난다. 이는 정상 메시지를 출력하는 스트림(System.out)과 
오류메시지(System.err)를 출력하는 스트림이 꼬여서 발생하는 일종의
오류이다. 

실행결과1 
예외 처리: 배열 크기 확인 필요:2
java.lang.ArrayIndexOutOfBoundsException:2
at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)
프로그램 종료합니다.

실행결과2
예외 처리: 배열 크기 확인 필요:2
java.lang.ArrayIndexOutOfBoundsException:2
프로그램 종료합니다.
at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)

실행결과3
예외 처리: 배열 크기 확인 필요:2
프로그램 종료합니다.
java.lang.ArrayIndexOutOfBoundsException:2

at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)

가장 이상적인 출력순서는 실행결과1 이지만,
다른 결과도 잘못된 것은 아니다. 
윈도우에서 명령프롬프트 창을 통해 프로그램을 실행하면 언제나
실행결과1이 출력된다. 

----------------------------------------------------
2.3 try - catch 구문의 흐름 

try 블록에는 문제가 발생할 수 있는 코드도 있고 그럴 염려가
없는 일반 코드도 섞여 있을수 있다. 

먼저, 예외가 발생하지 않는 경우
일단, try 블록에 있는 코드들이 다 실행된다. 
이후 catch할 예외가 발생하지 않았기 때문에 catch 블록은 
건너뛰고 catch 블록 다음 문장을 수행. 

하지만, try 블록에서 예외가 발생하면 그 이후의 일반 코드는 
수행되지 못하고 발생한 예외를 처리할수 있는 catch 블록으로 
연결된다. 만약 적당한 catch 블록을 만나지 못하면 예외처리는 실패다. 
예)
투수가 변화구를 던지는데 포수는 직구만 받을 수 있다면 포수는 
투수가 던진 공에 얻어맞는다. 
catch 블록이 실행된 후는 발생한 예외가 없어진 후이므로 
다음에 등장한 일반 코드들이 문제없이 수행된다. 

정수를 0으로 나누면 연산이 불가능하다. 이런 경우 자바에서는 
java.lang.ArithmeticException이 발생한다. 
다음 코드는 Random 클래스를 이용해 0 ~ 1 사이의 
무작위 정수를 만들고 이 숫자로 다른 정수를 나눴을 때 
상황별로 코드의 동작을 살펴볼수 있다. 

ex)
package ch09.exception;

import java.util.Random;

public class TryCatchFlow {

	public static void main(String[] args) {
		int num = new Random().nextInt(2);
		try {
			System.out.println("code 1, num: "+ num);
			int i = 1/num;
			System.out.println("code 2 - 예외 없음");
		}catch(ArithmeticException e) {
			System.out.println("code 3 - 예외 처리 완료");
		}
		System.out.println("code 4");
	}
}
//예외가 없는 경우
code 1, num: 1
code 2 - 예외 없음
code 4
//예외가 있는 경우
code 1, num: 0
code 3 - 예외 처리 완료
code 4



----------------------------------------------------
2.4 다중 예외 처리 

try 블록 내에서 한종류의 예외만 발생하라는 법은 없다. 
여러 종류의 예외를 처리하기 위해서는 어떻게 해야 할까?

하나의 try 블록에 여러 개의 catch 블록을 연결할 수 있다. 
각각의 catch 블록에서는 처리하려는 예외 타입을 선언하면 된다. 

ex)
try {
// exception 이 발생할 만한 코드 :YYException e 발생 
}catch (XXException e) { 
// XXException 발생시 처리코드  :e is a XXException? no
}catch (YYException e) {
// YYException 발생시 처리코드 : e is a YYException? yes
}catch(Exception e) {
// Exception 발생 시 처리코드 
}

그런데 여기서 catch 블록에서 처리할 예외의 순서를 정할때 주의할 점이 있다. 
JVM이 던진 예외를 적절한 catch 블록에게 연결할 때에도 
다형성이 적용된다. 
즉, 맨처음 등장한 catch 블록의 예외에서부터 차근차근 할당해보고 적용 가능한
경우라면 해당 catch 블록을 사용한다. 위의 예에서 만약 처음 
catch에서 처리할수 있는 예외가 XXException 이 아니라 
Exception이라면 어떻게 될까?

Exception은 다른 예외들의 조상 클래스 타입이기 때문에 
모든 예외가 처음 catch 블록에서 처리될수 있다. 
따라서 나중에 등장하는 catch 블록들은 평생 할 일이 없어진다. 
이 경우 'Unreachable catch block for Exception'
즉 '도달할수 없는 catch 블록'이라는 컴파일 에러가 발생한다. 

따라서 상속 관계가 없는 여러 예외를 처리할때는 순서가 상관없지만,
상속관계가 있는 예외를 처리하기 위해서는 자식 예외부터 조상 예외의 
순서로 catch 블록을 작성해야 한다. 

이번에는 checked exception 계열의 다중 예외를 
처리하는 예 
여기서 처리할 예외는 3개.
3줄의 코드를 사용할 것이고 각각 다른 예외를 발생시킨다. 
이 예외들은 checked exception 계열이므로 예외 처리에 대한 
코드를 작성하지 않으면 컴파일 되지 않는다. 각 코드에서 
발생하는 예외는 주석으로 표시했다. 

ex)
public static void main(String[] args) {
Class.forName("abc.Def"); //ClassNotFoundException
new FileInputStream("Hello.java"); //FileNotFoundException
DriverManager.getConnection("Hello");// SQLException
System.out.println("프로그램 정상 종료");
}

이 3개의 예외는 다행히 계층 관계는 없다. 따라서 순서와 무관하게 
예외를 처리할수 있다. 

ex)
package ch09.exception;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.sql.DriverManager;
import java.sql.SQLException;

public class MultiExceptionHandling {

	public static void main(String[] args) {
		try {
			Class.forName("ch09.exception.MultiExceptionHandling"); // ClassNotFoundException
			new FileInputStream("Hello.java"); // FileNotFoundException
			DriverManager.getConnection("Hello"); // SQLException
		} catch (ClassNotFoundException e) {
			System.out.printf("클래스를 찾을 수 없습니다.: %s%n", e.getMessage());
		} catch (FileNotFoundException e) {
			System.out.printf("파일을 찾을 수 없습니다.: %s%n", e.getMessage());
		} catch (SQLException e) {
			System.out.printf("DB 접속 실패: %s%n", e.getMessage());
		}
		System.out.println("프로그램 정상 종료");
	}
	
	public void exceptionHandling() {
		try {
			Class.forName("ch09.exception.MultiExceptionHandling"); // ClassNotFoundException
			new FileInputStream("Hello.java"); // FileNotFoundException
			DriverManager.getConnection("Hello"); // SQLException
		} catch (ClassNotFoundException | FileNotFoundException e) {
			System.out.printf("자원을 찾을 수 없습니다.: %s%n", e.getMessage());
		} catch (SQLException e) {
			System.out.printf("DB 접속 실패: %s%n", e.getMessage());
		}
		System.out.println("프로그램 정상 종료");
	}
}
//
파일을 찾을 수 없습니다.: Hello.java (지정된 파일을 찾을 수 없습니다)
프로그램 정상 종료

앞서 이야기했듯이 catch 블록은 다형성을 적용해 JVM이 던진 예외를 
할당한다. 따라서 catch 블록의 순서가 중요하다. 그럼 차라리 처음에 
Exception 하나로 모든 예외를 처리 할수도 있지 않을까?
Exception은 모든 예외의 상위 객체이기 때문에 아주 간단히 처리 할수 
있을것 같다. 

ex)
try {
Class.forName("ch09.exception.MultiExceptionHandling");
new FileInputStream("Hello.java");
DriverManager.getConnection("Hello");
}catch(Exception e){
System.out.printf("예외 처리 합니다.:%s%n", e.getMessage());
}

결론, 잘 동작함. 하지만, 예외라는 것은 다양한 상황에서 발생하는데
위 처럼 뭉뚱그려 Exception으로 처리하면 상황에 따른 예외 처리가 
어렵다. 
병은 여러가지인데, 처방은 언제나 하나인 경우.
따라서, 될수 있으면 예외는 예외별로 처리하는 것이 바람직하다. 

그런데 예외 중에는 성격이 비슷해서 처리하는 방식도 비슷한 것들이 있다. 
위의 예에서 보면, ClassNotFoundException이나 
FileNotFoundException의 경우 모두 사용하려는 리소스가 
없는 경우이다. 따라서, 대응도 유사하다. 
이런 경우 '|' 기호를 이용해서 여러 예외를 연결할 수 있다. 

ex)
public void exceptionHandling() {
try{
Class.forName("ch09.exception.MultiExceptionHandling");
new FileInputStream("Hello.java");
DriverManager.getConnection("Hello");
}catch(
ClassNotFoundException | FileNotFoundException e){
System.out.printf("자원을 찾을수 없습니다.:%s%n", e.getMessage());
}catch(SQLException e){
System.out.printf("DB 접속 실패: %s%n", e.getMessage());
}
System.out.println("프로그램 정상 종료");
}

위 예는 상속의 관계가 없는 예외들이 발생했을 경우이다. 
상속의 관계가 있을 경우는 자식 예외에 대한 처리가 먼저 
이루어져야 하고 조상 예외에 대한 처리가 나중에 이루어져야
한다. 

파일을 읽기 위해서는 FileInputStream을 생성하고 
이 객체가 제공하는 read() 메서드를 이용할수 있다. 
이때, FileInputStream의 
생성자에서는 java.io.FileNotFoundException
이 발생할 수 있고 read() 메서드에서는 java.io.IOException
이 발생할수 있다. 이들은 다음과 같은 상속의 관계가 이루어진다. 

java.lang.Object
 java.lang.Throwable
   java.lang.Exception
     java.io.IOException
	   java.io.FileNotFoundException
FileNotFoundException의 상속관계 

다음예 상속 관계에 있는 다중 예외를 처리하는 방식을 보여준다. 

ex)
package ch09.exception;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class HierarchyException {

	public static void main(String[] args) {
		String src = "./.project";
		try {
			FileInputStream input = new FileInputStream(src);
			int readData = -1;

			while ((readData = input.read()) != -1) {
				System.out.print((char) readData);
			}
		} catch (FileNotFoundException e) {
			System.out.printf("읽으려는 파일이 없습니다.: %s%n", e.getMessage());
		} catch (IOException e) {
			System.out.printf("파일 읽기에 실패했습니다.: %s%n", e.getMessage());
		}
		System.out.println("파일 읽음 완료!");
	}
}
//
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>java_press</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jdt.core.javanature</nature>
	</natures>
</projectDescription>
파일 읽음 완료!

// String src = "./.project"; , 프로젝트 안에 있음. 
// 파일은 이클립스를 통해 자바 프록젝트를 만들 때,
기본적으로 생성되는 파일.

try 블록 내에서 FileInputStream 객체를 생성하고 
read() 메서드를 사용한다. 
각각 FileNotFoundException과 IOException이 발생할수 
있으며 처리 코드가 필요하다. 

상속관계에 따라 FileNotFoundException과 
IOException의 순서대로 catch 블록을 구성한다. 

ch09.exception.HierarchyException.java 를 실행하면 
정상적으로 파일의 내용이 콘솔에 출력된다. 
간혹 혼동하는 때도 있는데 예외 발생에 대처하는 코드는 예외가 발생해서 
처리하는 것이 아니라 예외가 발생할수 있어서 대비하는 것이다. 
따라서 실제 발생 여부와는 상관없다. 
뒤에 throws 절에서 살펴보겠지만 단지 예외가 발생할수 있는 API를 
사용했다는 이유만으로 예외처리가 필요하다. 

----------------------------------------------------
2.5 try - catch - finally 구문 

try ~ catch 블록은 추가로 finally 블록을 가질수 있다. 
finally 블록은 예외발생여부와 상관없이 반드시 실행되어야 하는 
내용을 작성한다. 심지어 중간에 return 문을 만날때에도 
먼저 finally 블록을 실행 후 메서드가 리턴된다. 

ex)
try {
//exception 이 발생할 만한 코드 
}catch(Exception e) {
//XXException 발생시 처리코드
}finally{
// try block에서 접근했던 System 자원의 안전한 원상복구
}

try~catch~finally 블록의 실행 흐름에 대한 예제.
주의점, try 블록에서 마지막에 return문이 있다는 점. 

ex)
package ch09.exception;

import java.util.Random;

public class TryCatchFinallyFlow {
	public static void main(String[] args) {
		int num = new Random().nextInt(2);
		try {
			System.out.println("code 1, num: " + num);
			int i = 1 / num;
			System.out.println("code 2 - 예외 없음");
			return;
		} catch (ArithmeticException e) {
			System.out.println("code 3 - 예외 처리 완료");
		} finally {
			System.out.println("code 4 - 언제나 실행");
		}
		System.out.println("code 5");
	}
}
// 예외가 나온 경우
code 1, num: 0
code 3 - 예외 처리 완료
code 4 - 언제나 실행
code 5
//예외가 없는 경우
code 1, num: 1
code 2 - 예외 없음
code 4 - 언제나 실행
/return으로 code5 로 넘어감.

finally 블록의 주요 목적은 try  블록에서 
사용한 시스템 자원(System resource)의 반납처리다.
시스템 자원이란 데이터베이스 접속을 위한 Connection이나 
파일 I/O 를 위한 Stream 등을 들수있다. 
많은 시스템 자원들은 사용시 예외를 발생시킬수 있어서 
try 블록 내에서 사용하게 된다. 
시스템 자원은 유한하므로 사용 후 반납되지 않으면 
장래 리소스 릭(resource leak)이 발생할 수 있다. 
이러한 자원 반납은 애플리케이션이 정상적으로 사용했을 때는 
물론 예외가 발생했을때도 처리되어야 한다. 
다음은 finally 블록을 이용한 리소스 반납 코드의 예이다. 

ex)
package ch09.exception;

import java.io.FileInputStream;
import java.io.IOException;

public class CloseResourceTest {
public static void main(String[] args) {
CloseResourceTest crt = new CloseResourceTest();
System.out.println("--있는 파일(정상적)인 경우");
crt.useStreamOldStyle(".project");
System.out.println("--없는 파일인 경우");
crt.useStreamOldStyle("abc.txt");
}

public void useStreamOldStyle(String file) {
FileInputStream fileInput = null;
try {
fileInput = new FileInputStream(file);
System.out.println("FileInputStream이 생성되었습니다.");
fileInput.read();
} catch (IOException e) {
System.out.println("파일 처리 실패");
finally {
System.out.println("finally 블럭 동작");
if (fileInput != null) {
try {
fileInput.close();
System.out.println("FileInputStream이 종료되었습니다.");
} catch (IOException e) {
System.out.println("FileInputStream 종료 실패");
}
}
}
}



public void useStreamNewStye(String file) {
try (FileInputStream fileInput = new FileInputStream(file)) {
System.out.println("FileInputStream이 생성되었습니다.");
fileInput.read();
} catch (IOException e) {
System.out.println("파일 처리 실패");
}
}
}
//
--있는 파일(정상적)인 경우
FileInputStream이 생성되었습니다.
finally 블럭 동작
FileInputStream이 종료되었습니다.
--없는 파일인 경우
파일 처리 실패
finally 블럭 동작

//17-20
FileInputStream의 생성자에서는 
FileNotFoundException이 발생할수 있고
read() 메서드에서는 IOException이 발생할수 있어서 
try 블록으로 감싸져 있다. 
여기서 생성한 FileInputStream이 나중에 종료해야 하는 시스템 자원이다. 
//
20-21
FileNotFoundException의 조상클래스인 IOException으로 
catch 블록을 구성한다. 
22-32 
finally 블록에서 리소스를 종료해야한다. 
FileInputStream을 종료하기 위해 
fileInput 의 close() 메서드를 호출한다. 



----------------------------------------------------
2.6 try - with - resources 구문 

위의 예제는 안전하고, 완벽하게 시스템 리소스를 사용하는 방법이다.
그런데 finally 블록이 상당히 지저분.
사실 필요한 코드 fileInput.close() 한줄.
그런데 콘솔에 메시지 출력 내용을 빼더라도 8줄의 코드가 
finally 블록을 구성. 상당한 과대포장.
과대포장이 필요한 이유는 2가지.

1) close() 메서드 자체가 IOException을 발생시킬수 있는 코드이다. 
따라서, try~catch로 묶여야 한다. 

2) FileInputStream의 생성자에서 예외가 발생하는 경우 
fileInput 객체가 null이 되므로 try 블록에서 null에 대한 
대응 (fileInput != null 의 코드)도 필요한 것이다. 

이런 불편한 점을 개선하기 위해 자바 7버전에서 새롭게 추가된 기능이 
try~with~resources 구문이다. 
이 구문은 try 문의 선언부에 리소스를 선언하면 관련 
try~catch 블록을 모두 수행한 후 선언된 리소스들을 자동으로 
close 처리 해준다. 

ex)
try(리소스_타입1 res1 = 초기화; 리소스_타입2 res2 = 초기화;...)
{ // 예외 발생 코드
}catch(Exception e) {
// 예외처리코드
}

단 이 리소스들은 반드시 AutoCloseable 인터페이스를 구현해야 한다. 
AutoCloseable에는 close() 메서드가 하나 선언되어 있는데 
try~with~resource 구문을 사용하면 
try~catch 에 대한 처리가 끝난후 AutoCloseable 의 
close() 메서드를 자동으로 호출해준다. 
각종 I/O 작업을 위한 Stream 들이나 통신을 위한 Socket,
데이터베이스를 사용하기 위한 Connection 등은 대부분 AutoCloseable
인터페이스를 구현하고 있다. 

다음은 위의 finally 블록에서 리소스를 종료하는 코드를 
try~with~resource 문의 형태로 변경해서 처리한 예.

ex)
public void useStreamNewStye(String file){
try(FileInputStream fileInput = new FileInputStream(file)){
System.out.println("FileInputStream이 생성되었습니다.");
fileInput.read();
}catch(IOException e){
System.out.println("파일 처리 실패");
}
}

엄청난 코드의 다이어트가 이뤄졌다. 단지, try의 선언문에 
FileInputStream을 선언하고 초기화했을 뿐이다. 
참고로, try 선언문에서 초기화된 객체는 try 블록 내에서 
재생성될수 없다. 

물론 그렇다고 finally 블록이 필요 없다는 이야기는 전혀 아니다. 
finally 블록은 여전히 AutoCloseable을 지원하지 
않는 리소스의 종료에도 사용되고 다른 정리 작업에도 아주 중용하게 사용된다. 

----------------------------------------------------
3. throws 키워드를 통한 처리 위임 

3.1 throws 키워드 

예외 처리의 두번째 방법은 throws 키워드를 통한 위임 또는 전달. 
throws 는 메서드에서 처리해야 할 하나 이상의 예외를 메서드를 
호출한 곳으로 던져버린다. 이런 위임은 처리와는 다르다. 
try~catch에서 catch 블록은 예외를 처리해서 없애 버린다. 
하지만 위임은 예외를 없애지 못하고 단지 호출한 곳으로 예외를 전달할 뿐이다. 
예외를 전달받은 메서드는 다시 예외 처리의 책임이 발생한다. 

다음 예, 
먼저 methodCaller()는 exceptionMethod()를 호출. 
이 메서드는 Exception1, Exception2 등 여러 예외에 대한 
처리가 필요한 상황이었고 그에대한 try~catch 대신 throws 키워드를 
통해 메서드를 호출한 곳으로 예외를 전달한다. 
이제 다시 methodCaller()가 예외를 가지게 되었고 try~catch 를
통해 처리하든지 아니면 다시 어딘가 methodCaller()를 호출했던 곳으로 
다시 throws 처리할수 있다. 

ex)
void exceptionMethod() throws Exception1,Exception2{
//예외발생코드
}

void methodCaller(){
try{
method();
}catch(Exception e){}
}
throws를 통한 예외 전파 

throws를 통해서 예외를 전달할 때에도 다형성을 적용가능.
즉 처리할 예외의 상위 타입으로 throws 처리가 가능하다. 
위의 예에서도 exceptionMethod()가 던진 예외는 
Exception1, Exception2 이지만 처리하는 
methodCaller()는 모든 예외의 상위 타입인 Exception
으로 처리하고 있다. 

----------------------------------------------------
3.2 예외의 타입에 따른 throws 특징 

실제로 어떻게 예외가 전달되는지 과정을 확인해보자.
다음 예제, 꼬리에 꼬리를 물면서 다른 메서드를 호출한다.
마지막 메서드는 예외를 발생시키는 코드를 사용하고 있지만 
처리하지 않고 throws를 이용해 예외를 전달한다.
이 메서드의 호출 흐름(메서드 호출 스택)을 처음 유발한 
main() 메서드에서는 최종적으로 try~catch 문을 
이용해서 예외를 처리해야 한다. 
main()에서도 이 예외를 처리하지 않으면 프로그램은 
비정상 종료된다. 즉 예외 처리 실패다. 

ex)
package ch09.exception;

public class CheckedThrowsTest {
	public static void main(String[] args) {
		CheckedThrowsTest et = new CheckedThrowsTest();
		try {
			et.method1();
		} catch (ClassNotFoundException e) {
			System.out.printf("예외 처리: %s%n",e.getMessage());
			//e.printStackTrace();
		}
		System.out.println("프로그램 종료");
	}

	public void method1() throws ClassNotFoundException {
		method2();
	}

	public void method2() throws ClassNotFoundException {
		Class.forName("Some Class");
	}
}
//
예외 처리: Some Class
프로그램 종료


unchecked exception인 RuntimeException 계열은 
별도로 try~catch 문을 사용하지 않아도 컴파일이 진행되는 특징이
있었다. throws에서도 비슷한 상황인데 RuntimeException 
계열은 try~catch 가 없으면 별도의 throws 절이 없어도 예외의 
전달이 자동으로 진행된다. 하지만, throws는 처리가 아니기 때문에 
언젠가는 try~catch로 처리되어야 함을 명심하자. 

다음은 unchecked exception 계열의 예외가 전달되고 
처리되는 예이다. 정수를 0으로 나눴을때 발생하는 ArithmeticException이
어떻게 처리되는지 살펴보자. 

ex)
package ch09.exception;

public class RuntimeThrowsTest {
	public static void main(String[] args) {
		RuntimeThrowsTest et = new RuntimeThrowsTest();
		try {
			et.method1();
		} catch (ArithmeticException e) {
			System.out.printf("예외 처리: %s%n",e.getMessage());
		}
		System.out.println("프로그램 종료");
	}

	public void method1() {
		method2();
	}

	public void method2() {
		int i = 1/0;
	}
}
//
예외 처리: / by zero
프로그램 종료

1을 0으로 나누기 때문에 runtime exception 계열의 
ArithmeticException이 발생한다.
하지만 별도의 try~catch가 없으므로 자동으로 throws 처리된다.
이제 method2()를 호출한 15행이 예외를 가지고, 역시 별도의 
try~catch 없으므로 method1() 을 호출한 main()으로 예외가 
전달된다. 
최종적으로 main() 메서드에서 ArithmeticException을 처리한다. 

----------------------------------------------------
3.3 로그 분석과 예외의 추적 

Throwable 클래스가 가지는 printStackTrace() 메서드를 
사용하면 예외가 발생하고 전파된 메서드 호출 스택에 대한 정보를 
확인할수 있다. 이 메서드는 최초 호출 메서드에서 부터 예외가 
발생한 메서드까지의 스택 정보를 출력한다. 

CheckedThrowsTest의 catch 블록에 있는 출력문을 
e.printStackTrace()로 변경하고 실행해보자. 

ex)
try{
et.method1();
}catch(ClassNotFoundException e){
//System.out.printf("예외처리:%s%n", e.getMessage());
e.printStackTrace();
}

예외 처리: Some Class
java.lang.ClassNotFoundException: Some Class
at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583)
at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
at java.base/java.lang.Class.forName0(Native Method)
at java.base/java.lang.Class.forName(Class.java:315)
at ch09.exception.CheckedThrowsTest.method2(CheckedThrowsTest.java:20)
at ch09.exception.CheckedThrowsTest.method1(CheckedThrowsTest.java:16)
at ch09.exception.CheckedThrowsTest.main(CheckedThrowsTest.java:7)프로그램 종료

API가 연결된 오류 정보는 아주 복잡해 보여서 우리를 당혹스럽게 한다. 
하지만, 길이는 중요치 않다. 로그를 통해서 확인할 정보 3가지다.

1) 어떤 종류의 예외인가? 예외 클래스의 종류를 확인.
java.lang.ClassNotFoundException

2) 예외의 원인은 무엇인가? 예외 객체의 message에 해당하는 내용을 확인. 
Some Class

3) 어디서 발생했는가? 디버깅의 출발점을 확인한다. 
at으로 시작하는 정보들은 메서드의 호출스택을 나타낸다. 
맨위의 메서드가 최초로 예외를 발생시킨 메서드이고 맨 아래가 
그 메서드 호출 스택의 출발점이다. 
매우 많은 메서드가 연관되어 있을수 있지만, 사실 디버깅할수 있는 부분은 
일반적으로 우리가 작성한 소스 부분이다. 
나머지 부분인 시스템 API 부분 또는 외부 라이브러리 부분은 과감히 
건너뛰고 직접 작성한 소스부터 눈여겨 살펴본다. 
따라서 다음의 경우 
at ch09.exception.CheckedThrowsTest.method2
(CheckedThrowsTest.java:20)
가 디버깅 출발점이 된다. 

----------------------------------------------------
3.4 throws의 목적과 API 활용 

앞서 사용했던 FileInputStream의 생성자나 
Class.forName() 메서드와 같은 API 들은 throws를 이용해서 
API를 사용하는 쪽에 예외를 전파하고 있고, 개발자에게는 그 예외를
처리해야 할 책임이 발생한다. 

다음은 FileInputStream의 생성자에 대한 설명문이다. 생성자의 선언부에 
throws 키워드로 FileNotFoundException이 선언되어 있기 때문에 
귀찮지만, 이 생성자를 사용하려면 예외에 대해 책임져야 한다. 
이 생성자의 선언부에는 FileNotFoundException을 throws 하고 
있지만, 설명문 하단을 보면 실제로 throws 하는 항목은 SecurityException
을 포함해서 두가지이다. 
SecurityException은 unchecked exception 계열이므로 
별도의 throws 가 필요 없다. 

여기서 궁금한 점은 왜 이런 API들은 사용자에게 예외 처리를 위임하는 걸까?
설마 try~catch 블록 사용법을 몰라서? 
만약, API 내에서 예외를 처리해버렸다면 throws 같은 내용은 
필요 없었을 것이고 우리도 훨씬 쉽게 프로그래밍이 가능할 것이다. 

만약 예외가 발생하는 API 들이 발생한 예외들을 모두 try~catch로 
처리해버린다면 API를 사용하는 애플리케이션에는 어떤 문제가 발생했는지 
전혀 알수없게 된다. 하지만 개발자에게 예외를 전달함으로써 예외의 처리를 
강요할수 있게 되었고 개발자는 자신이 작성한 애플리케이션에서 
예외 상황에 대한 적절한 처리가 가능해진다. 

예를들어 FileNotFoundException이 발생했을 때 API 내부적으로 
처리를 끝내 버렸다면 개발자의 코드는 파일이 없는 상황에 대해 
어떤 오류가 발생했는지 모르게 되고 애플리케이션은 동작하지 않을 것이다.
하지만 예외를 개발자 코드에게 전파해주면 상황을 인지하고 파일이
없음을 나타내는 경고 메시지를 출력하는 등 적절한 예외 처리를 
할수 있을 것이다. 

Java API :예외발생 - 예외처리 하면, 
개발자코드 : 상황인지못함.

Java API :예외발생 - 예외전파 하면, 
개발자코드 : 상황인지 적절한 예외처리

이처럼 예외는 언제나 try~catch로 처리하는 것만이 능사는 아니다. 
특히, API나 다른 모듈에서 사용되는 기능을 제공하는 경우 예외를 
전달해서 그 예외에 대해 적절히 대응 할수있는 코드를 작성할수 있게 
해줄 필요가 있다. 

throws 가 필요한 상황에 대해 알아보자. 
일반적으로 애플리케이션을 설치할때 인스톨 툴이 사용되는데
일반적으로 3단계를 거친다. 
1단계는 설치에 필요한 파일들을 컴퓨터 임시 파일로 복사한다.
2단계는 설치를 진행하고 
3단계는 설치가 완료되면 임시 파일을 삭제해서 정리한다. 
그런데, 설치 도중 하드 디스크의 용량이 부족하거나 다른 
애플리케이션과 충돌하게 되면 예외가 발생한다. 
이 예외 발생 상황을 인스톨 툴을 사용하는 코드에게 
전달할때 throws 로 처리해서 설치 과정에 문제가 있음을 
알릴수 있다. 

이과정을 프로그래밍으로 전환해보자.
다음의 InstallTool 클래스는 install() 내부에서 
Math의 random() 메서드 값이 0.5 미만인 경우를 문제 
상황으로 간주한다. 이 상황에서 임의로 예외를 발생시켜야 하는데 
JVM이 예외가 발생했을 때, throw라는 키워드를
이용하는 것처럼 코드상에서도 비즈니스 로직상 어떤 문제가 발생하면 
예외 객체 생성후 throw를 이용해 던져버리면 된다. 
예외를 발생시킬 때에는 throw,
전파할 때는 throws 임을 주의 하자. 

ex)
package ch09.exception;

public class InstallTool {
	void copy() {
		System.out.println("파일 복사");
	}

	void install() throws Exception {
		System.out.println("설치");
		if (Math.random() > 0.5) {
			throw new Exception("설치 과정에서 문제 발생");
		}
	}

	void delete() {
		System.out.println("파일 삭제");
	}
}
//
Math.random() 값이 0.5 미만인 경우 throw를 이용해 새로운
예외 객체를 생성한다. 
따라서 11행은 try~catch로 처리해야 하지만, 
통보를 위해 8행처럼 throws를 이용해서 예외를 이 메서드를 
호출한 곳으로 전달한다. 

ex2)
package ch09.exception;

public class UseInstallTool {
	public static void main(String[] args) {
		InstallTool tool = new InstallTool();
		try {
			tool.copy();
			tool.install();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			tool.delete();
		}
		System.out.println("설치 종료");
	}
}
//예외 발생일 경우
파일 복사
설치
java.lang.Exception: 설치 과정에서 문제 발생
	at ch09.exception.InstallTool.install(InstallTool.java:11)
	at ch09.exception.UseInstallTool.main(UseInstallTool.java:8)
파일 삭제
설치 종료

// 예외 발생 안할 경우
파일 복사
설치
파일 삭제
설치 종료

----------------------------------------------------
3.5 메서드 오버라이드 와 throws

앞에 학습했던 메서드 오버라이드 제약 조건의 마지막 항목에 
throws와 연관된 내용이 있다. 
상속의 구조에서 조상클래스 메서드가 예외를 던지고 있고,
자식클래스에서 그 메서드를 오버라이드하는 경우 자식의 메서드는 조상메서드가
던지는 예외보다 부모예외를 던질수없다. 
쉽게 말해서 부모가 치지않은 사고를 자식이 칠수는 없는 것이다. 

다음예는 Parent 클래스를 상속받는 OverridingTest가 
method() 와 method()를 오버라이드 할 때 throws 부분을 
어떻게 처리하는지 보여준다. 

ex)
package ch09.exception;

import java.io.FileNotFoundException;
import java.io.IOException;

class Parent{
	void methodA() throws IOException{}
	void methodB() throws ClassNotFoundException{}
}

public class OverridingTest extends Parent {

	@Override
	void methodA() throws FileNotFoundException {
	}
	/*
	@Override
	void methodB() throws Exception {
	}
	*/
}
// methodA() 오버라이드한다. IOException의 자식 예외인 
FileNotFoundException을 throws 처리가능. 

methodB()를 오버라이드하면서 ClassNotFoundException의 
조상 예외인 Exception을 throws 처리하므로 
제약 사항 위반이 발생한다. 

----------------------------------------------------
4. 사용자 정의 예외

4.1 사용자 정의 예외 작성 

사용자 정의라는 단어가 이책에서 처음 등장. 
사용자 정의라는 것은 기존에 비슷한것이 있는데 
사용자가 원하는 형태로 재정의하는 것을 의미하며 
상속을 통해서 기존 클래스를 확장하는 것이 일반적이다. 

사용자 정의 예외는 API에 정의된 예외 이외에 필요에 따라 
작성한 예외 클래스를 말한다. 
일반적으로 예외의 특성에 따라 Exception 또는  RuntimeException 
클래스를 상속 받아서 작성한다. 

예를들어 로그인 처리하는 기능을 예외처리를 기반으로 고민해보자. 
일반적으로 로그인 메서드는 아이디와 비밀번호를 입력받아서 로그인 기능 여부를 
확인해준다. 이때 리턴타입으로는 어떤형태가 좋을까?

-boolean 
:로그인 성공 여부를 true/false로 잘 나타낼수 있다.
하지만 딱 거기까지다. 추가적인 정보를 전달할수 없다. 
예를들어 로그인이 실패한 원인을 함께 전달하려면 어떻게 해야 할까?
boolean에서는 방법이 없다. 

ex)
public boolean login1(String id, String pass){
return id.equals("hong")&& pass.equals("1234");
}

-String
:문자열에 여러 정보를 포함할수 있다. 
예를들어 '실패: 비밀번호 오류'라는 문자열을 반환하면 
실패 여부와 함께 사유도 알수 있다. 하지만, 이 메시지를 프로그래밍으로 
파악하기 위해서는 문자열을 어떻게 구성할 것인지 사전에 잘 정의된 
약속이 있어야 한다. 
즉, '콜론을 기준으로 앞부분은 성공여부, 뒷부분은 실패 사유를 적는다.'
라고 규칙을 정한 후 이에 맞춰 데이터를 작성해야 한다. 
이런 약속을 프로토콜(protocol)이라고 한다. 
프로토콜을 잘 이해하고 프로그래밍 해야 하며 혹시나 이 프로토콜이 바뀌면
번거로운 상황이 될수있다

ex)
public String login2(String id,String pass){
String msg ="성공";
if(!id.equals("hong")){
msg="실패 : 아이디 확인 필요";
}else if(!pass.equals("1234")){
msg = "실패: 비밀번호 확인 필요";
}
return msg;
}


-사용자 정의 객체 
: 원하는 멤버변수와 메서드를 가진 클래스를 만들고 이 클래스 타입의
객체를 리턴한다. 받는 쪽에서는 객체를 통해 성공/실패에 관한 내용을 쉽게 
파악할수 있다. 따라서 복잡한 내용을 전달하기 위해서는 사용자 정의 
객체가 가장 적절하다. 

ex)
public LoginInfor login3(String id, String pass){
LoginInfo info = new LoginInfo();
if(!id.equals("hong")){
info.setSuccess(false);
info.setMsg("아이디 확인 필요");
}else if(!pass.equals("1234")){
info.setSuccess(false);
info.setMsg("비밀번호 확인 필요");
}
return info;
}

그런데 로그인 메서드가 몇 단계를 거쳐 복잡하게 호출되었다면 어떨까?
중간 과정에서 계속 리턴 값을 다시 전달하는 절차가 있어야 할것이다. 

이제 Exception이 가지는 throws 를 이용한 전파를 사용해보자.
로그인에 실패한 것은 일종의 예외라고 볼수 있다. 
이 예외를 만들어서 throw 시킨다면 throws 메커니즘을 이용해 
메서드를 호출한 곳으로 쉽게 전달할 수 있다. 
게다가 이 예외가 unchecked exception 의 계열이라면 
중간에 throws 하는 절차도 필요 없을 것이다. 

사용자 정의 예외 클래스부터 만들어 보자. 

ex)
package ch09.exception.custom;

public class LoginFailException extends RuntimeException {
	enum ErrorCode{
		INVALID_ID, INVALID_PASS
	}	
	
	private ErrorCode errorCode;

	public LoginFailException(ErrorCode errorCode, String data) {
		super(data);
		this.errorCode = errorCode;
	}

	@Override
	public String getLocalizedMessage() {
		String msg = this.getMessage();
		switch (errorCode) {
		case INVALID_ID:
			msg += ", 아이디를 확인하세요.";
			break;
		case INVALID_PASS:
			msg += ", 비밀번호를 확인하세요.";
			break;
		}
		return msg;
	}
}
//


----------------------------------------------------
4.2 사용자 정의 예외 활용 

예외 클래스가 만들어졌다면 필요한 상황 즉 로그인이 안되는 상황에서 
객체 생성후 throw로 던져버리면 된다. 

ex)
throw new LoginFailException(..., ...);

ex2)
package ch09.exception.custom;

public class UserManagerWithException {
	public boolean login(String id, String pass) {
		if (!id.equals("hong")) {
			throw new LoginFailException(LoginFailException.ErrorCode.INVALID_ID, id);
		} else if (!pass.equals("1234")) {
			throw new LoginFailException(LoginFailException.ErrorCode.INVALID_PASS, pass);
		}
		return true;
	}
	
	public static void main(String[] args) {
		UserManagerWithException userManager = new UserManagerWithException();
		try {
			//boolean result = userManager.login("hong", "1234");
			//boolean result = userManager.login("hong2", "1234");
			boolean result = userManager.login("hong", "5678");
			System.out.printf("로그인 성공 여부: %b%n", result);
		}catch(LoginFailException e) {
			System.out.printf("예외 처리: %s%n",e.getLocalizedMessage());
		}
	}
}
//
로그인 성공 여부: true
//
예외 처리: hong2, 아이디를 확인하세요.
//
예외 처리: 5678, 비밀번호를 확인하세요.

 주석 처리 유무로 확인.
 
LoginFailException이 RuntimeException 계열이므로 
별도의 throws는 필요없다. 

----------------------------------------------------
5. 로깅(logging)과 디버깅(debugging)

5.1 로깅(logging)

사용자의 요처사항을 출력하는 것 이외에 애플리케이션에서 발생하는 
사건들을 기록하는 것을 로깅.
예) 사용자가 1과 2를 입력해서 더하기 결과를 출력하는 애플리케이션
이라면 3이라는 값을 출력하는 것 이외에 1과2라는 파라미터가 제대로 
입력되었는지 확인하는 과정은 로깅이라고 볼수 있다. 

ex)
public void printAddResult(int a , int b){
System.out.printf("파라미터 확인: %d, %d%n", a, b); //로깅 
int result = a+ b;
System.out.println("%d + %d = %d", a, b, result); //정보출력 
}
이제까지 출력을 위해 System.out.println 등 메서드를 통해 콘솔을 이용해 왔다. 
또한 예외 객체의 printStackTrace()와 같은 메서드 역시 콘솔을 통해 메서드 호출 
스택을 출력한다. 하지만 콘솔은 프로그램 사용자와의 인터페이스가 주요 
목적이므로 엄청난 양의 예외 정보가 출력되기에 부적합하다. 
따라서 로깅에는 정보 출력과 구분해서 별도의 전문 로깅 프레임워크 사용을 권장한다. 

java.util.logging 패키지에는 로깅을 위한 클래스들이 제공된다. 
Logger 클래스에는 다양한 레벨로 로깅을 남길 수 있는 메서드가 제공된다. 
로깅의 레벨은 
Level.INFO(정보)->Level.WARNING(경고)->Level.SEVERE(심각)
의 단계로 처리된다. 

java.util.Logging.Logger 의 주요 메서드 

메서드명    :   선언부와 설명 
getLogger() : public static Logger getLogger(String name)
:Logger를 반환하는 static 메서드이다. 일반적으로 클래스 이름을 
파라미터로 전달한다.

log() : public void log(Level level, String msg)
:심각도(level) 에 따라 메시지(msg)를 출력한다. 
level: Level.INFO , Level.WARNING, Level.SEVERE 등 로그의 심각도 설정 
msg: 출력하려는 메시지 

info() : public void info (String msg)
Level.INFO 심각도를 가진 로그를 출력한다
log(Level.INFO , msg)와 동일하다. 

warning() : public void warning(String msg)
Level.WARNING 심각도를 가진 로그를 출력한다.
log(Level.WARNING, msg)와 동일하다. 

severe() : public void severe(String msg)
Level.SEVERE 심각도를 가진 로그를 출력한다. 
log(Level.SEVERE, msg)와 동일하다. 

addHandler() : public void addHandler(Handler handler)
: 로그 메시지를 받을 handler를 추가한다. 

ex)

package ch09.exception.logging;

import java.util.logging.Level;
import java.util.logging.Logger;

public class SimpleLogging {
	private final static Logger logger = Logger.getLogger(SimpleLogging.class.getName());
	public static void main(String[] args) {
		logger.log(Level.INFO, "info log");
		logger.info("method type info log");
		logger.warning("method type warn log");
		logger.severe("method type severe log");
	}
}
//
3월 25, 2019 9:06:29 오전 ch09.exception.logging.SimpleLogging main
INFO: info log
3월 25, 2019 9:06:29 오전 ch09.exception.logging.SimpleLogging main
INFO: method type info log
3월 25, 2019 9:06:29 오전 ch09.exception.logging.SimpleLogging main
WARNING: method type warn log
3월 25, 2019 9:06:29 오전 ch09.exception.logging.SimpleLogging main
SEVERE: method type severe log

실행 결과를 살펴보면 발생 시점과 클래스 및 메서드 이름, 심각도,
메시지 정보가 별 수고 없이 출력됨을 확인가능. 

지금까지 단순한 예제들을 실행해봤기 때문에 출력되는 로그의 양도 
많지 않았다. 하지만, 서버 프로그램 등의 경우 아주 오랫동안 
동작하므로 쏟아지는 로그도 엄청나다. 
콘솔은 자체적인 작은 메모리에 정보를 저장하기 때문에 많은 
로그를 계속 저장할수 없다. 

과거에 발생한 로그를 장기간 저장하기 위해서는 별도의 대상 
(예: 파일)에 출력하는 것이 일반적이다. 
이런경우 Handler를 Logger 에 추가하면 간단히 처리 가능. 
가장 대표적으로 사용되는 Handler는 FileHandler이다. 
FileHandler는 로그 파일 이름의 패턴, 최대 파일의 크기등을 이용해 
생성 가능. 

FileHandler의 생성자 

생성자명   :  선언부와 설명 

FileHandler() : public FileHandler(String pattern , int limit, int count)
throws IOException, SecurityException

FileHandler의 생성자이다. 
pattern : 생성될 로그 파일의 이름패턴 
limit : 생성되는 파일의 최대 크기 (byte)
count : 만들수 있는 파일의 개수로 최소 1

public FileHandler(String pattern) throws IOException, SecurityException
FileHandler의 생성자.
파일의 크기에 제한이 없고 언제나 하나의 파일만 사용된다. 
pattern : 생성될 로그 파일의 이름 패턴 

파일 이름의 패터은 다음의 예약어를 사용할수 있다. 

%t : 시스템 임시 폴더 
%h : 시스템의 user, home 속성 값 
%g : 자동으로 생성되는 일련 번호 
%u : 동일한 파일명이 있을 경우 충돌을 방지하기 위해 생성되는 유일한 값.

ex)

package ch09.exception.logging;

import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SimpleLoggingFile {
	private final static Logger logger = Logger.getLogger(SimpleLoggingFile.class.getName());

	public static void main(String[] args) throws SecurityException, IOException {
		FileHandler fHandler = new FileHandler("mylog_%g.log");
		logger.addHandler(fHandler);
		logger.log(Level.INFO, "info log");
		logger.info("method type info log");
		logger.warning("method type warn log");
		logger.severe("method type severe log");
	}
}

//
콘솔 출력은 이전 예제와 동일 
// workspace에 mylog_0_0.log 파일이 생성되며 
파일의 내용은 콘솔의 로그를 xml 형태로 변경. 

이외에도 logging 패키지에는 다양한 기능을 가지는 클래스들이 
정의되어 있다. 하지만, 실무에서는 아쉽게도 이 클래스들은 
그다지 많이 사용되지 못한다. 
실무에서는 logback 과 같은 별도의 로깅 프레임워크들이 
사용되므로 여기서는 이정도로 마무리.
logback 프레임워크는 부록에서 다룬다. 

----------------------------------------------------
5.2 디버깅(debugging)

프로그램에서 발생하는 로직 상의 오류를 찾아내는 과정을 디버깅이라고 한다. 
기본적으로 프로그램 실행 중간 중간에 앞서 언급했던 로깅 메시지를 
남기거나 예외 발생시 메서드 호출 경로를 분석해서 디버깅하기도 하지만, 
이클립스와 같은 IDE가 제공하는 기능을 이용하면 훨씬 쉽고 편리하게 디버깅 
할수 있다. 

팩토리얼(계승, factorial의 기호로는 '!'을 쓴다. )을 구하는 예제를 만들어보고 
디버깅을 통해 분석해보자. 
5! = 5*4*3*2*1 로 120이다. 

ex)

package ch09.exception.debugging;

public class DifficultLogicTest {
	public DifficultLogicTest() {}
	public long factorial(int num) {
		if(num==1) {
			return 1;
		}else {
			return num * factorial(num-1);
		}
	}
	
	public static void main(String[] args) {
		DifficultLogicTest dlt = new DifficultLogicTest();
		System.out.println(dlt.factorial(5));
	}
}
//120
이런 식으로 함수가 다시 자신을 호출하는 구조를 
재귀함수라고 부른다. 

디버거를 통해서 어떻게 동작하는지 살펴보자.

디버거를 이용할 때에는 맨 먼저 이클립스의 편집 창에서 디버깅을
시작하려는 행 번호 왼쪽의 막대 영역을 더블클릭해서 중단점(break point)
을 설정한다. 

중단점(break point)란 프로그램 동작 중 디버깅을 위해서 
동작을 멈추는 지점이다. 
중단점을 지정해 놓으면 그 전까지 프로그램이 동작하다가 
중단점에 도착하면 사용자의 다음 동작을 기다린다. 
중단점은 필요에 따라 여러개 설정할수 있다. 

14번 행부터 디버깅을 시작해보자. 
더블클릭한 부분에 파란색의 작은 블렛이 표시된다. 
표시된 블렛을 다시 더블클릭하면 중단점 설정이 해제된다. 

디버깅을 위해서는 툴바에서 기존의 실행 버튼 좌측에 있는 벌레 모양의
디버깅 버튼을 클릭. 

처음 디버거를 실행하게 되면 다음과 같은 퍼스펙티브(perspective)변경에 
관한 확인 창이 나온다. 

퍼스펙티브는 이클립스에서 특정 목적의 작업을 위한 뷰들의 모임 또는 
구성 정도로 생각. 위 내용은 디버깅을 위해서 뷰들의 구조를 디버깅에 
유용하게 변경하려고 하는데, 동의하느냐는 내용이다. 
편리하게 해주겠다는데 마다할 필요 없다. 
Remember my decision 에 체크한 후 Yes 를 클릭하면 뷰들의 배치가 변경.

디버그 퍼스펙티브는 다음과 같은 유용한 뷰들로 구성된다. 
-디버그 뷰는 현재 실행준인 스택의 정보가 스레드(thread)별로 표시된다. 
-변수 뷰는 디버깅 과정에서 확인하려는 변수의 값들이 표시된다. 
-소스 뷰를 통해서는 다음 단계에서 실행할 라인이 어딘지 쉽게 파악할수 있다. 

디버거를 이용한 디버깅 과정을 단계별로 알아보자. 

1단계 디버거가 실행되면 처음 만나는 중단점이 설정된 곳에서 실행이 
멈춘다. 위에서 언급한 3가지 뷰에 각각 어떤정보가 표시되는지 살펴보자. 

뷰이름 :  표시내용 
디버그뷰 : main 스레드가 실행하는 main 메서드 14라인에서 멈춰 있음이 표현.
변수 뷰: 이 시점의 로컬변수인 args가 표시 된다. 
소스 뷰 : 14행이 배경색을 통해 강조 된다. 

본격적인 디버깅 진행은 디버그 뷰에 있는 버튼들을 이용한다. 

맨왼쪽 부터 
resume : 중단점에 의해 일시 정지된 프로그램을 다시 실행해서 다음 중단점까지 진행한다. 
suspend : 일시 정지한다. 
terminate : 디버깅을 즉시 종료한다.  
Step Into :한 문장씩 실행한다. 메소드를 만나면 메소드 안으로 진입한다. 
Step Over : 역시 한문씩 실행한다. 하지만 StepInto와 달리 메서드를 만나도 내부로 집입
하지 않는다. 
Step Return : 현재 디버깅 중인 메서드의 리턴 위치로 이동한다. 

2단계 Step Into를 클릭하자. 
이 때 실행되는 다음문장은 
new DifficultLogicTest()이므로 생성자 코드이다. 
따라서 기본 생성자인 4번행으로 실행커서가 이동한다. 

디버그 뷰 : main 스레드의 main 메서드 위에 DifficultLogicTest 생성자(init)가 표시.
변수 뷰: 생성자에서 사용될수 있는 this 변수가 표시된다. 
소스 뷰 : 4행이 배경색을 통해 강조된다. 

3단계 다시 StepInto 를 클릭하면 어떻게 될까?
생성자에서 실행할 다음 행은 생략되었지만, 조상의 생성자를 호출하는 super()이다. 
따라서 Object 클래스의 생성자로 이동한다. 

뷰이름 : 표시 내용 
디버그 뷰 : main 스레드의 생성자(init)위에 Object 의 생성자 (init)가 표시.
변수 뷰 : 생성자에서 사용될수 있는 this 변수가 표시된다. 
소스 뷰: Object 클래스로 이동한다. 

4단계 사실 Object 클래스는 이미 완벽하므로 디버깅 할 필요는 없다.
Step Return을 클릭해서 Object 생성자가 리턴했을 지점인 DifficultLogicTest의
기본 생성자로 이동한다.  다시 디버깅 뷰들의 정보로 2단계로 이동한다. 

5단계 DifficultLogicTest 생성자에서 확인할 내용이 없으므로 Step Over 
를 통해 다음으로 이동한다. 
생성자가 리턴되고 다시 메인 메서드로 이동된다. 디버깅 뷰들의 내용은 
1단계와 같지만 정확한 시점은 4단계에서 생성된 DifficultLogicTest 객체가 
dlt에 할당되는 지점이다. 

디버그 뷰: main 스레드가 실행하는 main() 메서드 14행에서 멈춰 있음이 표현된다. 
변수 뷰 : 이 시점의 로컬 변수인 args가 표시된다. 
소스 뷰 : 14행이 배경색을 통해 강조 된다. 

6단계 Step Over 를 클릭 하면 드디어 14행이 완전히 종료되면서 객체 할당이 끝나고 
다음 실행할 코드는 15행의 println() 메서드의 파라미터인 factorial()메서드 
호출부분이다. 

디버그 뷰: main 스레드가 실행하는 main() 메서드 15행에서 멈춰 있음이 표현된다. 
변수 뷰 : 이 시점의 로컬 변수인 args와 dlt 가 표시된다. 
소스 뷰 : 15행이 배경색을 통해 강조 된다. 

7단계 factorial() 메서드의 동작을 보고 싶기 때문에 Step Into를 선택 한다. 

디버그 뷰: main 스레드의 main() 메서드 위에 factorial 메서드가 표시된다. 
변수 뷰 : 이 시점의 로컬 변수인 this와 num 가 표시된다. (num = 5)
소스 뷰 : 6행이 배경색을 통해 강조 된다. 

8단계 이후 계속해서 Step Into 등을 실행하면서 factorial 메서드의 동작을 
세밀하게 들여다 볼수 있다. 디버깅을 중지하고 싶다면 
terminate를 클릭 한다. 

디버깅 작업을 다 마친 후 원래의 자바 편집 퍼스펙티브로 돌아가려면 
메뉴에서 
Window -> Perspective -> Open Perspective -> Java 를 선택한다. 

오른쪽 상단의 Perspective 바로가기 버튼 그룹을 사용할수도 있다. 


===================================
[자바 해바라기 정리] 10 내부 클래스와 람다식 

1. 내부 클래스

1.1 내부 클래스의 필요성 

객체지향 프로그램의 출발점은 추상화를 거처 현실 세계의 객체를
분석하고 클래스로 만드는 일이다. 
분석 과정에서 관리해야 할 요소들의 성격에 따라 여러 개의 클래스가
도출 될수 있다. 
예) 스마트폰 시스템을 프로그래밍 한다고 생각 해보자.
스마트폰, 전화기능, 배터리,GPS, 와이파이, 과금정보,
대리점, 설치된 앱, OS 등 다양한 요소를 떠올릴수 있다. 
이 중 스마트폰 중심으로만 생각해보자. 
스마트폰은 번호, 통신사, 금액 같은 전화기 고유 정보뿐 
아니라 배터리, 와이파이, GPS 등 다양한 정보로 구성된다. 

이런 속성들을 모두  SmartPhone 클래스 안에 담는 경우 
한 클래스 내부이므로 서로 접근 제한자에 관계없이 편하게
사용가능. 하지만, 모듈화가 되지 않기 때문에 
클래스의 복잡도가 올라가고 유지 보수에도 좋지 않다. 

따라서, Battery, WiFiModule, GpsModule 형태로 여러 
클래스로 분리해서 모듈화하고, 
SmartPhone 클래스에서 이들 클래스를 has-a 관계,
즉 멤버 변수로 관리한다. 

대략 구현하면 다음과 같다. 

ex)
public class SmartPhone {
private Battery battery = new Battery();
private GpsModule gps = new GpsModule(battery);
private WiFiModule wifi = new WiFiModule();
}//SmartPhone 클래스 영역 

class Battery {...}
class GpsModule {...}
class WiFiModule {...}

이제 GpsModule을 설계해보자. 
GpsModule은 동작하면서 배터리를 소모시키는데 
배터리의 잔량이 줄어드는 것을 표현해야 한다. 
같은 클래스에 있다면 상관없겠지만, 클래스가 달라졌기
때문에 Battery에 접근 하기 위해 Battery의 레퍼런스가 필요.
따라서, GpsModule은 다음처럼 구현해볼수 있다. 

ex2)
class GpsModule {
Battery battery;
public GpsModule(Battery battery) {
this.battery = battery;
}
public void useBattery () {
battery.useBattery(5); // 쓸 때마다 Battery의 잔량이 5만큼 줄어든다. 
}
}

결과적으로 Battery를 사용하기 위해서 상당히 복잡한 구조의 
클래스가 완성 되었다.

추가로 한가지 상황을 더 고민한다면, SmartPhone 시스템에서 
GpsModule의 용도이다. 
과연 다른 곳(예, 과금정보, 대리점등)에서 GpsModule을 사용할 일이 
있을까? 아마 SmartPhone을 제외한 클래스에서는 그다지 소용이 없을듯.

이처럼 모듈화를 위해서 분리하기는 하지만, 
has-a  관계에 있는 클래스 내부에서만 사용되는 클래스를 만들 때는 
내부 클래스(inner class)를 활용하는 것을 고려할 만하다.

내부 클래스(inner class) 는 다른 클래스 내부에 작성되는 클래스다.
내부 클래스를 작성하게 되면 내부 클래스에서는 외부 클래스의 멤버에 
접근 제한자와 무관하게 접근 할수 있고 다른 곳에서는 사용되지 않는 
클래스를 내부에 감춤으로써 프로그램의 복잡도를 감소시킬수 있다.
내부 클래스는 다른 말로 중첩 클래스(nested class)라고도 한다. 

이제 WiFiModule을 내부 클래스로 작성 해보자.

ex3)
public class SmartPhone {
private Battery battery = new Battery();
private GpsModule gps = new GpsModule(battery);
private WiFiModule wifi = new WiFiModule();

//내부클래스
class WiFiModule {
public void useBattery() {
battery.useBattery(3);
}
}
} // SmartPhone 클래스 영역 , 외부클래스

class GpsModule {...} //외부클래스

WiFiModule은 분명 별도의 class 키워드가 사용된 클래스이지만 
SmartPhone의 내부에 선언되어 있다. 더군다나 SmartPhone의 
private 멤버변수 battery를 마치 자신의 멤버변수 처럼 사용하고 있다. 

내부클래스는 클래스 내부에 다른 클래스를 정의하는 것이지 
하나의 파일에 두 개의 클래스를 정의하는 것이 아니다. 
즉, 위의 가상 코드가 하나의 SmartPhone.java 파일에 
선언된 경우 GpsModule이나 SmartPhone은 모두 외부 클래스들이다. 
WiFiModule처럼 외부클래스 내부에 선언된 클래스를 내부클래스라고 한다. 

내부클래스는 선언되는 위치와 형태에 따라 다음과 같은 4가지로 
구분된다. 

내부클래스의 종류 

선언위치 : 종류 : 특징 

멤버영역 : 인스턴스 내부클래스 : static이 없는 내부클래스
외부클래스의 멤버변수처럼 사용됨 
주로 외부클래스의 인스턴스 멤버들과 관련된 작업 수행.

멤버영역 : 클래스 내부클래스 : static이 붙은 내부 클래스 
주로 외부 클래스의 static 멤버들과 관련된 작업 수행 

로컬영역 : 로컬 내부클래스 : 외부클래스의 메서드나 초기화블록,
생성자등에서 선언됨.
선언된 영역 내부에서만 사용가능 

로컬영역 : 익명의 내부클래스 : 이름이 없으며 클래스 선언과 
객체 생성을 동시에 처리하는 형태 주로 객체를 재사용하지 않고 
한 번만 사용할때.

4가지 형태의 내부클래스의 특징을 보자. 

----------------------------------------------------
1.2 인스턴스 내부 클래스 

작성시 주의사항.

(1) 인스턴스 내부클래스는 외부클래스의 멤버변수 선언 위치에 
static 키워드 없이 선언된 클래스를 말함. 

(2) 내부클래스에서 외부 클래스의 멤버에 접근할 때 private 를 
포함한 모든 멤버에 대해 자유롭게 참조할 수 있다.

(3) 인스턴스 내부 클래스는 static 멤버를 가질수 없다. 
단, static final 멤버는 상수로 취급되므로 예외로 사용가능

만들어진 인스턴스 내부클래스도 당연히 객체화 해야 사용가능.
객체를 생성할 때는 static 메서드 영역과 인스턴스 메서드 영역에서의 
방법이 다른데 이는 기본적으로 인스턴스 멤버와 static 멤버의 
사용법과 매우 유사하다. 

(1) static 영역에서 인스턴스 내부클래스의 객체를 만들때는 먼저 
외부클래스의 객체를 만들고 이를 통해서 내부클래스의 객체를 생성한다. 

(2) static이 아닌 영역에서 객체를 만들때는 바로 객체의 생성이 가능하다. 

ex)
package ch10.nested;

public class InstanceInnerTest {
   class Inner {
      int innerMember = 10;
      //static int staticMember = 10;
      static final int finalStaticMember = 20;
   
// 인스턴스 내부 클래스에 일반 멤버를 선언할 수 있지만, 
// static 멤버는 선언할수 없다. 단, static final 형태는 가능. 
   
   // 내부클래스에서 외부클래스의 private 멤버변수인 outerMember를 마치 
   // 자신의 멤버 변수인 것처럼 사용할 수 있다. 
   
      private void innerMethod() { 
         System.out.println("om : " + outerMember+ ", im : " + innerMember);
         sOuterMember = 0;
      }
   }
   
   private int outerMember = 1;
   private static int sOuterMember = 0;
   
   // 인스턴스 메서드 영역에서 객체 생성 
   // static 이 아닌 인스턴스 메서드 에서 내부클래스의 객체를 생성한다.
   // 내부클래스 객체 생성 후 그 멤버에 접근하는 것은 일반클래스와 다른 
   // 점이 없다. 
   private void outerMethod() {
      Inner inner = new Inner();
      inner.innerMember = 100;
      inner.innerMethod();
   }

   // 클래스 메서드 영역에서 객체 생성 
   // static 영역에서 인스턴스 내부클래스의 객체를 생성하기 위해서 
   // 먼저 외부클래스의 객체를 생성 후 그 참조 값을 이용해서 내부클래스
   // 객체를 생성할수 있다. 
   public static void main(String[] args) {
      InstanceInnerTest iit = new InstanceInnerTest();
      Inner inner = iit.new Inner(); // 생성자를 호출하는 코드.
      inner.innerMethod();           // 외부 객체의 레퍼런스를 통해야 한다. 
   }
}
//
om : 1, im : 10

내부클래스를 사용하다 보면 가끔 내부클래스의 멤버와 외부클래스의 
멤버간의 이름 충돌로 인해 정확히 소속을 밝혀야 할 경우가 있다.
내부클래스에서 내부클래스의 멤버를 참조할때 this를 쓴다면 
외부클래스의 멤버를 참조할때는 외부클래스.this를 사용한다. 

ex2)
package ch10.nested;

public class DuplicatedNameTest {
   private int num = 100;
   
   class InnerClass{
      private int num = 200;// 이름 충돌
      
      public void method() {
         System.out.println(num);
         System.out.println(this.num);
         System.out.println(DuplicatedNameTest.this.num);
      }
   }
   
   public static void main(String[] args) {
      DuplicatedNameTest dnt = new DuplicatedNameTest();
      InnerClass ic = dnt.new InnerClass();
      ic.method();
   }
}
//
200
200
100

내부클래스는 컴파일 결과물도 일반클래스와 약간다르다.
위 코드의 실행 결과로 생성되는 클래스는 
InstanceInnerTest와 함께 
InstanceInnerTest$Inner 이다. 
즉, 내부클래스는 외부클래스$내부클래스의 이름으로 
.class가 생성된다. 

전혀 별개의 클래스에서 인스턴스 내부 클래스를 생성할 때는 
마치 멤버 변수에 대한 접근과 동일하게 
먼저 외부클래스의 레퍼런스를 확보하고, 이 레퍼런스를 
통해서 내부클래스를 생성해야 한다. 

하나 주의사항은 내부클래스에 대한 패키지 정보가 필요하다.

다음 형태는 Inner 클래스를 import 한 후 
instanceInnerTest()에서 내부클래스인 Inner의 객체를 생성한다. 
InstanceInnerTest 와 OtherClass는 같은 패키지임에도 불구하고 
import 문이 필요하다. 

ex)
import ch10.nested.InstanceInnerTest.Inner;

public class OtherClass {
public void instanceInnerTest() {
// 외부클래스의 객체를 먼저 생성 후 내부클래스 객체 생성 
InstanceInnerTest iit = new InstanceInnerTest();
Inner inner = iit.new Inner();
}
}

다음은 별도의 import 없이 외부클래스를 포함한 전체 이름을 
사용한다. 

ex2)
public class OtherClass {
public void instanceInnerTest() {
InstanceInnerTest iit = new InstanceInnerTest();

//이 부분 외부클래스를 포함한 전체이름 사용.
InstanceInnerTest.Inner inner2 = iit.new Inner();
}
}
// 외부클래스의 객체를 먼저 생성 후 내부클래스 객체 생성 

----------------------------------------------------
1.3 클래스 내부 클래스 

특징 
(1) 클래스 내부클래스는 static 키워드가 붙은 내부클래스이다.
(일반클래스는 클래스를 선언할때 static 키워드를 사용할수 없다.)
따라서 외부 클래스의 객체 생성과 무관하게 사용될수 있다.

(2) 내부클래스에서 외부클래스의 멤버에 접근할때 private를
포함한 모든 멤버에 대해 자유롭게 참조할수 있다. 
물론, 외부 클래스의 참조 값이 있을 때만 사용할수 있다. 
외부클래스는 static이 아니기 때문이다. 

(3)인스턴스 내부클래스와 달리 static 멤버를 가질수 있다. 

객체를 생성할때의 특징도 static 키워드의 특징을 떠올리면 
쉽게 이해할수 있다. static 키워드는 특정한 객체외는 무관하게
동작한다. 따라서 클래스 내부클래스를 생성하기 위해 외부클래스의 
참조값은 필요없다. 단지 클래스가 어디에 있는지만 표시 
해주면 된다. 

ex) 
package ch10.nested;

public class StaticInnerTest {
//class 선언부에 static 키워드가 사용된 클래스 내부클래스
   static class StaticInner {
      private int iMember = 10;
      
      //일반 멤버 변수는 물론 static 키워드가 추가된 멤버도 가질수있다.
      private static int sMember = 0;
      
      private void innerMethod() {
   
//외부클래스의 멤버를 사용할 때는 먼저 외부클래스 객체를
//만들고 그 객체를 통해서 접근한다. 이때 접근 제한자는 무관함.
         StaticInnerTest sit = new StaticInnerTest();
         System.out.println("om: "+sit.oMember+", im: "+iMember);
      }
   }

   private int oMember = 1;

   private void outerMethod() {
   
   //non-static 영역에서의 객체 생성
      StaticInner inner = new StaticInner();
      inner.iMember = 100;
      inner.innerMethod();
   }

   //외부클래스에서 클래스 내부클래스의 객체를 만들때는 외부클래스의
   //참조값 없이 바로 객체 생성이 가능하다.
   public static void main(String[] args) {
   //static 영역에서의 객체 생성 
      StaticInner inner = new StaticInner();
      inner.innerMethod();
   }
}
//
om: 1, im: 10

별개의 클래스에서 클래스 내부클래스의 객체를 생성할때도 외부클래스에 
대한 레퍼런스 없이 바로 생성할수 있다. 단, 외부클래스 이름을 
패키지로 간주한다는 점은 인스턴스 내부클래스와 동일하다. 

ex)
import ch10.nested.StaticInnerTest.StaticInner;

public class OtherClass {
public void staticInnerTest() {
StaticInner sinner = new StaticInner();
}
}

----------------------------------------------------
1.4 로컬 내부 클래스 

특징 
(1) 클래스 영역이 아닌 메서드나 생성자 또는 초기화 
블록의 내부에 선언된 클래스.

(2) static 변수는 가질수 없지만, final static 변수는 가질수 있다.

(3) 내부클래스에서 외부클래스의 멤버에 접근하는 것은 
전혀 제약이 없고 호출할때 외부의 객체에 대한 참조도 필요없다. 

(4) 내부클래스가 선언된 로컬영역의 변수에 접근할때 주의사항
a. 자바7까지는 final로 선언된 변수만 사용 가능하다. 
b. 자바8부터는 final 이외의 변수도 사용가능하다. 
단, final로 간주되므로 새로운 값을 할당할수는 없다. 

마지막 조건이 조금 복잡한데 메모리에서의 라이프사이클
(life cycle)이 다르기 때문이다. 
다음 코드는 method() 내부에 LocalInner 클래스가 선언된 
로컬 내부클래스 형태이다. 
LocalInner 내부의 innerMethod() 메서드에서는 외부메서드인 
method()의 로컬변수 localVar이 사용되고 있다. 

ex)
public void method() {
int localVar = 10;
class LocalInner {
void innerMethod() {
System.out.println(localVar);
}
}
LocalInner inner = new LocalInner();
}

이때 메모리 호출 스택은 다음과 같다. 

스택 
method
inner 0x100 ---> 힙 0x100 : LocalInner
localVar  10 -----힙 localVar 사용중. //언젠가 G.C 될때까지 존재 
//메서드 종료시 즉시 삭제 

그런데 만약 여기서 method()가 종료되면 어떤 일이 발생할까?
메서드 호출 스택은 메서드 종료 즉시 메모리에서 삭제된다. 
여기에는 localVar도 포함되어 있다. 
하지만, 이 변수는 힙에 구성된 객체의 메서드에서 사용되고 
있고 언젠가 G.C가 동작해서 inner가 없어질 때까지는 있어야 한다. 
즉 메모리에 훨씬 더 오래 남아 있을수도있다. 
이런 이유로 자바 7까지는 바로 사라지는 로컬변수를 로컬 내부클래스에서 
사용할수 없었다. 

final이 붙은 변수는 일반 로컬변수와 달리 상수풀(constant pool)에
계속 보관되기 때문에 메서드가 종료되더라도 inner 객체에서 
계속 참조가 가능하다. 
자바 8버전 이후에는 final이 없는 로컬변수도 사용할수 있지만, 
값을 변경할수는 없다. 
내부적으로 컴파일러가 final 키워드를 변수에 추가하는 형태로 
동작하기 때문이다. 

로컬 내부클래스의 객체를 만들기 위해서는 로컬 내부클래스가 
선언된 메서드 등을 호출하고 그 내부에서 객체가 생성된다. 
별개의 클래스에서는 메서드 내부를 볼수없기 때문에 당연히 
로컬 내부클래스 객체 생성이 불가능하다. 

ex)

package ch10.nested;

public class LocalInnerTest {
   int iMember = 1;
   static int cMember = 2;
   
   void method(){
      int localVar = 3;
      
      class LocalInner{
         int innerLocalVar = 4;
         void innerMethod(){
            System.out.println("외부 인스턴스 멤버 변수: "+iMember);
            System.out.println("외부 클래스 멤버 변수: "+cMember);
            System.out.println("외부 로컬 변수: "+localVar);   // JDK 8 이후 가능
            System.out.println("내부 인스턴스 멤버 변수: "+innerLocalVar);
            
            iMember++;
            cMember++;
            //localVar++;               // 여전히 편집은 불가능
            innerLocalVar ++;
         }
      }
      // 내부에서만 객체 생성 가능 
      LocalInner lInner = new LocalInner();
      lInner.innerMethod();
   }
   
   public static void main(String[] args) {
      LocalInnerTest lit = new LocalInnerTest();
      lit.method();
   }
}
//
외부 인스턴스 멤버 변수: 1
외부 클래스 멤버 변수: 2
외부 로컬 변수: 3
내부 인스턴스 멤버 변수: 4

위 코드를 컴파일하면 LocalInnerTest와 LocalInnerTest$1LocalInner 
인 두개의 클래스 파일이 생성된다. 
LocalInnerTest 내부에 여러개의 로컬 내부클래스가 같은 이름으로 
선언될 수 있으므로 숫자가 내부클래스 앞에 접두사로 추가되는 것.


----------------------------------------------------
1.5 익명의 내부 클래스

로컬 내부 클래스의 한 종류로 기본 특성은 동일하다. 
차이점, 부를수 있는 이름이 없다는 점이다. 
이름이 없기 때문에 다른 곳에서 이 클래스를 이용해 
새로운 객체를 만들수 없고 선언과 동시에 바로 클래스를 
구성하고 객체를 생성한다.
따라서 주로 일회용으로 더이상 재사용하지 않는 경우 
적합하다. 익명의 내부클래스는 abstract 클래스나 
인터페이스 구현에 많이 사용된다. 

익명의 내부클래스를 사용하는 예 
SomeSpeaker 와 이 인터페이스를 파라미터로 받는 
useSpeaker()로 구성된 클래스가 구성되어 있다. 

ex)
interface SomeSpeaker {
void sayHello();
}

public class AnonymousInnerTest {
public void useSpeaker(SomeSpeaker speaker) {
speaker.sayHello();
}
}

useSpeaker()에 SomeSpeaker를 구현한 클래스를 만들고 
객체를 넣는 다양한 방법이 떠오를수 있다.
그런데 전제조건으로 이 객체의 sayHello() 메서드가 사용되는 곳에서 
매번 다르게 동작한다고 생각해보자. 즉, 한번만 사용하고 
버리는 상황이다. 

AnonymousInnerTest 내에서만 특색 있게 한번만 사용될 것이므로 
외부에 별도의 클래스를 만들기에는 번거롭다. 
AnonymousInnerTest 내에서 조차 메서드별로 다른 인스턴스 내부클래스나 
클래스 내부클래스를 만드는 것도 재사용할 일이 없으므로 번거롭다. 

마지막으로 로컬 내부클래스 형태로 만들어보자. 

ex)
public void useSpeakerTest() {

//로컬 내부클래스
class KorSpeaker implements SomeSpeaker {
@Override
public void sayHello() {
System.out.println("안녕");
}
}
useSpeaker(new KorSpeaker());<------ 로컬 내부클래스

//로컬 내부클래스
class EngSpeaker implements SomeSpeaker {
@Override
public void sayHello() {
System.out.println("Hello");
}
}
useSpeaker(new EngSpeaker()); <------ 로컬 내부클래스
}

로컬 내부클래스에 따라 한국어와 영어로 메시지가 출력된다. 
여기서 아쉬운 점은 한번 파라미터로 넣어서 사용하기에 
코드가 과하다는 점. 여기서 핵심은 SomeSpeaker를 
구현한 객체를 넣는 것이고, 이 객체는 sayHello()를 
재정의 해야하는 것이다. 즉, 
KorSpeaker나 EngSpeaker와 같은 이름은 사실 중요치 않다. 
어차피 다시 불려서 객체로 만들 가능성은 없기 때문이다. 
이 코드를 익명의 내부클래스로 변경해보자. 
익명의 내부클래스를 만드는 방법은 간단한데 좀 어색하다. 
다음 코드를 살펴보자.

ex)
useSpeaker(

//익명의 내부클래스
new SomeSpeaker() { //new [XXClass_name implements] SomeSpeaker
@Override
public void sayHello() {
System.out.println("안녕");
}
}
);

useSpeaker()의 파라미터로 new 키워드와 함께 생성자가
호출되었나 싶지만, 사실 SomeSpeaker는 인터페이스이기 때문에 
생성자가 아니다. 어찌보면 

new [XXClass_name implements] SomeSpeaker 처럼 
사이에 클래스 이름이 생략된 형태이다. 

그래서 익명의 내부클래스이다. 인터페이스를 바로 객체로 
만들지 못하는 이유는 abstract 상태의 메서드가 있기때문이다. 
익명의 내부클래스는 객체를 생성하면서 바로 abstract 메서드를 
재정의해서 이 문제를 해결한다. 이 클래스는 이름이 없기 때문에 
다른 곳에서 부를수도, 재활용할 수도 없이 딱 일회용이다. 

참고,
익명의 내부클래스를 한줄 한줄 작성하기는 중괄호가 매우 복잡해 보임.
이클립스의 자동완성 기능을 이용하면 쉽게 익명의 내부클래스를 
작성할 수 있다. 익명의 내부클래스를 작성할 메서드의 파라미터 영역
내에서 new 키워드 후 삽입할 클래스의 상위 인터페이스 이름을 
작성 후 ctrl+space 를 입력하면 삽입할 내부 클래스가 
팝업되는데 이 클래스를 선택하면 기본코드가 제공된다. 
여기서 필요한 메서드만 재정의하면 어렵지 않게 작성이 가능하다. 
!

기본적인 익명의 내부클래스 사용방법 예제 

ex)
package ch10.nested;

interface SomeInterface {
   void printInfo();
}

public class AnonymousInnerTest {
   int iMember = 1;
   static int cMember = 2;

   void method(SomeInterface si) {
      si.printInfo();
   }

   public static void main(String[] args) {
      AnonymousInnerTest lit = new AnonymousInnerTest();
      int localVar = 3;
      lit.method(new SomeInterface() {
         @Override
         public void printInfo() {
            //System.out.println("외부 인스턴스 멤버 변수: " + iMember);
            System.out.println("외부 클래스 멤버 변수: " + cMember);
            System.out.println("외부 로컬 변수: " + localVar); // JDK 8 이후 가능

            cMember++;
            //localVar++; // 여전히 편집은 불가능
         }
      });
   }
}
//
외부 클래스 멤버 변수: 2
외부 로컬 변수: 3

method()를 호출하면서 SomeInterface 타입 객체를 익명의 
내부클래스 형태로 넘겨준다. 클래스 내부에서는 추상 메서드인 
printInfo()를 구현한다. 
printInfo()는 static인 main() 내부에 있기 때문에 21행처럼 
인스턴스 멤버를 바로 사용할수는 없다. 
22행처럼 클래스 멤버나 23행처럼 로컬변수를 참조하는 것은 가능하다.
하지만, 26행처럼 로컬 변수를 수정할수는 없고 읽기 전용으로만 
사용가능. 

위의 예를 컴파일한 결과로 AnonymousInnerTest와 AnonymousInnerTest$1
이라는 두개의 클래스가 생성된다. 즉 익명의 내부클래스는 정확한 
이름도 없다. 

이제까지의 내용을 바탕으로 클래스를 만들고 참조 값을 전달하는 
다양한 방식에 대해 하나의 예를 통해 알아보자. 

ex)
package ch10.nested;

interface InfoPrintable {
   public void printInfo();
}

public class VariousInnerClassTest {
   public void useInnerClass(InfoPrintable inner) {
      inner.printInfo();
   }

   public void useSpeakerTest() {
      useInnerClass(new InfoPrintable() {
         @Override
         public void printInfo() {
            System.out.println("익명의 내부 클래스");
         }
      });
      class EngSpeaker implements InfoPrintable {
         @Override
         public void printInfo() {
            System.out.println("로컬 내부 클래스");
         }
      }
      useInnerClass(new EngSpeaker());
      useInnerClass(new InstanceInnerClass());
   }

   class InstanceInnerClass implements InfoPrintable {

      @Override
      public void printInfo() {
         System.out.println("인스턴스 내부 클래스 이용");
      }
   }
}

class SomeClass implements InfoPrintable {

   @Override
   public void printInfo() {
      System.out.println("같은 파일에 있을 뿐 일반 클래스");
   }
}
//
외부 클래스 멤버 변수: 2
외부 로컬 변수: 3

전반적으로 별개의 클래스 -> 인스턴스(클래스) 내부클래스->
로컬 내부클래스 -> 익명의 내부클래스로 갈수록 복잡도가 
줄어드는 것 알수 있다. 
하지만, 그만큼 재활용성은 떨어진다. 
원하는 목적에 따라 적절한 방식의 선택이 중요한 이유이다. 


----------------------------------------------------
2. 람다식

2.1 람다식이란?

람다식(Lambda Expression : λ)은 자바 8에 추가된 가장 큰 특징의 
하나로 자바에서 함수형 프로그래밍 형태를 받아들인 결과이다. 
먼저, 함수형 프로그래밍에 대해 알아보자. 

1990년대부터 가장 대중적인 프로그래밍의 형태로 인기를 끌고 있는 
객체지향 프로그래밍과 함께 최근에 주목받고 있는 프로그래밍 방식은 
함수형 프로그래밍이다. 
사실 함수형 프로그래밍은 1950년대부터 있었으므로 객체지향보다 
역사가 오래되었다. 
함수형 프로그래밍 자체를 설명하기는 이 책의 범위에 한계이므로,
여기서는 '기능 위주의 프로그래밍 기법' 이라고만 정의하자.
객체지향 프로그래밍은 클래스 속성과 기능을 정의한다. 
즉, 기능은 객체에 포함된 개념이다. 하지만,
함수형 프로그래밍에서 기능, 즉 함수가 따로 존재한다. 

참고.
메서드 vs 함수?
객체지향 개념을 설명하면서 객체가 가지는 기능을 메서드 또는 
함수(function)이라고 지칭했다.
맞는 말인데 함수형 프로그래밍을 설명하다 보면 미묘한 차이가 
발생한다. 이제부터 나오는 설명에서 메서드는 특정 객체가 
수행하는 기능, 함수는 특정 객체에 속하지 않는 기능으로 
구별하자. 

예) 배열의 정렬이라는 주제에 관해 이야기해보자.
Arrays 클래스가 제공하는 sort() 메서드를 이용하면 
배열의 요소를 정렬할 수 있다.

String [] strs = {"this", "is", "java", "world"};
System.out.println(Arrays.toString(strs)); 
// 정렬 전: [this, is, java, world]
Arrays.sort(strs);
System.out.println(Arrays.toString(strs));
// 정렬 후 : [ is, java, this, world]

이 코드를 실행하면 알파벳 오름차순으로 정렬된  결과를 
볼수있다. Arrays 의 sort(String[]) 메서드는 문자열을 
비교할때 다음과 같은 Comparator의 compare() 메서드를 
사용한다. 정렬에 관한 내용이 생각나지 않는다면 5장 으로.

public int compare(String o1 , String o2) {
return o1.compareTo(o2);
}

compare() 내부에서는 String의 compareTo()를 이용하는데 
두 문자열을 알파벳 순으로 비교해서 o1이 크면 
(사전순으로 뒤에 나오면) 양수, 작으면 음수, 같으면 0을
리턴한다. 그래서 compare()의 결과 양수가 반환되면 
두 문자열은 자리를 바꾼다. 

그런데 원하는 정렬의 기준을 알파벳 내림차순 또는 글자수를
기준으로 오름차순등 기존에 제공하지 않는 방식으로 
처리하려면 어떻게 해야 할까?
실제로 윈도우 탐색기를 보면 다양한 형태의 정렬 기준을 
사용가능. 

sort()가 가지는 기본 정렬 방식을 사용하지 않으려면 
새로운 정렬 방식을 적용해 주어야한다. 

이를 위해 필요한 새로운 기능을 만들고 Arrays.sort()에
전달하면 되는데 자바에서는 기능, 즉 함수만을 전달할수는없다.
자바에서 전달 할수있는것은 오로지 객체이다. 
그래서, 기능을 가지는 클래스를 만들고 그 클래스의 객체를
전달한다. 많은 경우 이런 정렬방식은 해당 클래스에서만 
유요한 경우가 많다. 

이제 머리에 떠오르는 것은 내부클래스 일것이다 .
특히, 일회용의 정렬 기능 작성을 위해서는 익명의 내부클래스
만한 것이 없다. 다음은 익명의 내부클래스를 이용해 내림차순
정렬을 위한 Comparator를 작성하고 전달하는 코드이다. 

ex)
Arrays.sort(strs, new Comparator<String>() {
@Override
public int compare(String o1, String o2) {
return o1.compareTo(o2)* -1;
}
}); // -1 을 곱해서 내림차순으로 정렬한다
System.out.println(Arrays.toString(strs));
//내림차순 정렬후 :[world, this, java, is]

위 코드는 잘 동작함. 여기서 주목할 내용은 정렬을 위해 
필요했던 '기능은 Comparator가 아니라 사실 compare()라는 
점에 주목할 필요가 있다. compare()만 있으면 되지만, 
자바 언어의 한계 또는 특성으로 인해 익명의 내부클래스를 
만들고 객체화해서 전달하고 있다. 

자바8 부터 등장한 람다식은 이런 번거로움을 없애준다. 
위 코드를 람다식으로 표현하면 다음과 같다. 

ex)
Arrays.sort(strs, (o1,o2) -> { return o1.compareTo(o2) * -1;});
System.out.println(Arrays.toString(strs));
//정렬 후 :[world, this, java, is]

한눈에 보아도 분명 코드가 간결해진 것을 알수있다. 
람다식은 객체가 필요한 자리에 단순히 코드 블록만을 전달한다. 
이 람다식이 바로 함수라고 볼수있다. 
람다식은 런타임에 익명의 내부클래스로 변경돼서 처리되므로 
동작은 동일하다. 

(1) 함수형 인터페이스(functional interface) 
또는 타겟 타입(target type) 
람다식은 단순히 파라미터와 메서드의 구현부로 구성된다. 
즉 기능에만 초첨을 맞춰서 작성한다. 
그리고 이 표현식은 앞서 이야기했듯이 익명의 내부클래스로 
변환되어 참조값 형태로 전달된다. 
위의 코드를 약간 풀어서 써보면 다음과 같다. 

ex)
Comparator<String> strComp = (o1, o2) -> {
return o1.compareTo(o2)* -1; // 람다식의 리턴 타입은 함수형 인터페이스
};
Arrays.sort(strs, strComp);
System.out.println(Arrays.toString(strs));

이처럼 람다식은 결과적으로 인터페이스 타입의 클래스를 
손쉽게 구현하는 방법이다. 이런 인터페이스를 함수형 
인터페이스 또는 타겟 타입이라고 한다. 

함수형 인터페이스에는 반드시 하나의 abstract 메서드만 
존재 해야한다. 만약, abstract 메서드가 없거나 두개이상 
존재한다면 람다식으로 대체할수없다. 

함수형 인터페이스에는 일반적으로 @FunctionalInterface
애노테이션이 선언된다. 이 애노테이션은 필수요소는 
아니지만 컴파일러에게 '이 인터페이스는 람다식에서 사용할 
함수형 인터페이스이므로 abstract 메서드가 하나만 있는지를 
검사하라'고 요청한다. 
따라서 하나 이상의 abstract 메서드를 작성하면 오류가 발생. 
즉 안정적인 프로그래밍을 위한 옵션이다. 
다음은 위에서 살펴봤던 Comparator 인터페이스의 소스 일부이다. 

ex)
@FunctionalInterface
public interface Comparator<T> {
int compare( T o1, T o2);
...
}

한가지 신기한 점은 람다식을 사용할때 어떤 타입도 선언된 적이 
없는데 알아서 잘 적용이 된다는 점이다. 컴파일러는 메서드에 
선언된 타입을 보고 필요한 메서드 선언부가 작성된 람다식을 보면 
해당 타입의 익명 내부클래스로 변경해서 할당한다. 

람다식과 타입 추정 

함수형 인터페이스 타입 
Arrays.sort(strs, [Comparator 필요]);

① 
@FunctionalInterface
public interface Comparator<T> {
int compare(T o1, T o2);
...
}

② T 타입 변수 2개를 받아서 int 를 반환하는 메서드가 
하나 있군. 

(o1, o2) -> {return o1.compareTo(o2)*-1;}

③
Comparator 타입으로 인정. 

----------------------------------------------------
2.2 다양한 형태의 람다식 

람다식은 파라미터 및 리턴타입에 따라 다양한 형태로 작성된다. 
람다식은 축약형이 많은데 이때 형태가 기존의 코드와 사뭇 다르기 
때문에 작성법을 많이 연습해야 손에 익는다. 

(1) 기본 람다식 
람다식은 소괄호로 묶인 파라미터 그룹과 람다 연산자(->),
중괄호로 묶인 실행문으로 구성된다. 

ex)
(type variable_name [,...]) -> {실행문;}
   파라미터        람다연산자  메서드구현 
   
이 표현식의 의미는 '선언된 파라미터들을 이용해서 실행문을 
실행하라!' 정도이다.
파라미터 부분은 실행문 블록에서 사용하기 위한 값을 제공하는
일반적인 메서드의 파라미터 선언과 동일하다. 

ex2)
(String msg) -> {System.out.println(msg);}
이때 파라미터 선언부의 파라미터 타입은 런타임시 대입되는 값에 
따라 자동 인식되므로 일반적으로 생략한다. 

ex3)
(msg) -> {System.out.println(msg); }

파라미터가 하나일 경우 소괄호를 생략가능.
실행문장이 한문장일 경우 중괄호 역시 생략가능.
이때, 실행문의 마지막을 의미하는 ';' 역시 생략가능.

ex4)
msg -> System.out.println(msg)

하지만, 파라미터가 하나도 없는 경우는 소괄호를 생략할수 없다.

ex5)
() -> System.out.println("Hello")

리턴이 필요한 경우 일반적인 함수의 구현처럼 return 키워드를
이용해서 리턴한다. 

ex6)
(msg) -> {
System.out.println(msg);
return msg;
}

실행문이 단순히 리턴문 하나로만 구성되는 경우 중괄호와
함께 return 키워드도 생략 할수 있다. 
하지만 중괄호를 생략하고 return 문을 사용할수는 없다. 

(msg) -> "Hello" + msg 
// msg -> return "Hello" + msg // 오류 

실제로 함수형 인터페이스를 작성하고 다양한 형태의 
람다식의 사용 예를 살펴보자. 

(2) 파라미터와 리터 타입이 없는 경우의 예 

리턴타입과 파라미터가 없는 메서드를 갖는 함수형 인터페이스를 
만들고 람다식을 이용해서 사용해봦.

ex)
package ch10.lambda;

@FunctionalInterface
interface FunctionalInterface1 {
   void methodA();
   // void methodB();//Invalid '@FunctionalInterface' annotation;
   FunctionalInterface1 is not a functional interface
}

public class LambdaEx1 {
   public static void useFIMethod(FunctionalInterface1 fi) {
      fi.methodA();
   }

   public static void main(String[] args) {
      useFIMethod(new FunctionalInterface1() {
         @Override
         public void methodA() {
            System.out.println("익명의 내부 클래스 형태");
         }
      });
      useFIMethod(() -> {
         System.out.println("람다 표현식 이용 1");
      });
      useFIMethod(() -> System.out.println("람다 표현식 이용 2"));
   }
}
//
익명의 내부 클래스 형태
람다 표현식 이용 1
람다 표현식 이용 2

(3) 파라미터가 있는 람다식 

ex)
package ch10.lambda;

@FunctionalInterface
interface FunctionalInterface2 {
   void methodB(String msg);
}

public class LambdaEx2 {
   public static void useFIMethod(FunctionalInterface2 fi) {
      fi.methodB("홍길동");
   }

   public static void main(String[] args) {
      useFIMethod((String msg) -> {
         System.out.println("람다 표현식 이용 1: " + msg);
      });
      useFIMethod(msg -> System.out.println("람다 표현식 이용 2: " + msg));
   }
}
//
람다 표현식 이용 1
람다 표현식 이용 2

(4)리턴 타입이 있는 람다식 

package ch10.lambda;

@FunctionalInterface
interface FunctionalInterface3 {
   String methodB(String msg) throws Exception;
}

public class LambdaEx3 {
   public static void useFIMethod(FunctionalInterface3 fi) {
      try {
         System.out.println(fi.methodB("홍길동"));
      } catch (Exception e) {
         e.printStackTrace();
      }
   }

   public static void main(String[] args) {
      useFIMethod((String msg) -> {
         return "람다 표현식 이용 1: " + msg;
      });
      useFIMethod(msg -> "람다 표현식 이용 2: " + msg);
      //파라미터 타입이 생략. 파라미터의 갯수가 하나이므로 소괄호가 
      //필요없고, 리턴문장 하나만 존재하므로 return 키워드및 
      //중괄호도 필요없다.
   }
}
//
람다 표현식 이용 1: 홍길동
람다 표현식 이용 2: 홍길동

(5) 람다의 실행 블록에서 변수 참조 
람다식은 컴파일러에 의해 익명의 내부클래스로 처리되기 
때문에 변수에 대한 참조 규칙도 동일하다. 

a. 외부클래스의 멤버를 자유롭게 사용할수 있다. 
b. 자바 8부터는 일반 로컬변수도 사용할수 있는데 final 키워드가 
적용된 것처럼 새로운 값을 할당할수는 없다. 

하지만, this를 사용하는 방법은 약간 다르다. 
람다식에서 this는 타겟 인터페이스가 아닌 외부클래스를
나타낸다. 따라서 람다식 내에서 this와 
외부클래스.this는 동일한 객체를 나타낸다. 

ex)
package ch10.lambda;

@FunctionalInterface
interface FunctionalInterface4 {
   String methodB(String msg);
}

public class VariableUseTest {
   private int instanceMember = 10;

   public void useFIMethod(FunctionalInterface4 fi) {
      System.out.println(fi.methodB("홍길동"));
   }
   
   public void lambdaTestMethod() {
      int localVar = 20;
      
      useFIMethod((String msg) -> {
         System.out.println("this: " + this);
         System.out.println("외부클래스.this: " + VariableUseTest.this);
         System.out.println("변수 참조: " + localVar + " : " + instanceMember);
         // localVar++;   // 로컬 변수 수정은 불가
         return "람다 표현식 이용 : " + msg + ", " + (instanceMember++);
      });

      useFIMethod(new FunctionalInterface4() {
         @Override
         public String methodB(String msg) {
            System.out.println("this: " + this);
            System.out.println("외부클래스.this: " + VariableUseTest.this);
            System.out.println("변수 참조: " + localVar + " : " + instanceMember);
            // localVar++;   // 로컬 변수 수정은 불가
            return "익명의 내부 클래스 이용 : " + msg + (instanceMember++);
         }
      });
   }

   public static void main(String[] args) {
      VariableUseTest vut = new VariableUseTest();
      vut.lambdaTestMethod();
   }
}
//
this: ch10.lambda.VariableUseTest@7cef4e59
외부클래스.this: ch10.lambda.VariableUseTest@7cef4e59
변수 참조: 20 : 10
람다 표현식 이용 : 홍길동, 10
this: ch10.lambda.VariableUseTest$1@2db0f6b2
외부클래스.this: ch10.lambda.VariableUseTest@7cef4e59
변수 참조: 20 : 11
익명의 내부 클래스 이용 : 홍길동11

----------------------------------------------------
3. 람다식을 이용한 함수형 프로그래밍

객체지향 언어로서의 자바 프로그래밍에서는 메서드의 구조와 이름이 
중요하다. 이름을 통해서 기능을 호출하기 때문이다. 

ex)
Arrays.sort(strs, new Comparator<String>(){
@Override
public int compare(String o1, String o2) {
return o1.compareTo(o2);
//Comparator의 compare 가 사용됨. 
}
})

하지만, 함수형 프로그래밍에서는 함수의 타입이 구조적이며 필요한 곳에 
바로 전달되므로 이름은 불필요하다. 

ex2)
Arrays.sort(strs, (o1, o2) -> { return o1.compareTo(o2)*-1;});

함수의 타입이 구조적이라는 표현은 자주 쓰는 패턴이 정해져 있다는 말이다. 
일반적으로 함수는 파라미터가 없거나 하나, 많으면 두개이다. 
반환 값은 있거나 없다. 
달라지는 것은 이를 이용한 구현부이다. 
따라서, 몇개 안되는 함수의 형태는 함수형 인터페이스로 정의하고 
달라지는 구현부는 람다식을 이용해서 작성한다. 

자바 8에서는 빈번히 사용되는 함수형 인터페이스들을 
java.util.function 패키지를 통해 제공한다. 
이 패키지에 선언된 함수형 인터페이스들은 메서드나 
생성자의 파라미터로 제공되는 타겟 인터페이스 사용된다. 

다음은 java.util.function 패키지에서 제공되는 기본 API의 종류들이다. 

종류 : abstract method 특징 
종류 : 파라미터 : 리턴: 메서드 : 비고 
(1) Consumer 계열 : O : X : void accept(T) : 소비자
(2) Supplier 계열: X : O : T get() : 공급자 
(3) Function 계열 : O : O :T apply(R) : 주로 파라미터를 리턴으로 매핑 
(4) Operation 계열 : O :O : T xxx(R) : 주로 파라미터를 연산해서 리턴 
(5) Predicate 계열 : O : boolean : boolean test(T) : 파라미터를 이용해서 return 결정. 

----------------------------------------------------
3.1 Consumer 계열

Consumer 계열은 소비자이다. 무엇을 소비할까? 바로 파라미터이다. 
Consumer 는 전달받은 파라미터를 받아서 소비하는 소비자이며 
리턴하지는 않는다. 

파라미터 -> Consumer :파라미터 소비 

다음은 Consumer 계열의 함수형 인터페이스 종류.

인터페이스명 : 메서드 : 설명 
(1) Consumer<T> : void accept (T t) : T 타입 객체 t를 받아서 소비 

(2)BiConsumer<T, U> : void accept( T t , U u) 
: T 타입과 U 타입 객체를 받아서 소비 

(3)P*Consumer : void accept(p# value)
 : p# 타입의 값을 받아서 소비 

 (4)ObjP*Consumer<T> : void accept(T t, p# value) 
: 객체 타입 T와 p# 값을 받아서 소비 

P* : Int, Long, Double를 의미하고, 
p# : int , long , double 을 나타낸다. 

P*와 p#에 해당하는 값들을 대입해보면 총 8가지가 존재하지만, 
매우 직관적인 이름 규칙을 가지고 있기 때문에 어렵지 않게 
이해할 수 있다. 이 규들은 다른 함수형 인터페이스에도 비슷하게 
적용되니 잘 기억하자. 

먼저, Consumer<T> 는 객체 하나를 받아서 소비한다. 
파라미터 두개를 받는 경우 Bi 접두사가 붙는다. 
BiConsumer<T, U>는 T와 U 두개를 파라미터로 받는다. 

객체를 처리하지 않고 기본형을 처리하는 경우 double, long, int 
값을 처리할수 있다. 
이때, 인터페이스에는 각 타입의 첫 글자를 대문자로 바꿔서 접두사로 추가해준다. 
(DoubleConsumer, LongConsumer, IntConsumer)

객체와 함께 기본형을 받는 경우 다시 위 인터페이스 이름 앞에 Obj가 추가된다. 
(ObjDoubleConsumer<T>, ObjLongConsumer<T>, ObjIntConsumer<T>)

물론, int 값을 처리하기 위해 Consumer<Integer>를 이용한다면 
IntConsumer를 사용하지 않아도 좋다. 
하지만, 내부적으로 오토박싱(auto boxing)이 일어나기 때문에 성능상 
좋지는 않다. 될수 있으면 타입에 특화된 버전을 사용하는 것이 좋다. 

간단히 Consumer<T> 를 사용해보자. 
다음 예는 문자열 하나를 파라미터로 받아서 출력한다. 
따라서, 콘솔에 Hello 가 출력된다. 

ex)
Consumer<String> consumer = x -> System.out.println(x);
consumer.accept("Hello");

다음은 객체인 String 과 int 를 받아서 처리하는 ObjIntConsumer의 사용 예.

ex2)
ObjIntConsumer<String> consumer2 = (name, repeat) -> {
for (int i =0; i < repeat; i++){
System.out.println(name);
}
};
consumer2.accept("홍길동",2);

Student 타입의 객체를 다양한 방식으로 출력 해보자. 

ex3)
package ch10.lambda.functional;

import java.util.function.Consumer;

public class ConsumerTest {
   public static void printStudent(Student student, Consumer<Student> printer) {
   
   //Student 타입 객체와 Student를 소비하는 Consumer인 printer를 갖는 
   //printStudent()를 정의한다. 
   
      printer.accept(student);
   }

   public static void main(String[] args) {
      Student student = new Student("홍길동", 80);

      printStudent(student, s -> System.out.println(s.name));
      printStudent(student, s -> s.score *= 1.5);
      printStudent(student, s -> System.out.println(s.name + ": " + s.score));
   }
}

class Student {
   public String name;
   public double score;

   Student(String name, double score) {
      this.name = name;
      this.score = score;
   }
}
//
홍길동
홍길동: 120.0



----------------------------------------------------
3.2 Supplier 계열

Supplier는 리턴값을 공급해주는 공급자다. 
이 계열은 파라미터를 받지 않으며 자체적으로 리턴할 값을 생산한다. 

동작 방식 
리턴 값 생산  Supplier---> return

Supplier 계열의 인터페이스

인터페이스명 : 메서드 : 설명 

(1) Supplier<T> : T get() : T 타입 객체 리턴 
(2) P*Supplier : p# getAsP*() : p# 타입의 값 리턴 

P* : Int, Long, Double를 의미하고, 
p# : int , long , double 을 나타낸다. 

Supplier 계열은 파라미터가 없기 때문에 Bi가 붙는 형태는 없다. 

ex)
Supplier<String> supplier = () -> { return "Hello";};
System.out.println(supplier.get());

IntSupplier supplier2 = () -> {
Random random = new Random();
return random.nexInt(6);
};
System.out.println(supplier2.getAsInt());

ex2)
package ch10.lambda.functional;

import java.util.function.Supplier;

public class SupplierTest {

   public void useSupplier(Supplier<String> sup) {
      System.out.println(sup.get());
   }

   public static void main(String[] args) {
      SupplierTest supT = new SupplierTest();
      Supplier<String> sup = () -> {
         return "Hello";
      };
      supT.useSupplier(sup);

      supT.useSupplier(() -> {
         return "Lambda";
      });
      supT.useSupplier(() -> "World");
      //인라인 형태로 Supplier를 useSupplier()의 파라미터로 전달한다. 
      // 이때, return 문 하나로만 구성되므로 중괄호와 return 키워드는 생략되었다. 
   }
}
//
Hello
Lambda
World

----------------------------------------------------
3.3 Function 계열

Consumer 계열과 Supplier 계열이 각각 파라미터, 리턴값만을 설정하는 
형태여서 활용에 어려움이 있었다면 Function 계열을 사용할수 있다. 
Function 계열은 파라미터를 받고 리턴도 존재한다. 

파라미터 -> Function -> return 
  파라미터 활용 ----> 리턴값 생성  
  
다음은 Function 계열의 함수형 인터페이스 종류이다. 

인터페이스 명 : 메서드 : 설명 
(1) Function<T, R> : R apply (T t) : T 타입의 파라미터를 받고 R 타입을 리턴 

(2) BiFunction<T, U, R> : R apply (T t, U u)
: T와 U 타입의 파라미터를 받고 R 타입을 리턴

(3) P*Function<R> : R apply (p# value) 
: p# 타입의 값을 받아서 R 타입으로 리턴 

(4)P*toQfunction : q applyAsQ(p# value) 
:p* 타입의 값을 받아서 q 타입으로 리턴 

(5) ToP*Function<T> : p# applyAsP*(T t)
:p# 타입의 값을 받아서 R 타입으로 리턴 

(6) ToP*BiFunction<T> : p# applyAsP*(T t, U u)
:T와 U 타입의 값을 받아서 p# 타입으로 리턴


P* , Q : Int, Long, Double를 의미하고, 
p# , q : int , long , double 을 나타낸다. 

Function 계열은 가장 다양한 형태의 인터페이스들이 제공되지만, 
Consumer와 Supplier 의 이름 적용 방법을 잘 학습했다면 
어렵지 않게 내용을 파악가능.

ex)
Function<String, Integer> function = (src) -> { return src.length();};
System.out.println(function.apply("Hello"));

ToIntBiFunction<String, String> function2 = (src1,src2) ->{
return Integer.parseInt(src1) + Integer.parseInt(src2);
};
System.out.println(function2.applyAsInt("4","5"));

다음은 Function 인터페이스를 이용하는 예.

ex2) 
package ch10.lambda.functional;

import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.ToIntFunction;

public class FunctionTest {
   private Person person;

   //String 과 Integer 두 개의 파라미터를 받고 Person을 리턴하는 
   //BiFunction 타입에 String, Integer를 받는 메서드 apply()가 있다. 
   //apply()에 name 과 age를 넘겨주면 Person이 리턴된다. 
   
   public void addPerson(BiFunction<String, Integer, Person> function, String name, Integer age) {
      person = function.apply(name, age);
   }

   // String을 파라미터로 받고 String을 리턴하는 Function 타입과 String을 파라미터
   // 로 받는 메서드이다. function의 apply()에 name을 넘겨주면 String이 리턴된다. 
   
   public void printPerson(Function<String, String> function, String name) {
      System.out.println(function.apply(name));
   }

   // String을 파라미터로 받아 int를 리턴하는 ToIntFunction 타입과 String을 파라미터
   //로 받는 메서드이다. function은 applyAsInt()에 name 을 넘겨주면 int 를 리턴한다. 
   
   public void printAge(ToIntFunction<String> function, String name) {
      System.out.println(name + "의 나이: " + function.applyAsInt(name));
   }

   public static void main(String[] args) {
      FunctionTest ft = new FunctionTest();
      
      //addPerson()을 호출하면서 람다식을 이용해 BiFunction 타입 인터페이스를 
      //넘긴다. 구현부에서는 Person 객체를 생성후 리턴한다. 
      
      ft.addPerson((name, age) -> {
         return new Person(name, age);
      }, "홍길동", 10);

      // printPerson()을 호출하면서 람다식을 이용해 Function 타입 인터페이스를 넘긴다. 
      // 구현부에서는 Person 객체의 name이 파라미터인 홍길동과 같으면 객체의 
      // toString() 을 리턴하고 그렇지 않으면 unknown user를 리턴한다. 
      ft.printPerson((name) -> {
         if (ft.person.name.equals(name)) {
            return ft.person.toString();
         } else {
            return "unknown user";
         }
      }, "홍길동");

      // printAge()을 호출하면서 람다식을 이용해 ToIntFunction 타입 인터페이스를 넘긴다. 
      // 구현부에서는 Person 객체의 name이 홍길동과 같으면 객체의 age 값을, 
      // 그렇지 않으면 0을 리턴한다.       
      ft.printAge((name) -> {
         if (ft.person.name.equals(name)) {
            return ft.person.age;
         } else {
            return 0;
         }
      }, "홍길동");
   }
}

class Person {
   String name;
   int age;

   Person(String name, int age) {
      this.name = name;
      this.age = age;
   }

   @Override
   public String toString() {
      return "Person [name=" + name + ", age=" + age + "]";
   }
}
//
Person [name=홍길동, age=10]
홍길동의 나이: 10

----------------------------------------------------
3.4 Operator 계열

Operator 계열은 Function 계열과 유사하게 파라미터와 리턴 타입을 
모두 갖는다. 다만, 차이점은 Function 계열은 파라미터와 리턴타입이 
무관하지만, Operator 계열은 파라미터를 이용해 어떤 연산을 수행한 후 
파라미터와 같은 타입이 린턴된다. 

동작방식
파라미터 -> Operator ->return
 파라미터활용 -> 파라미터 리턴 

다음은 Operator 계열의 함수형 인터페이스 종류이다. 

인터페이스 명 : 메서드 : 설명 
(1)UnaryOperator<T> : T apply(T t) 
: T 타입의 파라미터를 받고 T 타입을 리턴 

(2) BinaryOperator<T> : T apply(T t1, T t2)
: T와 T 타입의 파라미터를 받고 T 타입을 리턴.

(3) P*UnaryOperator : P* appAsP*(p# value) :
P* 타입의 값을 받아서 p# 타입으로 리턴 

(4) P*BinaryOperator: P* appAsP*(p# value1, p# value2)
: P* 타입의 값을 두개를 받아서 p# 타입 리턴 

P*는 Int, Long, Double을 의미.
p# 는 int, long, double

Operator 계열은 여러모로 Function 계열을 닮았다. 
실제로 UnaryOperator<T>는 Function<T,T>를 
상속받았고 BinaryOperator<T>는 BiFunction<T, T, T>
를 상속받았다. 

ex)
UnaryOperator<Double> operator = (x) -> { return Math.pow(x,2);};
System.out.println(operator.apply(10,0));

DoubleBinaryOperator operator2 = (x,y) -> { return Math.max(x,y);};
System.out.println(operator2.applyAsDouble(100,200));


----------------------------------------------------
3.5 Predicate 계열

Predicate 계열은 파라미터와 리턴 타입을 갖는데 리턴타입이
boolean으로 고정되어 있다. 

동작방식 
parameter-> Predicate -> boolean
                 파라미터로 판단
              
다음은 Predicate 계열의 함수형 인터페이스 종류이다. 

인터페이스명 : 메서드 : 설명 

(1) Predicate<T> : boolean test (T t)
:T 타입의 파라미터를 받고 boolean을 리턴.

(2) BiPredicate<T> : boolean test( T t, U u)
: T와 U 타이의 파라미터를 받고 boolean을 리턴 

(3) P*Predicate : boolean test(P* value)
:P* 타입의 값을 받아서 boolean으로 리턴 

P*는 Int, Long, Double을 의미.

ex)
Predicate<String> predicate = (name) -> { return name.contains("Java");};
System.out.println(predicate.test("JavaScript");

DoublePredicate predicate2 = (num) -> { return num > 0.5;};
System.out.println(predicate2.test(Math.random()));

다음은 int의 배열에서 원하는 형태의 데이터만 추출하는 예제.

ex2)
package ch10.lambda.functional;

import java.util.function.IntPredicate;

public class PredicateTest {
   static int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
   
   public static void printSome(IntPredicate pred) {
      for (int num : nums) {
         if (pred.test(num)) {
            System.out.print(num + "\t");
         }
      }
      System.out.println();
   }

   public static void main(String[] args) {
      printSome((num) -> {
         return num % 3 == 0;
      });
      printSome(num -> num > 5);
   }
}
//
3   6   9   
6   7   8   9   10   

----------------------------------------------------
3.6 표준 함수형 인터페이스의 메서드

이제까지 소개했던 java.util.function 패키지의 인터페이스들은 모두 
하나 이상의 default 또는 static 메서드를 포함하고 있는데 
이들 메서드를 이용해서 동일한 계열의 여러 동작을 연결해서 
사용할수 있다. 

(1) andThen() 과 compose() 
andThen()과 compose()는 Consumer, Function, Operator 계열에 선언된 
default 메서드로 두개의 함수형 인터페이스를 순차적으로 연결한다. 
이때 첫번째 함수의 연산의 결과를 두번째 함수의 파라미터로 제공해서 
최종 결과 값을 도출한다. 최종값의 타입은 당연히 두번째 함수의 리턴타입이다.

이 두메서드의 차이점은 적용순서이다. 먼저, andThen()을 살펴보자. 

A 인터페이스에 선언된 andThen()을 사용해서 B 인터페이스를 연결할 때는 
A.andThen(B)와 같이 작성한다. 그럼 두개의 인터페이스가 결합된 AB 인터페이스를 
사용할수 있고 최종 결과는 AB 인터페이스를 통해서 확인할수 있다. 
이 때 A의 결과는 B의 파라미터로 활용되고 B가 리턴하는 값이 AB가 
리턴하는 값과 동일하다. 

andThen() 의 동작 방식. 

(1) //(3)의 리턴 값 받음. 
AB = A.andThen(B)
AB.method(param) 

(2) //(1)이 파라미터 값 (3)으로 리턴
A 
(lambda ex) 

(3) //(2)의 리턴값이 파라미터로 그리고  (1)으로 리턴
B 
(lambda ex)

(1) = (2) ->  (3)

compose() 는 A와 B의 적용순서가 반대이다. 
A 인터페이스에 선언된 compose()를 사용해서 B 인터페이스
를 연결할 때는 A.compose(B) 와 같이 작성한다. 
역시 두개의 인터페이스가 결합된 AB 인터페이스를 사용할수 있고,
최종 결과는 AB 인터페이스를 통해서 확인할수 있다. 
이때 B가 먼저 동작해서 B의 리턴이 A의 파라미터로 사용되고 
A의 리턴은 최종적인 AB 의 리턴과 동일하다. 

andThen() 의 동작 방식. 

(1) //(2)의 리턴 값 받음. 
AB = A.andThen(B)
AB.method(param) 

(2) //(3)의 리턴값을  파라미터 값으로
A 
(lambda ex) 

(3) //(1)의 리턴값이 파라미터로 그리고  (2)으로 리턴
B 
(lambda ex)

(1) = (2) <- (3)

다음 표는 인터페이스별로 andThen()과 compose() 지원 여부를 나타낸다. 

인터페이스 명 : andThen() : compose

Consumer<T> : O : X 
BiConsumer <T, U> : O : X 
P*Consumer : O :X 
Function<T, R> : O : O 
BiFunction<T, U, R> : O : X
BinaryOperator<T> : O : X 
P*UnaryOperator : O : O 

-Compose 계열에서의 연결 
Compose 계열은 리턴값이 존재하지 않는다. 따라서 최초의 파라미터가 
그대로 두번째 인터페이스의 파라미터가 되고 처음 인터페이스의 동작은 
두번째 인터페이스의 동작에 영향을 주지 않는다. 

ex) 
DoubleConsumer con1 = num -> System.out.println(Math.pow(num,2));
DoubleConsumer con2 = num -> System.out.println(num + num);

DoubleConsumer andThen = con1.andThen(con2);
andThen.accept(10);

위 코드의 실행 결과는 먼저 con1 의 실행결과로 100.0이 출력되고 
이어서 con2의 결과로 20.0이 출력된다. 

andThen = con1   andThen con2 : 최초 파라미터가 그대로 전달. 
accept(10)   100.0                  20.0

-Function 계열의 연결 
Function<T, R> 계열에서는 andThen()과 compose()를 모두 사용가능. 
andThen()과 compose()를 이용해 FUnction 을 연결하는 간단한 예를 보자. 

ex)
Function<String, String> func1 = name -> "Hello" + name;
Function<String, String> func2 = data -> "returned : " + data;

Function<String, String> func3 = func1.andThen(func2);
System.out.println(func3.apply("홍길동")); // returned : Hello 홍길동 

Function<String, String> func4 = func1.compose(func2);
System.out.println(func4.apply("장길산")); // Hello returned : 장길산 

func3는 func1.andThen(func2)로 구성된다. func3.apply()의 파라미터로 
공급된 "홍길동"은 처음 인터페이스인 func1의 파라미터로 사용돼서 
"Hello 홍길동"을 리턴한다. 
이 값은 다시 두번째 인터페이스인 func2의 파라미터가 되서 최종 결과물은 
"returned: Hello 홍길동"이 된다. 

func3 = func1   andThen   func2 
apply("홍길동") 의 파라미터가 func1의 파라미터로 
func1의 리턴값 Hello 홍길동은 다시 func2의 파라미터가 
되서 최종 결과물은 
"returned: Hello 홍길동"이 된다. 

func4는 func1.compose(func2)로 구성되므로 
func4.apply()의 파라미터로 공급된 "장길산"은 
먼저 func2의 파라미터로 사용돼서 " returned : 장길산"을 리턴한다. 
이값은 다시 첫번째 인터페이스인 func1의 파라미터가 돼서 
최종 리턴값은 "Hello returned : 장길산"이 된다. 

(2) and() , or(), negate(), isEqual()
Predicate 계열은 디폴트 메서드로 and(), or(), negate()를 가지고 클래스 
메서드로는 isEqual()을 갖는다. 
이들 메서드는 서로 다른 두개의 Predicate를 연결하거나 기존의 
Predicate를 이용해 새로운 Predicate를 반환한다. 

먼저, 디폴트 메서드에 대해 알아보자. 

a. and()는 두개의 Predicate를 연결하며 && 연산자와 동일하게 동작한다. 
즉, 두개의 Predicate가 모두 true 일 때 test()의 결과가 true 인 새로운 
Predicate를 리턴한다. 

b. or()는 두개의 Predicate를 연결하며 || 연산자와 동일하게 동작한다. 
즉, 두개의 Predicate 중 하나라도 true 이면 test() 결과 true인지 새로운 
Predicate를 리턴한다. 

c. negate() 기존의 Predicate에 대해 !(부정)으로 동작한다. 
즉 기존의 test() 결과가 true 이면, false , false 이면 true를 리턴하는 Predicate를
생성한다. 

ex)
package ch10.lambda.composing;

import java.util.function.IntPredicate;

public class PredicateComposeTest {

   public static void main(String[] args) {
      int [] nums = {1,2,3,4,5,6,7,8,9,10};
      IntPredicate ip1 = (num) ->{return num%2==0;};// 2의 배수인지 확인
      IntPredicate ip2 = (num) ->{return num%3==0;};// 3의 배수인지 확인

      IntPredicate ip3 = ip1.and(ip2);
      for(int num: nums) {
         if(ip3.test(num)) {
            System.out.println("2와 3의 공배수: "+num);
         }
         if(ip1.negate().test(num)){
            System.out.println("2의 배수가 아닌 수: "+num);
         }
      }
   }
}
//
2의 배수가 아닌 수: 1
2의 배수가 아닌 수: 3
2의 배수가 아닌 수: 5
2와 3의 공배수: 6
2의 배수가 아닌 수: 7
2의 배수가 아닌 수: 9

다음으로 클래스 메서드인 isEqual()에 대해 알아보자. 

isEqual()은 클래스 메서드이므로 바로 인터페이스 이름을 통해 호출하고 
메서드 파라미터로 비교될 기준 값을 넘겨주면 Predicate 객체가 리턴된다. 
이때 Predicate의 람다식은 내부적으로 java.util.Objects.equals()를 이용해서 
대상 객체와 기준 객체를 비교하도록 작성된다. 

다음은 java.util.Objects.equals() 메서드이다. 

public static boolean equals(Object a, Object b) {
return (a == b) || (a != null && a.equals(b));
}
위 코드에서 a가 Predicate의 소스가 되고 b는 test()의 파라미터가 전달된다. 

Predicate<String> strPredicate = Predicate.isEqual("Hello");
System.out.println(strPredicate.test("Hello")); // true 

(3) 
minBy(), maxBy()

minBy()와 maxBy()는 BinaryOperator에서 제공되는 클래스 메서드들이다. 
이 두메서드는 Comparator<T>를 파라미터로 받아서 각각 최소값과 최대값 
을 구하는 BinaryOperator<T>를 리턴한다. 
Comparator<T> 자체도 함수형 인터페이스이기 때문에 람다식을 이용해서 
비교 방법을 설정한다. 

BinaryOperator<String> bo = BinaryOperator.minBy((o1, o2)) -> {
return o1.compareTo(o2);
});
System.out.println(bo.apply("Hello", "Hi")); //Hello

BinaryOperator<Integer> bo2 = BinaryOperator.maxBy((i1, i2) -> {
return i1.compareTo(i2);
});
System.out.println(bo2.apply(10, 5)); //10

----------------------------------------------------
3.7 메서드 와 생성자 참조 

람다식을 이용해 프로그래밍하다 보면 다른 코드에 전달하려는 동작을 
수행하는 메서드가 이미 있는 경우가 있다. 
예) 문자열의 정렬할때 함수형 인터페이스로 Comparator 타입이 필요하고 
Comparator 의 compare()메서드에서 사용할 기능을 전달하는데 
이때 String 의 compareTo()가 사용된다. 
ex)
String[] langs = {"Phython", "C", "JAVA"};

Arrays.sort(langs, (o1,o2) -> {
return o1.compareTo(o2);
});

이처럼 단순히 기준에 사용된 코드를 재사용하는 경우 
:: 연산자 (더블콜론연산자)를 이용해 기존 메서드를 
참조할수 있다. 이 특수한 연산자를 사용하면 내부클래스를 줄이는 
람다식을 다시 더 줄일수 있다. 
람다식이 메서드 구현부를 간략하게 작성하는 방법이라면, 
:: 연산자는 이름만으로 메서드를 참조할수 있게 한다. 

:: 연산자는 메서드 이름과 클래스 이름 또는 객체 이름을 분리하며 
다음과 같은 3가지 형태로 구분할수 있다. 

- 클래스::인스턴스_메서드 
- 클래스::클래스_메서드
- 객체::인스턴스_메서드

(1) 클래스::인스턴스_메서드

클래스::인스턴스_메서드 형태는 인스턴스 메서드를 참조하는 형태로 
람다식에 하나 이상의 파라미터가 전달되는 형태를 대체한다. 
이때, 첫번째 파라미터의 클래스가 메서드의 소속이 되고 나머지 
파라미터들은 메서드 호출시 메서드의 파라미터로 전달된다. 

예를 들어 문자열의 정렬에는 String 클래스의 compareTo()가 사용된다. 
이 메서드를 이용해서 String[] 정렬하려면 다음과 같이 쓸수 있다. 

String[] langs = { "Phython", "C", "java", "JavaScript"};
Arrays.sort(langs, String ::compareTo);

즉, 람다식에 전달된 o1의 타입인 String 클래스가 가지는 compareTo()
메서드에 두번째 파라미터 o2가 전달된다. 

(2) 클래스::클래스_메서드
클래스 :: 클래스_메서드 형태는 클래스에 속한 클래스 메서드를 사용하는 기법으로 
메서드의 소속이 이미 나와 있기 때문에 람다식에 전달된 모든 파라미터가 
클래스_메서드의 파라미터로 전달된다. 

ex)
package ch10.lambda.ref;

import java.util.function.Function;

public class MethodReference2 {

   public static void main(String[] args) {
      Function<String, Integer> f0 = (str) -> {return Integer.parseInt(str);};
      System.out.println(f0.apply("100"));
      
      //최대한 축약한 람다식. 파라미터가 하나이므로 ()가 생략되고 구현부가 
      //return 한 문장이므로 {} 와 return 키워드는 생략될수 있다. 
      
      Function<String, Integer> f1 = str -> Integer.parseInt(str);
      System.out.println(f1.apply("200"));

      // ::연산자를 이용해 메서드를 직접 참조함으로써 가장 간단한 형태로 작성되었다. 
      // 이때 전달되는 파라미터인 "300" 은 Integer.parseInt() 의 파라미터로 전달된다. 
      
      Function<String, Integer> f2 = Integer::parseInt;
      System.out.println(f2.apply("300"));
   }
}
//
100
200
300

(3) 
객체 :: 인스턴스_메서드의 형태 
객체::  인스턴스_메서드의 형태는 주어진 객체의 메서드가 호출되면
람다식에 전달된 파라미터는 메서드에 그대로 전달된다. 

ex)
package ch10.lambda.ref;

import java.util.function.Consumer;
import java.util.function.Function;

public class MethodReference3 {

   public static void main(String[] args) {
      String base = "Lambda";
      Function<String, Boolean> f = (str) -> base.equals(str);
      System.out.println(f.apply("Lambda"));

      //메서드 참조형식으로 변경해서 구현이 간단해졌다. 
      //apply를 통해서 전달된 파라미터는 base.equals()의 파라미터로 전달된다. 
      
      Function<String, Boolean> f2 = base::equals;
      System.out.println(f2.apply("Lambda"));

      // Consumer<T>에서 메서드 참조를 사용한 예로 System.out 객체가 
      // 가진 println 메서드를 참조해서 "Lambda"를 출력한다. 
      
      Consumer<String> c = System.out::println;
      c.accept("Lambda");
   }
}
//
true
true
Lambda

(4)
클래스:: new 
마지막 참조 형태는 생성자 참조이다. 
클래스::new 형태의 코드는 클래스 타입의 새로운 객체를 생성한다. 
호출되는 생성자는 전달되는 파라미터의 타입과 개수에 근거해서 
결정된다. 
만약 매칭되는 생성자가 없을 경우는 당연히 컴파일 에러가 발생한다. 

클래스::new 를 통한 생성자 참조는 배열을 만들때도 사용할수 있다. 
이때 넘기는 파라미터는 배열의 길이를 의미한다. 

ex)
IntFunction<String []> function = String[]::new;
String [] strs1 = function.apply(10); // length = 10;
String [] strs2 = function.apply(5); // length = 5;

다음 예제는 생성자 참조를 이용해서 다양한 형태의 StringBuffer의 
생성자를 호출하는 방식을 보여준다. 

ex)
package ch10.lambda.ref;

import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Supplier;

public class ConstructorReference {

   public static void main(String[] args) {
   
   // StringBuffer를 파라미터로 받아서 capacity()와 length()를 출력하도록 
   // Consumer<T>를 작성한다. 
   
      Consumer<StringBuffer> cons = (src) ->{
         System.out.println(src.capacity()+" : "+src.length());
      };

        //Supplier<T> 를 이용해서 기본적인 StringBuffer를 생성한다. 
      //이때 넘기는 파라미터가 없으므로 StringBuffer() 기본 생성자가 호출. 
      
      Supplier<StringBuffer> s1 = StringBuffer::new;
      StringBuffer sb1 = s1.get();  //파라미터 없음
      cons.accept(sb1);
      
      //Function<T,R>을 이용해서 String을 파라미터로 받는 StringBuffer(String src)
      //생성자를 호출한다. 
      
      Function<String, StringBuffer> f1 = StringBuffer::new;
      StringBuffer sb2 = f1.apply("Hello"); //문자열 파라미터 1개
      cons.accept(sb2);
      
      //IntFunction<R>을 이용해서 int 를 파라미터로 받는 StringBuffer(int capacity)
      //생성자를 호출한다. 
      
      IntFunction<StringBuffer> f2 = StringBuffer::new;
      StringBuffer sb3 = f2.apply(10); // 숫자형 파라미터 1개
      cons.accept(sb3);
   }
}
//
16 : 0
21 : 5
10 : 0

===================================
[자바 해바라기 정리] 11 java.lang 패키지

1. Object 클래스 

이제까지 자바의 객체지향적인 특성을 이해했다면 본격적인
프로그래밍이 가능하다. 추가로 효율적인 자바 프로그래밍을 하기 
위해서는 자바가 제공해주는 다양한 API(Application Programming Interface
:미리 만들어진 클래스들의 모임)를 잘 사용하는 것이 매우 중요하다. 
예) 배열의 크기가 고정적이라는 답답함을 개선하기 위해 스스로 
크기를 늘릴수 있는 자료 구조를 반복문과 제어문을 이용해 밤새 
작성했는데 다음날 다른 사람은 java.util에 있는 ArrayList 라는 
클래스를 이용해 단 한줄에 동일한 목적을 달성했다면 누가 좋은 
프로그래머 일까?

java.lang 패키지는 이름대로 자바 언어에서 가장 기본적이며 자주 
사용되는 클래스들의 모임이다. 따라서 별도로 import 하지 않아도 바로 사용할수 
있다. 이번 장에서는 java.lang 패키지의 대표적인 클래스들에 대해 알아보자. 

1. Object 클래스 
Object 클래스는 앞서 살펴봤듯이 가장 최상위 클래스로 모든 클래스의 
조상 클래스이다. 
따라서, Object 의 멤버는 모든 클래스의 멤버가 된다. 
Object 클래스에는 toString(), equals(), hashCode(), getClass() 등 다양한 메서드들이 
선언되어 있다. 

Object : toString(), equals(), hashCode(), getClass()...
System, Exception , Math , Person
Exception - RuntimeException 
Person <---SpiderMan---toString()

앞서 toString()의 경우에서 살펴봤듯이 Object에 있는 메서드들은 기본에는 
충실하지만, 자식 입장에서는 만족스러운 기능을 하지 못하기 때문에 
많은 경우 오버라이딩이 필요하다. 
하지만, 그렇다고 해서 Object에서 toString()을 제외하면 println()과 
같은 메서드를 통해 객체를 출력하기가 매우 힘들어 질것이다. 

ex) 
System.out.println(new Person()); // Object의 toString 사용 
System.out.println(new SpdierMan()); // SpdierMan의 toString 사용. 

다음은 Object 클래스에 선언된 메서드.

메서드 명 : 선언부와 설명 

getClass() : public final native Class<?> getClass()
현재 객체의 실제 Class 객체를 리턴한다. 

hashCode() : public native int hashCode()
현재 객체의 해시 코드 값을 리턴한다. 

equals(): public String toString()
객체의 문자열로 변환 후 리턴한다. 

clone() : protected native Object clone() throws CloneNotSupportedException
현재 객체를 복제해서 동일한 내용의 새로운 객체를 리턴한다. 

finalize() : protected void finalize() throws Throwable
객체가 G.C(Garbage Collection)되기 직전에 호출되는 메서드로 
자바 9에서 @Deprecated 선언됨.

Object 메서드에는 native 키워드가 사용된 메서드들이 다수 존재한다. 
대표적인 Object의 메서드들에 대해서 알아보자. 
native란 자바가 아닌 다른 언어(C, C++등)로 작성된 기능을 자바에서 
사용할 때 이용하는 키워드이다. 


----------------------------------------------------
1.1 equals() 메서드

equals 메서드는 이름대로 비교 대상인 두개의 객체가 같은지 등가비교 
(==을 이용)해서 같으면 true, 다르면 false를 리턴한다. 

ex)
public boolean equals(Object obj) {
return (this == obj);
}

객체들은 참조변수에 할당되기 때문에 여기서 같다는 말은 참조하는 값이 
같은지, 즉 같은 객체인지를 확인한다. 
다음 obj1 과 obj2 에 각각 새로 생성한 객체의 참조를 할당하고 
obj3에는 obj2의 참조 값을 할당한 후 equals 와 '=='을 이용해서 비교한 결과.

ex2)
Object obj1 = new Object();
Object obj2 = new Object();
Object obj3 = obj2;
System.out.printf("obj1 == obj2 : %b%n", obj1 == obj2); // false
System.out.printf("obj1 equals obj2 : %b%n", obj1.equals(obj2)); // false
System.out.printf("obj2 == obj3 : %b%n", obj2 == obj3); // true
System.out.printf("obj2 equals obj3 : %b%n", obj2.equals(obj3); // true

결과를 보면 '=='과 equals 메서드의 결과가 같음알수 있다. 
Object 의 equals 메서드가 '=='으로 구현되어 참조값 자체를 비교하기 때문에 
당연한 결과이다. 

ex)
obj1 -> 0x100
obj2 -> 0x200 
obj3 -> 0x200 

그런데 이결과가 정말 우리가 필요한 결과일까? 만약 "Hello" 라는 내용을 
가지는 두개의 String 객체가 있을때 우리는 두 객체를 같다고 할것인가?
다르다고 할것인가? 이 세상의 모든 핸드폰은 고유의 전화번호를 갖는다.
만약, 두 HandPhone 객체가 있는데 번호가 같다면 우리는 이 두 
HandPhone 을 같다고 할것인가? 다르다고 할것인가? 

물론, 두 객체의 주소값을 비교해서 같은 객체인지를 파악할수도 있겠지만, 
실생활에서 '같다'라는 표현은 주소값보다는 내용을 기준으로 하는 경우가 많다. 
따라서 이런 경우도 Object 가 물려준 equals 를 그대로 쓰기보다는 내용을 
비교하도록 오버라이딩 해서 사용할 필요가있다. 
String과 같은 API는 미리 equals 메서드를 내용을 비교하도록 
오버라이딩 해놓았다. 
주소값을 비교하고 싶을 경우는 '==' 을사용하고,
내용을 비교하고 싶을 때는 equals를 사용한다. 

ex)
package ch11.object;

class Phone {
	String number = "전화번호";

	public Phone(String number) {
		this.number = number;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj != null && obj instanceof Phone) {
			Phone casted = (Phone) obj;
			return number.equals(casted.number);
		}
		return false;
	}
}

public class EqualsTest {
	private static void testString() {
		String s1 = new String("Hello");
		String s2 = new String("Hello");
		System.out.println("String: "+(s1 == s2) + " : " + s1.equals(s2));
	}

	private static void testPhone() {
		Phone p1 = new Phone("0100000000");
		Phone p2 = new Phone("0100000000");
		System.out.println("Phone: "+(p1 == p2) + " : " + p1.equals(p2));
	}
	//둘은 다른 객체, '==' 결과 false ,
	// equals()가 주석 처리되면 ,Phone이 가지는 equals()는 Object의 것이다. 
	//따라서 내용을 비교하지 않고 단순히 '=='의 결과와 동일한다. 
	// 주석을 해제하고 다시 실행하면 내용을 비교하게 된다. 

	public static void main(String[] args) {
		testString();
		testPhone();
	}
}
//
주석 해제 전 오버라이딩 
String: false : true
Phone: false : false

주석 해제후 오버라이딩
String: false : true
Phone: false : true


----------------------------------------------------
1.2 hashCode() 메서드

객체의 해시코드(hash code) 란 시스템에서 객체를 구별하기 위해 사용되는 
정수값으로 프로그램 내에서 객체마다 유일한 값이기 때문에 그냥 주소값이라고 
이해해도 괜찮다. 
이값은 Object의 hashCode() 메서드를 통해 리턴 받을수 있다. 
이 메서드는 native로 선언되어 있기 때문에 구현을 알아볼수는 없다. 

ex)
public native int hashCode();

이 hashCode()는 뒤에서 HashSet이나 HashMap 등에서 객체를 구별하기 위한 
일종의 키값으로 사용한다. java.util 패키지에 있는 HashSet은 데이터를 저장하는 
자료구조의 하나인데 동일한 데이터는 중복해서 저장하지 않는 특성이 있다. 
중요한 것은 동일한 데이터를 판단하는 기준이다. 

Object 클래스에는 다음 내용이 있다. 

-애플리케이션 실행 중에 같은 객체의 hashCode()를 여러번 호출할때 
equals()에서 사용하는 값들이 변경되지 않으면 언제나 동일한 값이 반환되어야 한다. 

- equals() 메서드가 같다고 판단한 두 객체의 hashCode() 값은 언제나 같아야 한다. 

- equals() 메서드가 다르다고 판단한 두 객체의 hashCode()는 항상 같을 필요는 없지만 
다른 값이 나올때 해시 테이블의 속도가 향상된다. 

즉 equals() 메서드를 사용해 두 개의 객체가 내용을 기준으로 같은지 비교하도록 
오버라이딩 해봤는데 이것으로는 부족하고 추가로 hashCode() 메서드도 오버라이딩 
해야한다는 것이다. String이나 Number와 같은 클래스들은 이미 
equals() 와 hashCode()를 오버라이딩 하고 있기 때문에 
Set 계열의 자료 구조에 저장하면 하나의 객체만 관리된다. 

ex)  
              add
String s1 = new String("Hello") -> Set 
String s2 = new String("Hello") -> Set 
-> {s1} 하나만 관리 
Set --  s1.equals(s2) && s1.hashCode() == s2.hashCode()

객체마다 유일한 hashCode()를 리턴하도록 메서드를 오버라이딩하는 것은 
쉽지 않다. 
일반적으로 멤버변수들이 가진 hashCode()를 조합해서 사용하면 쉽게 
오버라이딩이 가능하다. 

ex)
package ch11.object;

import java.util.HashSet;
import java.util.Set;

class Product {
	String sn;

	public Product(String sn) {
		this.sn = sn;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj != null && obj instanceof Product) {
			Product casted = (Product) obj;
			return sn.equals(casted.sn);
		}
		return false;
	}

	@Override
	public String toString() {
		return "Product [sn=" + sn + "]";
	}
	
	@Override
	public int hashCode() {
		return sn.hashCode();
	}
}
//String 타입의 sn 을 멤버 변수로 가지는 Product 클래스를 정의한다. 
equals()메서드와 toString() 메서드가 구현되어 있으며 
hashCode()는 주석 처리되어 있다. hashCode() 함수는 간단하게 
sn의 hashCode()를 그대로 재사용한다. 
equals()에서 비교 조건에 사용되는 멤버가 단지 sn이기 때문이다. 


public class HashCodeTest {
	public static void testString() {
		Set<String> set = new HashSet<>();
		set.add(new String("Hello"));
		set.add(new String("Hello"));
		System.out.printf("set의 내용: %s%n", set);
	}
	// HashSet 타입의 객체를 만들고 두개의 String 객체를 추가한다. 
	//출력 결과는 언제나 Hello 하나의 문자열만 출력된다. 
	// 나머지 하나는 중복 데이터로 간주하기 때문이다. 
	
	public static void testProduct() {
		Set<Product> set = new HashSet<>();
		set.add(new Product("98765432109876543210"));
		set.add(new Product("98765432109876543210"));
		System.out.printf("set의 내용: %s%n", set);
	}
	// HashSet에 Product 타입의 객체 두개를 추가한다. 
	// 이 두객체는 같은 sn을 갖기 때문에 equals() 메서드의 결과는 true를 리턴한다. 
	//하지만 주석된 상태에서 실행해보면 두개의 Product가 추가된다. 
	// 주석해제후 실행하면 하나의 Product 정보만을 확인 할수 있다. 
	
	public static void main(String[] args) {
		testString();
		testProduct();
	}
}
// 
주석 해제 전 
set의 내용: [Hello]
set의 내용: [Product [sn=98765432109876543210], Product [sn=98765432109876543210]]


주석 해제 후
set의 내용: [Hello]
set의 내용: [Product [sn=98765432109876543210]]

이처럼 hashCode() 와 equals()는 언제나 상호 보완적으로 동작해야 한다. 
약간 귀찮을수 있는 이 두메서드의 오버라이딩은 
eclipse의 기능을 사용하면 아주 손쉽게 처리할수 있다. 

이클립스의 편집창에서 마우스 오른쪽 버튼을 클릭하여 표시되는 단축메뉴에서 
source-> generated hashCode() and equals() 메뉴를 클릭하면 
두 메서드를 자동으로 오버라이딩 해서 생성. 

----------------------------------------------------
1.3 clone() 메서드 

clone() 은 자신을 복제해서 새로운 객체를 생성하는 메서드이다. 
배열 같은 객체를 clone() 하게 되면 기존 객체를 그대로 둔 체 동일한 
구성의 객체를 하나 더 만들기 때문에 원본을 훼손하지 않고 다양한 
테스트를 진행할 수 있다. 

ex)
int [] intArr1 = {1, 2, 3, 4, 5};
int [] cloned = intArr1.clone();
for(int i : cloned) {
System.out.printf("%d\t", i); // 1 2 3 4 5 
}

clone() 메서드를 사용하기 위해서는 두가지 사실을 염두에 두어야 한다. 

먼저, Object에 있는 clone() 메서드는 protected 접근 제한자를 사용하기 때문에 
오버라이딩 하지 않고는 외부에서 호출할수는 없다. 
외부호출을 위해서는 clone()을 오버라이딩 하면서 public 으로 접근 제한자를 변경한다. 

ex)
protected native Object clone() throws CloneNotSupportedException;

둘째 clone()을 하기 위해서는 대상 객체가 Cloneable 인터페이스를 
구현하고 있어야 한다. 그렇지 않으면 
ClassNotSupportedException 이 던져진다. 
Cloneable은 별다른 메서드가 선언되어 있지 않기 때문에 단순히 
implements만해도 충분하다. 
이런 인터페이스를 마커 인터페이스라고 한다. 

ex)
package ch11.object;

import java.util.Arrays;

class Person implements Cloneable {
	String name;
	int age;
	int[] score;

	public Person(String name, int age, int[] score) {
		this.name = name;
		this.age = age;
		this.score = score;
	}

	@Override
	public String toString() {
		return "[name=" + name + ", age=" + age + ", score=" + Arrays.toString(score) + "]"+System.identityHashCode(name);
	}

	// String 과 int, int[] 멤버변수로 갖는 Person을 작성.
	// 이 클래스는 Clonable 인터페이스를 implements 하고 있음을 눈여겨보자. 
	//Person은 toString()과 clone()  메서드를 오버라이딩 하고 있다. 
	//Arrays 가 가진 toString() 메서드를 이용하면 배열을 문자열로 변환해서 
	//쉽게 내용을 출력가능. 
		
	@Override
	public Object clone() throws CloneNotSupportedException {
		Person cloned =  (Person)super.clone();
		cloned.score = this.score.clone();
		cloned.name = new String(this.name);
		return cloned;
	}
}

public class CustomCloneTest {
	public static void main(String[] args) throws CloneNotSupportedException {
		Person original = new Person("홍길동", 20, new int[] { 100, 90 });
		System.out.printf("원본: %s%n", original);
		Object cloned = original.clone();
		System.out.printf("복제품: %s%n", cloned);
		original.score[0] = 80;
		System.out.printf("복제품: %s%n", cloned);
		System.out.println(System.identityHashCode(original) + " : " + System.identityHashCode(cloned));
// Person 타입의 객체 original 을 생성 후 clone()메서드로 복제한다. 
//복제한 객체를 출력하면 최초 만들었던 original과 같은 내용으로 출력된다. 
// 두 객체의 해시코드를 출력해보면 다름을 알수있다. 
//참고로 Object의 hashCode()는 오버라이딩으로 변경이 가능하지만, 
//System의 identityHashCode()는 언제나 객체 고유의 해시 코드를 반환한다. 

		}
}

//
원본: [name=홍길동, age=20, score=[100, 90]]457233904
복제품: [name=홍길동, age=20, score=[100, 90]]245672235
복제품: [name=홍길동, age=20, score=[100, 90]]245672235
1012570586 : 1207140081

복제가 이뤄질때는 객체의 내용을 복사하는데 여기에는 얕은 복사(shallow copy)
와 깊은 복사(deep copy)가 있다. 얕은 복사는 단순히 객체가 가지는 기본형의 
값과 객체의 참조값만을 복사해서 복제본을 만든다. 
기본적으로 clone에서 사용하는 복사방식은 얕은 복사다. 
반면, 깊은 복사는 객체가 참조하는 객체의 내용까지 복사하는 것이다. 

ex2) 수정. 
package ch11.object;

import java.util.Arrays;

class Person implements Cloneable {
	String name;
	int age;
	int[] score;

	public Person(String name, int age, int[] score) {
		this.name = name;
		this.age = age;
		this.score = score;
	}

	@Override
	public String toString() {
		return "[name=" + name + ", age=" + age + ", score=" + Arrays.toString(score) + "]"+System.identityHashCode(name);
	}

	@Override
	public Object clone() throws CloneNotSupportedException {
return super.clone();
		//		Person cloned =  (Person)super.clone();
//		cloned.score = this.score.clone();
//		cloned.name = new String(this.name);
//		return cloned;
	}
}

public class CustomCloneTest {
	public static void main(String[] args) throws CloneNotSupportedException {
		Person original = new Person("홍길동", 20, new int[] { 100, 90 });
		System.out.printf("원본: %s%n", original);
		Object cloned = original.clone();
		System.out.printf("복제품1: %s%n", cloned);
		original.score[0] = 80;
		System.out.printf("복제품2: %s%n", cloned);
		System.out.println(System.identityHashCode(original) + " : " + System.identityHashCode(cloned));
	}
}
//
원본: [name=홍길동, age=20, score=[100, 90]]457233904
복제품1: [name=홍길동, age=20, score=[100, 90]]457233904
복제품2: [name=홍길동, age=20, score=[80, 90]]457233904
245672235 : 1012570586

달라진 내용은 원본인 original의 첫번째 score 항목을 80으로 변경하고 
다시 복제품을 출력하도록 33,34 행이 추가 되었다. 
그런데 결과로 출력된 복제품의 score의 첫 번째 항목이 80으로 
변경되었다. 바로 얕은 복사의 결과로 단순히 원본 객체에 대한 
레퍼런스 값만을 복사했기 때문이다. 

깊은 복사를 하려면 직접 객체의 내용을 복사해줘야 한다. 
위 예제의 clone 메서드를 깉은 복사를 이용하도록 오버라이딩 .

@Override
	public Object clone() throws CloneNotSupportedException {
		Person cloned =  (Person)super.clone();
		cloned.score = this.score.clone();
		cloned.name = new String(this.name);
	return cloned;
	}
실행 결과 
원본: [name=홍길동, age=20, score=[100, 90]]457233904
복제품1: [name=홍길동, age=20, score=[100, 90]]245672235
복제품2: [name=홍길동, age=20, score=[100, 90]]245672235
1012570586 : 1207140081

이제 출력 결과를 보면 원본의 score 를 변경하더라도 복제품의 
score 값이 변경되지 않았다. 

1.4 getClass() 메서드 
자바 애플리케이션이 실행될 때 JVM은 클래스 로더(class loader)
라는 것을 이용해서 '.class' 파일을 메모리에 읽어 들인 후 
'Class 타입의 객체'로 관리한다. 이 객체는 '.class' 별로 하나씩 
존재하는 메모리상의 원판이 된다. 
이후 new 키워드를 이용해서 객체를 만들 때 이 Class를 이용한다. 

ex) 
A.java ->(compile)-> A.class -> (class loader) -> 
(메모리공간) -> A Class   ,  A  a  = new A();

getClass() 메서드는 객체의 원판 Class에 대한 정보를 얻기 위한 메서드이다. 
Class를 통해서는 리플렉션(reflection) API를 사용할 수 있다. 
리플렉션 API는 일반 객체를 통해서 원본 객체의 정보를 획득하고, 
추가로 필요한 정보를 조회하는 과정을 지원하는 API이다. 
리플렉션 API는 자동화 툴이나 프레임워크의 내부를 작성할 때 주로 
사용되는데 자세한 내용은 자바 튜토리얼 문서 를 활용하고,
이 책에서는 자세한 설명은 생략. 

Class 타입 객체를 얻을때는 getClass() 메서드뿐만 아니라 Class 의 
static 속성인 class 를 이용할수도 있다. 

ex)
Class gctClass = gct.getClass();
Class gctClass2 = GetClassTest.class;

ex2)
package ch11.object;

public class GetClassTest {

	public void sayHello() {
		System.out.println("Hello");
	}
	
	public static void main(String[] args) throws Exception{
		GetClassTest gct = new GetClassTest();
		Class gctClass = gct.getClass();
		//getClass() 메서드를 이용해 gct의 원본 Class에 대한 객체를 얻는다. 
	
		System.out.println("이름: "+ gctClass.getName());
		System.out.println("메서드 개수: "+gctClass.getDeclaredMethods().length);
		
		Class gctClass2 = GetClassTest.class;
		gctClass.getDeclaredMethod("sayHello").invoke(gct);
		// Class가 제공하는 다양한 메서드를 이용해서 원본의 정보를 획득한다. 
		// getName()은 클래스 이름을 패키지 명을 포함해서 리턴. 
		//getDeclaredMethods()는 클래스에 선언된 모든 메서드의 정보를 
		//Method[] 타입으로 반환한다.
		// getDeclaredMethod()를 통해서 특정 이름의 메서드르 얻을수 있으며
		// Methhod가 제공하는 invoke 메서드를 이용해 호출할수 있다. 
	}
}

//
이름: ch11.object.GetClassTest
메서드 개수: 2
Hello

----------------------------------------------------
2. System 클래스 

System 클래스는 JVM이 실행되고 있는 운영체제(OS)와 소통을 
위한 클래스로 다양한 정적(static) 메서드를 제공한다. 

System 클래스의 주요 속성 

속성 명 : 선언부와 설명 
err : public static final PrintStream err 
에러를 출력하기 위한 표준출력 스트림 객체이다. 

in : public static final InputStream in
입력을 위한 표준 입력 스트림 

out : public static final PrintStream out 
출력을 위한 표준 출력 스트림 

System 클래스의 주요 메서드

arraycopy() : public static native void arraycopy(Object src, int srcPos,
Object dest, int desPos, int length)
src 배열의 srcPos부터 length 만큼을 dest 배열의 destPos 에 복사한다. 

currentTimeMillis() : public static native long currentTimeMillis()
시스템의 현재 시간을 ms 단위로 리턴한다. 

exit() : public static void exit(int status)
status 상태로 애플리케이션을 종료시킨다.

gc() : public static void gc()
G.C 의 동작을 요청한다. 

getenv() : public static java.util.Map<String,String> getenv()
:환경변수의 목록을 Map 타입으로 리턴한다.

public static String getenv(String name)
name에 해당하는 환경변수 값을 String으로 리턴한다. 

getProperties() : public static Properties getProperties()
시스템 속성을 Properties 타입으로 리턴한다. 

getProperty() : public static String getProperty(String key)
key 에 해당하는 시스템 속성의 값을 문자열로 리턴한다. 
만약 해당 값이 없으면 null을 리턴한다. 

public static String getProperty(String key, String def)
key에 해당하는 시스템 속성의 값을 문자열로 리턴한다. 
만약 해당 값이 없으면 def를 리턴한다. 

identityHashCode() : public static native int identityHashCode(Object x)
x 고유의 해시 코드 값을 리턴한다. 

lineSeparator() : public static String lineSeparator()
시스템 종속적인 행 구분자를 리턴한다. 유닉스 계열은 \n을,
윈도우 계열은 \r\n을 리턴한다. 

nanoTime() : public static native long nanoTime()
현재 시스템 시간을 나노초(1/10^9 초) 단위로 리턴한다.

setProperties() : public static void setProperties(Properties props)
props 로 시스템 속성을 설정한다.

setProperty() : public static String setProperty(String key, String value)
key에 해당하는 시스템 속성을 value로 설정한다. 

System 클래스의 API는 대략 5가지 부류로 구분할수 있다. 

----------------------------------------------------
2.1 시스템 I-O 사용 

System 클래스에서 제공되는 in 과 out 속성은 각각 
java.io.InputStream과 java.io.PrintStream 타입이다. 
InputStream은 키보드에서 사용자가 입력한 값을 받아들인다.
하지만, 직접 InputStream을 제어하기는 번거롭기 때문에
앞서 학습한 Scanner 를 이용하는 것이 일반적이다.
물론 Scanner를 생성할때 InputStream을 파라미터로 사용한다. 
PrintStream은 출력하고자 하는 내용을 콘솔을 통해 출력한다. 
출력을 위한 스트림으로 out 과 함께 err도 제공되는데 
err 는 주로 에러를 출력할때 사용되며 이클립스 콘솔에서 
빨간색으로 표시된다.

ex)
package ch11.system;

import java.util.Scanner;

public class BasicIO {

	public static void main(String[] args) {
		try (Scanner scanner = new Scanner(System.in)) {
			String str = scanner.nextLine();
			System.out.println("일반 출력: " + str);
			System.err.println("오류 출력: " + str);
		}
	}
}
// System.in 을 이용해서 Scanner를 생성한다. 
//Scanner 를 사용하고 close()를 호출하지 않으면 리소스 릭 
//(resource leak : 자원을 반납하지 않고 계속 점유해서 지속적으로 
//사용하다 보면 나중에 부족 현상이 발생함)이 발생한다. 
//try ~ with resource 문은 Closeable 인터페이스가 적용된 리소스에 
대해 사용 후 자동으로 close를 호출한다. 

//
서준아 안녕
오류 출력: 서준아 안녕  //빨간색으로 표시 
일반 출력: 서준아 안녕 // 하얀색으로 표시 

대부분 콘솔을 통한 출력을 제외하고는 System의 in 과 out
등을 직접 다루지 않고 다양한 I/O의 클래스들을 이용하는데 
이 부분은 후에 학습한다. 

----------------------------------------------------
2.2 프로그래밍의 종료와 G.C 권고 

System의 exit() 메서드는 JVM을 강제로 종료시키는 메서드이다.
이 메서드는 파라미터로 종료 상태를 나타내는 int 값을 받는데 관습적으로 
정상으로 종료할때는 0, 나머지 경우에 다른 정수를 사용한다. 

gc()는 시스템에게 G.C를 요청하는 메서드이다. 하지만 
이 메서드가 호출된다고 해서 쭉 G.C가 일어난다는 보장은 없다. 
사실 G.C는 JVM이 시스템 상황에 맞춰 자동으로 이뤄지기 때문에 
대부분 경우 프로그램에서 직접 호출할 일은 없다.
하지만 폭발적으로 가비지가 생기는 경우 등에서 명시적으로 호출을 
요청함으로써 빠른 메모리 회복을 유도할수 있다. 

ex)

package ch11.system;

import java.util.Scanner;

class Dummy {
	public Dummy() {
		System.out.println("dummy 객체 생성됨");
	}
	@Override
	protected void finalize() throws Throwable {
		System.out.println("dummy 객체 소멸됨");
	}
}

public class ProcessManageTest {
	public static void main(String[] args) {
		try (Scanner scanner = new Scanner(System.in)) {
			while (true) {
				System.out.println("명령을 입력하세요: C, G, X");
				String readLine = scanner.nextLine();
				if(readLine.equals("C")) {
					new Dummy();
				}else if(readLine.equals("G")) {
					System.gc();
				}else if(readLine.equals("X")) {
					System.exit(0);
				}
			}
		}
	}
}

//
명령을 입력하세요: C, G, X
C
dummy 객체 생성됨
명령을 입력하세요: C, G, X
G
명령을 입력하세요: C, G, X
dummy 객체 소멸됨
X


----------------------------------------------------
2.3 현재의 시각 정보 획득 

종종 작성한 애플리케이션의 성능을 체크하기 위해 소요시간을 
계산할 필요가 있다. System이 제공하는 currentTimeMillis()는 
현재 시각을 밀리세컨드(1/1000초) 단위의 long 값으로 리턴한다. 
nanoTime()는 현재 시각을 나노세컨드(1/10^9초) 단위의 long 값
으로 리턴한다. 

ex)

package ch11.system;

public class SystemClockTest {
	public static void main(String[] args) {
		long start = System.nanoTime();
		int num = 20;
		long result = getFactorial(num);
		System.out.println(num+"!은 "+result+"입니다.");
		long end = System.nanoTime();
		System.out.println("총 소요 시간(nanosec): "+(end - start));
	}
	public static long getFactorial(long num) {
		if(num==1) {
			return num;
		}else {
			return num * getFactorial(num-1);
		}
	}
}
//
20!은 2432902008176640000입니다.
총 소요 시간(nanosec): 436600

----------------------------------------------------
2.4 시스템 속성 및 환경변수 참조 

시스템 속성(System Property)은 JVM이 시작할때 OS로 부터 얻어오는 값이다.
여기에는 OS 종류, JDK 설치경로, 사용자 계정, 사용자 임시 디렉터리 경로 
등의 정보가 들어있다. 
이 시스템 속성이 중요한 이유는 OS의 종류를 가리지 않는 플랫폼 독립적인 
프로그램을 작성하기 위해서이다.
예) 임시 경로에 파일을 저장하도록 프로그램을 작성한다고 했을때 ,
경로명 "C:\Users\andy\AppData\Local\Temp\" 를 하드코딩(소스코드에
그대로 적음)하면 리눅스 시스템에서는 오동작할 것이다. 
리눅스에서는 '/tmp' 가 기본값으로 사용되는 임시경로이다. 
이런 값을 System 속성을 통해서 가져온다면(java.io.tmpdir)
OS가 바뀌더라도 OS가 제공해주는 값을 사용할수 있다.

자주 사용되는 시스템 속성은 다음과 같다. 

속성 명(키) : 설명 : 값예시 (windows 10 기준)
user.country : OS 로케일 정보 : KR 

java.io.tmpdir : 임시경로 : c:\Users\사용자_명AppData\Local\Temp\

line.separator : 행 분리 구분자 : \n\r 

user.home : 사용자 홈 경로 : c:\Users\사용자_명 

file.separator : 파일 경로 구분자 : \

System이 제공하는 getProperties() 메서드는 모든 시스템 속성들을
키-값의 쌍으로 데이터를 저장하는 java.util.Properties 형태로 
반환한다. 또는 getProperty() 메서드에 속성 이름 즉 키를 넘겨주면 
해당하는 값을 반환한다. 

환경변수는 OS에 설치된 프로그램들에게 제공할 목적으로 설정하는 값이다.
Windows 의 경우 [제어판]-[시스템]-[고급 시스템 설정]-[환경변수]-[시스템변수]
에서 확인/추가/수정/삭제 할수있다.

환경변수를 사용하는 방법은 시스템 속성을 사용하는 방법과 아주 유사하다.
일단 getenv() 메서드는 java.util.Map 타입을 반환한다. 
Map 은 Property와 유사하게 키-값 형태의 쌍으로 데이터를 저장한다.
또한 getenv()에 파라미터로 키를 전달하면 연결된 값을 반환한다. 

ex)
package ch11.system;

import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class PropertyTest {

	public static void main(String[] args) {
		Properties props = System.getProperties();
		Set<Object> keys = props.keySet();
		for(Object key: keys) {
			System.out.printf("key: %s, value: %s%n", key, props.get(key));
		}
		String ls = System.getProperty("java.io.tmpdir");
		System.out.println("사용자 임시 디렉토리 경로: "+ls);
		
		Map<String, String> envs = System.getenv();
		Set<String> envKeys = envs.keySet();
		for(String key: envKeys) {
			System.out.printf("key: %s, value: %s%n", key, envs.get(key));
		}
		String userName = System.getenv("USERNAME");
		System.out.println("사용자 명: "+userName);
	}
}
//
key: sun.desktop, value: windows
key: awt.toolkit, value: sun.awt.windows.WToolkit
key: java.specification.version, value: 11
key: sun.cpu.isalist, value: amd64
key: sun.jnu.encoding, value: MS949
key: java.class.path, value: C:\Users\pc\git\java-kame\target\classes
key: java.vm.vendor, value: Oracle Corporation
key: sun.arch.data.model, value: 64
key: user.variant, value: 
key: java.vendor.url, value: http://java.oracle.com/
key: user.timezone, value: 
key: os.name, value: Windows 10
key: java.vm.specification.version, value: 11
key: sun.java.launcher, value: SUN_STANDARD
key: user.country, value: KR
key: sun.boot.library.path, value: C:\Program Files\Java\jdk-11.0.2\bin
key: sun.java.command, value: ch11.system.PropertyTest
key: jdk.debug, value: release
key: sun.cpu.endian, value: little
key: user.home, value: C:\Users\pc
key: user.language, value: ko
key: java.specification.vendor, value: Oracle Corporation
key: java.version.date, value: 2019-01-15
key: java.home, value: C:\Program Files\Java\jdk-11.0.2
key: file.separator, value: \
key: java.vm.compressedOopsMode, value: Zero based
key: line.separator, value: 

key: java.specification.name, value: Java Platform API Specification
key: java.vm.specification.vendor, value: Oracle Corporation
key: java.awt.graphicsenv, value: sun.awt.Win32GraphicsEnvironment
key: user.script, value: 
key: sun.management.compiler, value: HotSpot 64-Bit Tiered Compilers
key: java.runtime.version, value: 11.0.2+9-LTS
key: user.name, value: pc
key: path.separator, value: ;
key: os.version, value: 10.0
key: java.runtime.name, value: Java(TM) SE Runtime Environment
key: file.encoding, value: UTF-8
key: java.vm.name, value: Java HotSpot(TM) 64-Bit Server VM
key: java.vendor.version, value: 18.9
key: java.vendor.url.bug, value: http://bugreport.java.com/bugreport/
key: java.io.tmpdir, value: C:\Users\pc\AppData\Local\Temp\
key: java.version, value: 11.0.2
key: user.dir, value: C:\Users\pc\git\java-kame
key: os.arch, value: amd64
key: java.vm.specification.name, value: Java Virtual Machine Specification
key: java.awt.printerjob, value: sun.awt.windows.WPrinterJob
key: sun.os.patch.level, value: 
key: java.library.path, value: C:\Program Files\Java\jdk-11.0.2\bin;C:\WINDOWS\Sun\Java\bin;C:\WINDOWS\system32;C:\WINDOWS;C:/Program Files/Java/jre1.8.0_60/bin/server;C:/Program Files/Java/jre1.8.0_60/bin;C:/Program Files/Java/jre1.8.0_60/lib/amd64;C:\Program Files (x86)\NetSarang\Xshell 6\;C:\Program Files\Java\jdk-11.0.2\bin;C:\ProgramData\Oracle\Java\javapath;C:\NewGen\Rebirth\Dll;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\PuTTY\;C:\Program Files\TortoiseGit\bin;C:\Program Files\Git\cmd;C:\Users\pc\AppData\Local\Microsoft\WindowsApps;C:\Program Files\Bandizip\;C:\Users\pc\Desktop;;.
key: java.vendor, value: Oracle Corporation
key: java.vm.info, value: mixed mode
key: java.vm.version, value: 11.0.2+9-LTS
key: sun.io.unicode.encoding, value: UnicodeLittle
key: java.class.version, value: 55.0
사용자 임시 디렉토리 경로: C:\Users\pc\AppData\Local\Temp\
key: configsetroot, value: C:\WINDOWS\ConfigSetRoot
key: USERDOMAIN_ROAMINGPROFILE, value: DESKTOP-DTHLEPU
key: LOCALAPPDATA, value: C:\Users\pc\AppData\Local
key: PROCESSOR_LEVEL, value: 6
key: USERDOMAIN, value: DESKTOP-DTHLEPU
key: FPS_BROWSER_APP_PROFILE_String, value: Internet Explorer
key: LOGONSERVER, value: \\DESKTOP-DTHLEPU
key: JAVA_HOME, value: C:\Program Files\Java\jdk-11.0.2
key: SESSIONNAME, value: Console
key: ALLUSERSPROFILE, value: C:\ProgramData
key: PROCESSOR_ARCHITECTURE, value: AMD64
key: PSModulePath, value: C:\Program Files\WindowsPowerShell\Modules;C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules;C:\Program Files\Intel\
key: SystemDrive, value: C:
key: OneDrive, value: C:\Users\pc\OneDrive
key: APPDATA, value: C:\Users\pc\AppData\Roaming
key: USERNAME, value: pc
key: ProgramFiles(x86), value: C:\Program Files (x86)
key: VBOX_MSI_INSTALL_PATH, value: C:\Program Files\Oracle\VirtualBox\
key: CommonProgramFiles, value: C:\Program Files\Common Files
key: Path, value: C:/Program Files/Java/jre1.8.0_60/bin/server;C:/Program Files/Java/jre1.8.0_60/bin;C:/Program Files/Java/jre1.8.0_60/lib/amd64;C:\Program Files (x86)\NetSarang\Xshell 6\;C:\Program Files\Java\jdk-11.0.2\bin;C:\ProgramData\Oracle\Java\javapath;C:\NewGen\Rebirth\Dll;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\PuTTY\;C:\Program Files\TortoiseGit\bin;C:\Program Files\Git\cmd;C:\Users\pc\AppData\Local\Microsoft\WindowsApps;C:\Program Files\Bandizip\;C:\Users\pc\Desktop;
key: FPS_BROWSER_USER_PROFILE_String, value: Default
key: PATHEXT, value: .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC
key: DriverData, value: C:\Windows\System32\Drivers\DriverData
key: OS, value: Windows_NT
key: COMPUTERNAME, value: DESKTOP-DTHLEPU
key: CATALINA_HOME, value: C:\apache-tomcat-8.0.48
key: PROCESSOR_REVISION, value: 9e09
key: CLASSPATH, value: C:\Program Files\Java\jdk-11.0.2\lib;.;
key: CommonProgramW6432, value: C:\Program Files\Common Files
key: ComSpec, value: C:\WINDOWS\system32\cmd.exe
key: ProgramData, value: C:\ProgramData
key: ProgramW6432, value: C:\Program Files
key: HOMEPATH, value: \Users\pc
key: SystemRoot, value: C:\WINDOWS
key: TEMP, value: C:\Users\pc\AppData\Local\Temp
key: HOMEDRIVE, value: C:
key: PROCESSOR_IDENTIFIER, value: Intel64 Family 6 Model 158 Stepping 9, GenuineIntel
key: USERPROFILE, value: C:\Users\pc
key: TMP, value: C:\Users\pc\AppData\Local\Temp
key: CommonProgramFiles(x86), value: C:\Program Files (x86)\Common Files
key: ProgramFiles, value: C:\Program Files
key: PUBLIC, value: C:\Users\Public
key: NUMBER_OF_PROCESSORS, value: 4
key: windir, value: C:\WINDOWS
key: =::, value: ::\
사용자 명: pc


----------------------------------------------------
3. String 클래스 

3.1 String 클래스의 특징과 객체 생성 

String 클래스는 아마도 프로그램을 작성하면서 가장 많이 사용되는 
클래스일 것이다. 그만큼 정확한 사용법을 숙지하는 것이 중요하다.

다음은 String이 갖는 기본적인 특징.

(1) String은 final 클래스이다. 따라서 상속을 받아서 수정할수 없다. 
(2) String은 내부적으로 char[] 배열을 만들어 데이터를 저장한다. 
우리가 직접 배열을 만들고 사용하기는 번거롭기 때문에 
String이라는 클래스를 만들어서 편하게 쓸수 있게 해주었다. 
(3) String은 생성자를 사용하지 않고 바로 ""로 둘러싼 문자열을 
할당할 수 있다. 

String 타입의 객체를 만들때 new 키워드를 이용할수도 있고 단순히 
문자열을 할당할수도 있다. 두가지 방법은 메모리 차원에서 상당히 
큰 차이가 있다. 
new 를 이용했을때는 글자 그대로 힙(heap) 공간에 새로운 문자열을 
만든다. 하지만, new 를 사용하지 않았을 때는 상수 저장공간에
(Constant Pool)에 저장한다.

상수 저장공간에 문자열을 만들때는 먼저 상수 저장공간에 같은 
내용의 문자열이 있는지 확인하여, 같은 문자열이 있다면 
해당 문자열을 반환하고 , 같은 문자열이 없다면 새로 만든다. 
따라서 특수한 목적이 아니라면 가급적 new 키워드 없이 만드는 것이
메모리 절약에 유리하다. 

ex)
package ch11.String;

public class NewStringTest {
	public static void main(String[] args) {
	    String s1 = "Hello";
	    String s2 = "Hello";
	    System.out.println("== 연산 결과 : "+(s1==s2?"==같음":"다름"));
	    System.out.println("equals 연산 결과 : "+(s1.equals(s2)?"같음":"다름"));

		//new 키워드를 사용하지 않고 두개의 문자열을 사용한다. String 클래스는 
		//문자열의 내용을 비교하도록 equals() 메서드가 오버라이딩 되어 있기때문에 
		//equals()는 물론 참조값을 비교하는 == 연산의 결과까지 true로 판단된다. 
		
	    String s3 = new String("Hello");
	    String s4 = new String("Hello");
	    System.out.println("== 연산 결과 : "+(s3==s4?"==같음":"다름"));
	    System.out.println("equals 연산 결과 : "+(s3.equals(s4)?"같음":"다름"));
		// new 키워드를 사용해서 두개의 문자열을 생성한다. equals()는 true를 
		// 반환하지만 , == 연산의 결과는 false이다. 새로운 객체이기 때문이다.
	}
}
//
== 연산 결과 : ==같음
equals 연산 결과 : 같음
== 연산 결과 : 다름
equals 연산 결과 : 같음

String의 또하나 중요한 특징은 불변성(Immutable) 클래스이다.
이 말은 일단 생성 후 변경이 불가능하다는 이야기다. 우리는 이제까지 
문자열을 출력할 때 '+' 연산자를 이용해서 문자열을 결합해왔다. 
다음 문장 

ex)
String a = "Hello" + "Java" + "World!";

결과로 a에 할당된 문자열은 "HelloJavaWorld!"이다. 하지만,
이 과정에서 최초에 "Hello"라는 문자열이 있었고 여기에 
"Java"가 더해지는 것이 아니라 " Hello"와 "Java" 는 그대로 있고 
"HelloJava"가 새로 생성된다. 
물론 여기에 "World"가 더해지는 과정도 마찬가지다.
결과적으로 메모리에 생성된 문자열은 "Hello","Java","HelloJava",
"World", "HelloJavaWorld!"로 5개이다. 
무심코 연결한 문자열이 메모리를 심각하게 낭비할수 있다는 점을 주의하자.
맨 마지막에 사용되는 문자열 "HelloJavaWorld!" 이외의 나머지 4개는 
G.C의 대상이다. 

ex)
0x100 : Hello , 0x200 : Java 
0x300 : HelloJava
0x400 : World
0x500 : HelloJavaWorld
a --> 0x500 

ex2)
 package ch11.String;

public class ImmutableClass {

	public static void main(String[] args) {
		String a = "a";
		System.out.println(System.identityHashCode(a));
		a = a + "b";
		System.out.println(System.identityHashCode(a));
		System.out.println(a);
	}
}
// 출력값은 실행시 마다 달라짐 
125130493
914504136
ab

따라서 문자열의 결합 연산에는 가급적 String 보다는 뒤에 
언급할 StringBuffer 나 StringBuilder 를 활용하는 것이 좋다. 

----------------------------------------------------
3.2 주요 메서드

String 클래스에는 검색, 분리, 추출, 변환, 비교 등 다양한 메서드를 
가지고 있다. 그중 자주 사용되는 메서드를 알아보자. 
String의 메서드 들은 인덱스(index)를 자주 사용한다. 
앞서 String은 char[]로 데이터를 저장한다고 했는데 바로 그 배열에서의 
인덱스이다.
따라서 인덱스의 범위는 0부터 문자열의 길이 -1 까지만 사용할수 있다.

String 클래스의 주요 메서드

메서드 명 : 선언부 와 설명 

length() : public int length()
주어진 문자열의 길이를 리턴한다.

charAt() : public char charAt(int index)
index에 해당하는 문자를 리턴한다.

indexOf() : public int indexOf(int ch)
문자열 내에서 ch의 index를 리턴한다. 없을 경우는 -1을 리턴한다.

equals() : public boolean equals(Object abObject)
abObject와 문자열의 내용을 비교해서 결과를 리턴한다.

equalsIgnoreCase() : public boolean equalsIgnoreCase(String anotherString)
대소문자의 구별 없이 anotherString과 문자열의 내용이 같은지 리턴한다. 

replace() : public String replace(char oldChar, char newChar)
문자열에서 oldChar를 찾아서 newChar로 변경된 새로운 문자열을 리턴한다.

subString() : public String subString(int beginindex, int endindex)
문자열의 beginindex에서 endindex 앞까지 잘라서 리턴한다

split() : public String[] split(String regex)
문자열을 주어진 정규표현식으로 나눈 후 배열에 담아서 리턴한다

(1) 문자열의 길이 
length()는 문자열의 길이를 리턴한다. 이 길이는 내부적으로 문자열을 
저장하는 char[]의 length이다. 

ex)
String str = "Hello";
System.out.println(str.length());

(2) 특정 인덱스의 문자 또는 특정 문자의 위치 조회 
charAt(int index)은 특정 위치 즉 index에 있는 문자를 리턴한다.
이때 index 의 범위는 ' 0 <= index <= 문자열의 길이 -1' 이다. 
이 범위를 벗어나는 경우 IndexOutOfBoundsException이 발생한다.

indexOf(char ch)는 특정 문자가 처음 등장하는 위치를 반환하는데 
만약 String에 원하는 문자가 포함되지 않은 경우는 -1을 리턴한다. 

주민등록번호에서 남성과 여성을 파악하거나 이메일 주소에서 
'@'와 '.'의 위치를 파악해서 형식에 맞는지 확인해보자.

ex)
package ch11.String;

public class UseIndex {
	public static void main(String[] args) {
		String ssn = "000518-3111111";
		char gender = ssn.charAt(7);	// -다음의 문자 추출
		if(gender=='1' || gender=='3') {
			System.out.println("남성입니다.");
		}else if(gender=='2' || gender=='4') {
			System.out.println("여성입니다.");
		}else {
			System.out.println("주민등록번호의 형식이 잘못되었습니다.");
		}
		
		String email = "abc@gmail,com";
		if(email.indexOf('@')<0 || email.indexOf('.')<0){
			System.out.println("잘못된 이메일 형식입니다.");
		}
	}
}
//
남성입니다.
잘못된 이메일 형식입니다.

(3)문자열의 내용 비교 
String은 문자열의 내용을 비교하도록 equals()를 오버라이딩해 놓았다.
추가로 equalsIgnoreCase() 대소문자의 구분 없이 내용이 같은지를 비교한다. 

ex)
package ch11.String;

public class EqualsTest {
	public static void main(String[] args) {
		String str = "Hello";
		System.out.println("hello".equals(str));
		System.out.println("hello".equalsIgnoreCase(str));
		
		String nullStr = null;
		//System.out.println(nullStr.equals("some")); // NullPointerException 발생 가능
		System.out.println("some".equals(nullStr)); // NullPointerException 발생 없음
	}
}
//
false
true
false

위 소스 코드를 보면 "hello".equals()와 같은 형식의 코드가 약간 
낯설다. String 클래스의 메서드를 사용할 때 자주 사용되는 패턴으로 
NullPointerException 을 미리 예방할수있는 작은 패턴이다.

ex)
System.out.println(nullStr.equals("some")); // NullPointerException 발생 가능
System.out.println("some".equals(nullStr)); // NullPointerException 발생 없음

(4)문자열 대체와 추출 
replace()는 기존 문자열에서 특정 문자열을 찾아 원하는 문자열로 대체해서 
리턴한다. String은 불변성을 가지고 있으므로 변경된 문자열은 기존 문자열과는
다른 새로운 문자열일 것이다. subString()은 인덱스를 이용해 문자열의 
특정 부분을 잘라내서 리턴한다.

전화번호의 맨 뒤의 4자리를 '*'로 대체해서 출력해보자. 

ex)
package ch11.String;

public class MaskingTest {
	public static void main(String[] args) {
		String hp = "010-1234-5678";
		String last4 = hp.subString(9, hp.length());
		System.out.println("추출된 문자열: "+last4);
		String masked = hp.replace(last4, "****");
		System.out.println(masked);
	}
}
//
추출된 문자열: 5678
010-1234-****

(5)문자열 앞뒤의 공백 제거
사용자로부터 입력받은 문자열을 비교하다 보면 우연히 추가된 공백 
때문에 다른 문자로 파악되는 경우가 종종 있다. 
이때 trim() 메서드를 사용하면 문자열 앞, 뒤의 공백을 제거해준다.
이때 제거되는 공백은 단순히 스페이스 바에 의한 공백뿐만 아니라 탭 문자 
(\t)나 줄 바꿈 문자(\n)를 포함한다. 

ex)

package ch11.String;

public class TrimTest {
	public static void main(String[] args) {
		String helloWithWhiteSpace="\tHello \n";
		System.out.println("Hello".equals(helloWithWhiteSpace));
		System.out.println("Hello".equals(helloWithWhiteSpace.trim()));
	}
}
//
false
true

(6)정규표현식의 활용 
정규표현식(regular expression)이란 특정한 규칙을 갖는 문자열의 집합을 
표현하는데 사용되는 형식 언어이다. 예를들어 이메일이나 전화번호가 형식에 
맞는지, 비밀번호의 복잡도는 원하는 수준인지 등을 파악할때 정규표현식이 
사용된다. 정규표현식에 대한 내용은 12장에서 다룬다. 

정규표현식을 사용하는 대표적인 메서드들은  split()이나 matches()가 있다. 
두함수 모두 정규표현식을 파라미터로 받는다. 
split()이나 matches()가 있다. 두함수 모두 정규표현식을 파라미터로 받는다.
split()는 정규표현식에 해당하는 문자들을 구분자로 해서 원본 문자열을 쪼개고 
배열로 리턴한다. matches()는 원본 문자열이 정규표현식에 부합하는지를 
리턴한다.

ex)
package ch11.String;

public class RegexpTest {

	public static void main(String[] args) {
		String str =  "Hello Java World";
		String [] splitResult = str.split("[a ]");
		
		//split()에 사용된 정규표현식 [a ]는 a 또는 공백을 의미한다. 
		// 따라서 이 split()은 원본인 str에서 a 또는 공백을 만나면 
		// 그 자리에서 문자열을 쪼개서 배열의 원소로 만든후 배열을 
		// 리턴한다. 
		
		for(int i=0; i<splitResult.length; i++) {
			System.out.println(i+" : "+splitResult[i]);
		}
		String nameRule = "[a-zA-Z가-힣]{2,5}";
		// 알파벳 대/소문자와 한글을 포함해서 2~5글자가 있어야 한다는 의미.
		
		System.out.println("Hello Java".matches(nameRule));
		//공백 있어서 탈락
		
		System.out.println("홍길동".matches(nameRule));
		System.out.println("홍길동2".matches(nameRule));
		// 숫자가 들어가서 탈락
	}
}
//
0 : Hello
1 : J
2 : v
3 : 
4 : World
false
true
false


----------------------------------------------------
4. StringBuffer 와 StringBuilder 클래스 

4.1 특징과 객체 생성 

String 클래스는 불변성 클래스이기 때문에 생성하고 읽고 
사용하는 용도로 문자열을 이용한 연산에는 제약이 많다. 
문자열을 이용한 연산에 적합한 클래스는 StringBuffer 나 
StringBuffer가 있다. 

이 두 클래스의 특성은 다음과 같다. 

(1)String 과는 상속 관계가 없다.
(2)내부적으로 버퍼(buffer : 데이터를 임시로 저장하는 공간으로 배열)에 
문자열을 저장하고 그 안에서 추가/수정/삭제 작업을 가능하게 한다. 
(3)연산 과정에서 새로운 객체를 생성하지 않는다. 
(4) toString() 메서드는 내용 문자열을 출력하도록 오버라이딩 되었다. 
(5) equals() 메서드는 오버라이딩되지 않아서 Object의 equals를 
그대로 사용한다. 

두가지 클래스의 사용법은 거의 유사하며 차이점은 StringBuffer는 
멀티스레드에서 안전하므로 무겁고, StringBuilder는 반대다. 
멀티스레드 관련된 내용은 14장에서 다룬다. 
예제에서는 StringBuilder를 이용해보자. 

StringBuilder는 다양한 생성자를 갖는데 생성되는 기본 버퍼의 
크기를 설정하는 방식이 각각 다르다. 

StringBuilder의 생성자 목록 

생성자 명 : 선언부와 설명 

StringBuilder()

(1)public StringBuilder()
capacity 가 16인 용량의 버퍼를 가진 StringBuilder를 생성한다. 

(2)public StringBuilder(int capacity)
capacity 만큼 용량의 버퍼를 가진 StringBuilder를 생성한다. 

(3)public StringBuilder(String str)
초기에 str을 포함한 StringBuilder를 생성한다.
이 객체는 str.length() + 16만큼 크기를 갖는 버퍼를 내장한다. 

(4)public StringBuilder(CharSequence seq)
초기에 seq을 포함한 StringBuilder를 생성한다. 
이 객체는 seq.length() + 16 만큼 크기를 갖는 버퍼를 내장한다. 

버퍼는 배열이기 때문에 한번 크기가 정해지면 더 많은 데이터를 
저장하기 위해서는 새로운 배열을 만들고 기존 값을 복사한 후 
사용해야 한다. StringBuffer나 StringBuilder는 내부적으로
System.arraycopy() 메서드를 사용한다. 
버퍼의 크기를 너무 작게 가져가면 데이터가 늘어날때 자주 
arraycopy() 를 수행해야 하므로 프로세스가 바빠진다.
반면, 버퍼를 미리 너무 크게 가져가면 사용하지 않는 메모리 
공간이 그만큼 늘어난다.

ex)
public StringBuilder() {
super(16);
}
public StringBuilder(int capacity) {
super(capacity);
}
public StringBuilder(String str) {
super(str.length() + 16);
append(str);
}

위의 예에서 기본생성자를 통해서 만드는 버퍼의 크기는 16이다.
또는 2번째 생성자처럼 초기 버퍼의 크기를 capacity를 통해 
지정할수 있다. 3번째 생성자는 문자열을 넘겨주면 문자열의 
길이 + 16만큼의 크기로 버퍼를 잡는다. 이후 처리할 문자열의 
길이가 버퍼의 길이를 넘어갈 때 마다 ( 기존 크기 * 2 + 1)의 
크기로 새로운 버퍼를 만들고 
System.arraycopy()로 기존 값을 복제해서 사용한다.
따라서 문자열의 길이를 예상할수 있다면 2번째 생성자처럼 
크기를 미리 지정하고 사용하는 것이 좋다. 

ex)
package ch11.Stringbuilder;

public class StringBuilderTest {

	public static void main(String[] args) {
		StringBuilder builder = new StringBuilder("Hello");
		//문자열 "Hello"를 이용해 StringBuilder를 생성한다.
		// '문자열 길이'+ 16의 크기만큼의 버퍼를 가지는 
		// StringBuilder가 생성된다. 
		
		System.out.println("buffer 크기: "+builder.capacity());
		// capacity는 버퍼의 크기를 리턴한다. 6행의 결과로 21이 출력.
		
		System.out.println("문자열 길이: "+builder.length());
		// length 는 순수한 문자열의 길이를 리턴한다.
	}
}
//
buffer 크기: 21
문자열 길이: 5


----------------------------------------------------
4.2 문자열 편집을 위한 주요 메서드

StringBuilder 또는 StringBuffer에는 문자열을 편집할수 있는 다양한 메서드를 
제공한다. 

StringBuilder의 주요 메서드 

메서드 명 : 선언부와설명

indexOf() : public int indexOf(String str)
StringBuilder의 버퍼에서 str의 시작 인덱스를 반환한다.

append() : public StringBuilder append(P# param)
현재 버퍼의 맨 뒤에 param을 추가한 후 리턴한다. 

delete() : public StringBuffer delete(int start , int end)
버퍼에서 start에서 end 사이의 인덱스에 있는 값을 삭제 후 리턴한다. 

deleteCharAt() : public StringBuilder deleteCharAt(int index)
버퍼에서 index에 있는 문자를 삭제 후 리턴한다. 

insert() : public StringBuilder insert(int offset, P# param)
버퍼의 offset 위치에 param을 추가한후 리턴한다.

replace() : public StringBuilder replace(int start , int end, String str)
버퍼의 start <= x < end 사이의 값을 str로 변경한 후 리턴한다. 

toString() : public String toString()
버퍼의 내용을 문자열로 리턴한다. 

참고 
P# : Object, String, StringBuffer, CharSequence, Char[], boolean
, char, int, long, float, double 이 올수 있다. 

ex) 
StringBuilder alphabet = new StringBuilder("A");
alphabet.append("B");
alphabet.append("C");

alphabet.append("D").append("E");

"B" , "C" 를 추가하는 코드보다는 "D" , "E"를 추가하는 코드가 
훨씬 편리하다. 이런식으로 메서드의 리턴 타입이 자기 자신을 리턴하고,
계속 연결해서 다음 메서드를 호출하는 형태의 프로그래밍 방식을 
빌더 패턴(Builder Pattern)이라고 한다. 

다음은 지하철 노선을 작성하는 과정이다. 
최종 결과물은 '사봉-용산-사가정-용마산'이다. 
어떤 과정을 거쳐 값을 수정하는지 살펴보자. 

ex)

package ch11.Stringbuilder;

public class StringBuiderMethodTest {
	public static void main(String[] args) {
		StringBuilder builder = new StringBuilder("사봉-용산-사가정-용마산");
		builder.append("-중곡");	// 맨 뒤에 -중곡 추가
		System.out.println(builder);
		builder.insert(3, "면목-");	// 사봉-뒤에 면목-추가
		System.out.println(builder);
		builder.delete(5, 8);		// -용산 삭제
		System.out.println(builder);
		builder.replace(0, 1, "상");// 사를 상으로 변경
		System.out.println(builder);	
	}
}
//
사봉-용산-사가정-용마산-중곡
사봉-면목-용산-사가정-용마산-중곡
사봉-면목-사가정-용마산-중곡
상봉-면목-사가정-용마산-중곡


----------------------------------------------------
5. Math 클래스

5.1 특징 

Math 클래스는 수학 계산에 필요한 메서드를 가지는 클래스로 
String 클래스와 마찬가지로 final 클래스이다. 
따라서 상속을 받거나 메서드를 오버라이딩 할수없다.
또한, 클래스의 모든 멤버가 static으로 선언되어 있으므로
사용을 위해 별도로 객체를 만들 필요가 없다.

----------------------------------------------------
5.2 주요 메서드

Math에는 우리가 이제까지 배웠던 대부분의 수학 공식들이 
포함되어 있다. 

메서드명 : 선언부와 설명 
abs() : public static double abs(p# a)
숫자형 타입 a에 대해 절대값을 리턴한다.

ceil() : public static double ceil(double a)
a 의 올림 값을 double로 리턴한다

floor() : public static double floor(double a)
a 의 올림 값을 double로 리턴한다

max() : public static float max(p# a, p# b)
a와 b 중 큰 값을 리턴한다

min() : public static int min(p# a, p# b)
a와 b 중 작은 값을 리턴한다

random() : public static double random()
0.0 <= x < 1.0 사이의 double 값을 무작위로 리턴한다.

round() : public static long round(double a)
소수점 첫째 자리에서 반올림한 정수값을 리턴한다.

addExact() : public static int addExact(int x, int y)
x와 y의 정확한 합을 리턴한다. 만약 오버플로가 발생할 경우
ArithmeticException이 발생한다.

subtractExact() : public static int subtractExact(int x, int y)
x와 y의 정확한 차를 리턴한다. 만약 오버플로가 발생할 경우
ArithmeticException이 발생한다.

multiplyExact() : public static int multiplyExact(int x, int y)
x와 y의 정확한 곱을 리턴한다. 만약 오버플로가 발생할 경우
ArithmeticException이 발생한다.

p# 는 int, long, float, double을 의미한다

대부분 수학 연산자의 의미는 수학 공식 그대로 이므로 
사용법은 생략.
대신 활용도가 높은 random() 과 round()는 예제를 통해 자세히 
알아보자. 

(1) random()

random() 은 0 <= x <1 인 무작위의 double 값을 반환한다.
주사위를 던져서 무작위의 수가 나오는 경우를 생각해보자.
주사위는 1~6 까지의 정수가 표시되는데 random() 함수를 이용해서 
어떻게 주사위의 숫자를 표현 할수 있을까?

방법은 간단. 숫자를 만들어가면 된다. random()에 6을 곱하면 
0 <= x <6 인 double 값이 나올 것이다. 이 숫자를 정수로 형변환 하면 
0 <= x <= 5인 정수이다. 여기에 마지막으로 1을 더하면 원하는
1 <= x <= 6인 정수가 된다. 

ex)
package ch11.math;

import java.util.Random;

class MyDice {
	public int nextNum() {
		return (int) (Math.random() * 6) + 1;
		// Math.random() 함수를 이용해 1<= x <= 6 인 정수를 생성하고 
		// 리턴한다
	}
}
public class MyDiceTest {
	public static void main(String[] args) {
		MyDice dice = new MyDice();
		System.out.println(dice.nextNum());
	}
}

class YourDice{
	public int nextNum() {
		Random random = new Random();
		return random.nextInt(6)+1;
	}
}
// 실행할 때마다 다른 값이 된다. 

3

이런 과정이 약간 번거로운데 java.util.Random 클래스를 사용하면 
훨씬 손쉽게 처리할수 있다. Random 클래스가 제공하는 nextInt(int bound)
는 0부터 bound 까지의 무작위 정수를 리턴한다.
따라서 주사위를 만든다면 nextInt(6) + 1을 사용할수 있다.

import java.util.Random;

class YourDice{
	public int nextNum() {
		Random random = new Random();
		return random.nextInt(6)+1;
	}
}

(2) round()
round()는 숫자를 반올림하는 함수이다. Math 의 round()는 
double 타입의 파라미터를 소수점 첫째 자리에서 반올림해서 정수로 
리턴한다. 즉 '소수점 둘째 자리에서 반올림하라'와 같은 
요청사항을 처리할수 없다. 원하는 자리에서 반올림 처리하기 위해서는
반올림할 자릿수가 소수점 첫째 자리가 되도록 10^n 숫자를 곱해서 
반올림한 후 다시 10^n.0 으로 나누어야한다. 

다음 예 10.45를 소수점 둘째 자리에서 반올림해서 소수점 한자리로 
결과를 만드는 과정이다. 

ex)
package ch11.math;

public class RoundTest {
	public static void main(String[] args) {
		// 소숫점 둘째 자리에서 반올림하시오.
		double source=10.45;
		double num = source * 10;
		long rounded = Math.round(num);
		System.out.println("최종: "+(rounded / 10.0));
	}
}
//
최종: 10.5

(3) 오버플로 방지를 위한 연산 
정수 연산의 문제점은 오버플로에 있고 문제는 이 상황이 오류가 
아님을 설명한 바 있다.
하지만, 드디어 자바 8부터 추가된 XXExact() 메서드들은 
오버플로가 발생할 때 ArithmeticException이 발생해서 
안전한 연산이 가능하게 되었다.

다음 예는 더하기 연산을 위해 addExact() 메서드를 
사용하는 예이다.

ex)

package ch11.math;

public class ExactCalcTest {
	public static void main(String[] args) {
		int i = Integer.MAX_VALUE;
		int i2 = i + 1;
		System.out.println(i2);
		try {
			int i3 = Math.addExact(i, 1);
			System.out.println(i3);
		} catch (ArithmeticException e) {
			System.out.println("예외 발생: " + e.getMessage());
		}
	}
}
//
-2147483648
예외 발생: integer overflow


----------------------------------------------------
6. Wrapper 클래스

6.1 특징 

Wrapper 클래스는 특정 클래스를 말하는 것이 아니라 부류를 말한다. 
Wrapper 클래스는 8종류의 기본형을 객체로 만들기 위한 클래스들을 
이야기한다. 기본형마다 그에 상응하는 Wrapper 클래스가 존재한다. 

기본형과 Wrapper 클래스

기본형 : Wrapper 클래스

byte : Byte 
char : Character
short : Short 
int : Integer
long : Long 
float : Float 
double : Double
boolean : Boolean

기본형을 Wrapper 클래스로 만드는 방법은 각각의 생성자에 기본형을 
파라미터로 전달하거나 valueOf()를 호출하면서 기본형 값을 
전달한다. 

ex)
Boolean b1 = new Boolean(true);
Boolean b2 = Boolean.valueOf(true);

Wrapper 클래스는 왜 필요할까? 중국집에서는 음식을 배달할 때 
배달통을 사용한다. 이 배달통에는 모든 타입의 음식이 들어갈 수 
있는데 조건이 있다. 통에 넣기 전에 음식을 랩(wrap)으로 감싸야 한다. 

자바에서도 모든 것을 담을 수 있는 통이 있는데 바로 Object이다. 
특히나 Object를 담을수 있는 배열을 만든다면 다양한 종류의 객체들을 
담을 수 있게 된다. 
단, 기본형은 제외다. 기본형은 Object를 상속 받지 않았기 
때문에 저장할수 없다. 이때, 기본형 데이터를 살짝 
감싸서 객체로 만들어 주는 것이 Wrapper 클래스이다. 

ex)
package ch11.wrapper;

public class WrapperTest {

	public static void main(String[] args) {
		Object [] objs = new Object[2];
		objs[0] = "Hello";
		objs[1] = new Integer(100);
		
		if(objs[1] instanceof Integer) {
			int num = ((Integer)objs[1]).intValue();
			
			// intValue() 생략하고, 앞에 소괄호 없애도 됨.
			
			System.out.println("값: "+num);
		}
	}
}
//
값: 100

(1)오토박싱(auto boxing)과 언박싱(unboxing)

위와 같은 과정으로 기본형을 참조형으로 형변환하여 데이터를 관리 
할수 있었다. 그런데 상당히 귀찮다. 
자바 5부터 이런 과정을 자동화 해주는 오토박싱과 언박싱 기능이 
추가 되었다. 오토박싱은 자동으로 박스를 만들어주는 것, 즉 자동으로
Wrapper 클래스의 객체로 변경해준다. 다음 코드를 보면 기본형 int 
타입을 바로 객체형인 Integer에 할당하고 있다. 
언박싱은 그 반대 개념으로 객체형인 Integer 를 바로 기본형처럼 
사용할 수 있다. 

ex)
int i = 10;
Integer wrapped = i; // autoboxing 
int b = i + wrapped; // unboxing
System.out.println(b);

따라서 앞서 살펴보았던 WrapperTest 예제에서도 100을 
배열에 넣을때 다음과 같이 간략하게 사용할수 있다. 

ex)
objs[1] = 100;

하지만 값을 뺄 때는 쉽사리 언박싱을 적용하기 어렵다.
왜냐하면 objs[1] 번째 항목이 Integer인지 아직 확실하지 
않기 때문에 형변환 과정이 필요하기 때문이다. 
이 부분에 대한 간소화는 뒤에 배울 제너릭을 통해서 처리 
할수 있다. 

(2) Wrapper 타입의 비교 
Wrapper 타입의 객체들은 기본형이 아니다. 따라서 객체들이 
갖는 내부 값들을 비교하기 위해 ==이나 !=와 같은 연산자를 사용 
할수 없다. 이들은 순수하게 참조값만을 비교한다. 
다행히 Wrapper 클래스는 내부 값들을 비교하기 위해 equals 메서드를 
오버라이딩하고 있다. 하지만, 한가지 또 주의할점이 있는데 
참조형과 기본형을 직접 비교할때는 언박싱으로 인해 기본형의 
값을 가지고 비교하게 된다. 

ex)
package ch11.wrapper;

public class EqualsTest {

	public static void main(String[] args) {
		Integer iObj1 = new Integer(1000);
		Integer iObj2 = new Integer(1000);
		System.out.println(iObj1==iObj2);
		System.out.println(iObj1.equals(iObj2));
		System.out.println(iObj1==1000);
	}
}
//
false
true
true


----------------------------------------------------
6.2 기본형의 다양한 형변환

Wrapper 클래스의 기본 목적이 기본형과 참조형 간의 
형변환인데 그것만큼이나 많이 사용되는 것이 
문자열과 기본형 간의 형변환이다. 

(1)문자열에서 기본형으로 변환 메서드 
5장에서 살펴봤듯이 main() 메서드의 경우 String[] 배열만을 
파라미터로 받을수있고, 이 문자열을 다시 기본형으로 변경하기 
위해 Character 를 제외한 Wrapper 클래스들은 문자열을 
반환할수 있는 static 메서드들을 제공한다. 메서드 이름은 클래스별로
'parse + 기본형'의 형태를 갖는다. 또한, 변환할 수 없는 값이 
파라미터로 들어오면 java.lang.NumberFormatException을 발생시킨다.

ex)

String strNum = "1000.0";
try {
int i = Integer.parseInt(strNum);
System.out.println(i);
}catch (NumberFormatException e){
System.out.println("int 로 형변환할 수 없습니다.");
}

(2)문자열에서 Wrapper 타입으로 변환 

문자열을 Wrapper 타입으로 변경할 때에는 각 Wrapper 클래스들이 
제공하는 valueOf 메서드나 생성자를 이용한다. 

ex)
Integer intObj = Integer.valueOf("100");
Integer intObj2 = new Integer("100");

이 과정에서도 역시 형변환할수 없는 형태의 문자열이 파라미터로 
들어온다면 NumberFormatException 이 발생한다. 

이제까지 나왔던 형변환 방식을 정리하면 다음 그림과 같다. 

ex)
기본형 --> String : 기본형 + ""


기본형 --> Wrapper : valueOf() 또는 생성자 이용 
ex)
Boolean b1 = new Boolean(true);
Boolean b2 = Boolean.valueOf(true);

문자열 --> 기본형 : parseXX()
ex)
int i = Integer.parseInt(strNum);

문자열 --> Wrapper : valueOf() 또는 생성자 이용 
ex)
Integer intObj = Integer.valueOf("100");
Integer intObj2 = new Integer("100");

Wrapper --> 기본형 :
ex)
int b = i + wrapped; // unboxing

Wrapper --> String : toString()

===================================
[자바 해바라기 정리] 12 유용한 클래스들 

이 장에서는 프로그래밍 과정에서 java.lang 패키지의 클래스들 
다음으로 많이 사용되는 클래스들을 모아서 알아본다.
이 장에서는 java.util을 중심으로 java.time , java.text , 
java.math 등 다양한 패키지의 클래스들을 소개한다. 
java.lang 패키지에 대해 다루었던 11장과 마찬가지로 많은 파라미터와
메서드들이 소개되지만, 전체를 설명할수는 없고 자주 사용되는 것들을 
위주로 설명. 따라서 가능하다면, 프로그래밍할 때 자바에서 제공되는 
API를 참조하는 습관을 들이는 것이 좋다. 


1. Objects를 통한 Object 관리 

java.util.Objects 는 객체에 필요한 기능성 메서드들을 정적 메서드로 정의해 
놓은 클래스이다. 

Objects의 static 메서드들 

메서드명 : 선언부와 설명 

equals() : public static boolean equals(Object a, Object b)
두 객체 a 와 b의 동등성을 검사하는 점은 Object 의 equals와 동일하지만
두 객체가 모두 null 인 경우도 비교가 가능하며 이때 return 값은 true이다. 

deepEquals() : public static boolean deepEquals(Object a , Object b)
역시 두 객체 a와 b의 동등성을 검사하는데 만약 배열인 경우 Arrays. 
deepEquals0를 이용해 배열의 내용까지 비교한다. 

toString() : public static String toString(Object o)
o 가 null 이 아닌 경우는 o의 toString()을 이용해 객체를 출력한다. 
단, null인 경우는 "null" 을 출력한다.

public static String toString(Object o, String nullDefault)
o 가 null 이 아닌 경우는 o의 toString()을 이용해 객체를 출력한다. 
단 null 인 경우는 nullDefault를 리턴한다. 

compare() : public static <T> int compare (T a , T b , Comparator < ? super T> c)
Comparator를 이용해서 a와 b를 비교한다. 

requireNonNull() : public static <T> requireNonNull( T obj)
obj가 null 이면 NullPointerException이 발생한다. null이 아니면 
객체를 리턴한다. 

public static <T> T requireNonNull(T obj, String message)
obj가 null 이면 NullPointerException이 발생한다. 이 때 예외객체의 
메시지로 message가 사용된다. obj가 null이 아닌 경우 obj가 리턴된다. 

public static <T> T requireNonNull(T obj, Supplier<String> messageSupplier)
obj가 null이면 NullPointerException 이 발생하는데 이때 예외 객체의 
메시지는 messageSupplier를 통해 공급받는다. obj가 null이 아닌 경우 obj가
그대로 리턴된다. 

isNull() : public static boolean isNull(Object obj)
obj가 null 이면 true, 아니면 false를 리턴한다.

nonNull() : public static boolean nonNull(Object obj)
isNull과 반대로 obj가 null 이면 false, 아니면 true 를 리턴한다. 


1.1 equals() 와 deepEquals()

equals() 와 deepEquals()는 Object에 있는 equals()를 제삼자의 
입장에서 볼수 있게 한다. Object의 equals()는 자신이 null인 경우는 
NullPointerException이 발생하므로 사용할수 없다. 

하지만, Objects 의 equals()는 null 여부와 관계없이 두 객체를 비교한다. 
심지어는 비교하는 두 객체 모두 null인 경우에도 비교가 가능하고 
이때 결과는 true 이다. 

deepEquals() 는 특히 배열의 동등성을 확인할때 아주 유용한데 비교하는 
두 요소가 모두 배열이면 배열이 가지는 요소들을 모두 비교해서 결과를 
반환한다.

ex)
package ch12.objects;

import java.util.Objects;

public class EqualsTest {

	public static void main(String[] args) {
		System.out.println(Objects.equals("Hello", "Hi"));
		System.out.println(Objects.equals(null, null));

		int [] ints1 = {1,2};
		int [] ints2 = {1,2};
		System.out.println(Objects.equals(ints1, ints2));
		System.out.println(Objects.deepEquals(ints1, ints2));
	}
}
//
false
true
false
true


----------------------------------------------------
1.2 toString()

Objects의 toString()은 객체가 null 이 아닌 경우는 객체의 toString()
의 결과를 리턴한다. 하지만, null이면 NullPointerException 대신 
"null"이 출력되고 필요하다면 nullDefault를 리턴할수도 있다. 

ex)
Object obj1 = null;
//System.out.println(obj1.toString());--NullPointerException
System.out.println(Objects.toString(obj1)); // null
System.out.println(Objects.toString(obj1, "널")); // 널 


----------------------------------------------------
1.3 compare()

compare()는 두 객체를 Comparator에 의거해 비교한다. 결과는 주로 
정렬 등에 사용될수 있다. Comparator는 compare 메서드 하나를 
가지는 인터페이스이다. compare()의 리턴타입은 정수로 a가 b보다 
작으면 음수(-1) , 같으면 0, 크면 양수(+1)를 리턴하도록 구현한다. 

ex)
package ch12.objects;

import java.util.Comparator;
import java.util.Objects;

class StringLengthComparator implements Comparator<String>{
	@Override
	public int compare(String o1, String o2) {
		int o1Length = o1.length();
		int o2Length = o2.length();
		if(o1Length> o2Length) {
			return 1;
		}else if(o1Length==o2Length) {
			return 0;
		}else {
			return -1;
		}
	}
}

public class CompareTest {

	public static void main(String[] args) {
		String a = "Hello";
		String b = "Java";
		int compResult = Objects.compare(a, b, new StringLengthComparator());
		if(compResult>0) {
			System.out.println("a가 더 길다.");
		}else if(compResult==0) {
			System.out.println("a와 b의 길이는 같다.");
		}else {
			System.out.println("b가 더 길다.");
		}
	}
}
//
a가 더 길다.


----------------------------------------------------
1.4 null 처리 

객체가 null 인 상황은 잠재적으로 NullPointerException을 발생시킬수 
있기 때문에 의심스러운 경우 잘 체크해야 한다. 일반적으로 obj == null 과 
같이 체크하지만 Objects 에는 다양한 메서드로 관련 처리를 도와준다. 

- requireNonNull() 계열의 메서드는 표현대로 non null이 필요하다.
따라서 그렇지 않으면, 즉 null인 경우는 자체적으로 NullPointerException을 
발생시켜준다. 필요하다면 예외 객체에 원하는 메시지를 설정할 수도 있다. 
만약 객체가 null이 아니라면 해당 객체를 리턴한다. 

- isNull이나 nonNull() boolean 값으로 객체가 null인지 여부를 리턴한다. 

ex)
package ch12.objects;

import java.util.Objects;

public class NullCheckTest {

	public static void main(String[] args) {
		String[] strs = { "Hello", null };
		
		if (Objects.nonNull(strs[0])) {
			System.out.println(strs[0].length());
		}
		
		if (Objects.isNull(strs[1])) {
			System.out.println("strs[1]은 null 입니다.");
		}
		
		try {
			String name = Objects.requireNonNull(strs[0]);
			System.out.println(name);
		} catch (NullPointerException e) {
			System.out.println(e);
		}
		
		try {
			String name = Objects.requireNonNull(strs[1], "먼저 값을 할당하세요.");
			System.out.println(name);
		} catch (NullPointerException e) {
			System.out.println(e.getLocalizedMessage());
			
			// requireNonNull()의 파라미터로 문자열이 추가로 전달된다. 
			// 이 문자열은 예외객체의 message에 할당되므로 getLocalizedMessage()
			//를 호출하면 확인할수 있다. 
		}
		
		try {
			String name = Objects.requireNonNull(strs[1], ()->"먼저 값을 할당하세요.");
			System.out.println(name);
		} catch (NullPointerException e) {
			System.out.println(e.getLocalizedMessage());
		}
	}
}
//
5
strs[1]은 null 입니다.
Hello
먼저 값을 할당하세요.
먼저 값을 할당하세요.


----------------------------------------------------
2. 날짜 및 시간의 처리 

2.1 날짜 및 시간을 관리하는 클래스의 변천사 

날짜 및 시간 데이터는 프로그래밍에서 아주 빈번히 사용된다. 
그런데 자바에서 특히 이 값을 표현하는 대표적인 클래스가 자주 
바뀌었다. 문제는 새로운 버전으로 갈수록 합리적이지만 
이전 버전이 아직도 많이 사용된다는 점이고 우리는 모두 다 알아야한다.

(1) java.util.Date 

자바가 처음 나오면서부터 날짜 및 시간을 관리하던 클래스는 java.util.Date 
클래스이다. 그러나 Date 클래스의 대부분 생성자 및 메서드들은 더이상 
사용되지 않는 것으로 (Deprecated)으로 처리되어 있을 만큼 상황이 
좋지 않다. 하지만, 이미 작성된 많은 API가 파라미터나 리턴 타입으로 
Date를 여전히 사용하고 있는 편이다. 

다음은 Date 클래스의 주요 메서드들이다.

생성자/메서드명  :  선어부와 설명 

Date() : public Date()
현재 시각 (System.currentTimeMillis())을 이용하는 생성자이다.

public Date(long date)
date 를 이용하는 생성자이다. date는 1970/11 0:00:00 초를 
기점으로 해당 시각까지의 밀리 초( 1/1000초) 단위의 값이다. 

getTime() : public long getTime()
Date 객체의 시각을 long 값 (밀리초)으로 리턴한다. 

setTime() : public void setTi (long time)
Date 객체의 시각을 time으로 설정한다. 

toString() : public String toString()
Date 를 EEE MMM dd HH:mm:ss zzz yyyy 패턴의 문자열로 리턴한다. 

equals() : public boolean equals(Object obj)
getTime() 을 이용해 두 Date 객체의 시각이 같은지 여부를 리턴한다. 

Date  객체를 출력할때 사용되는 EEE MMM dd HH:mm:ss zzz yyyy 패턴의
의미는 SimpleDateFormat에서 다시 다룬다. 

ex)
package ch12.date;
import java.util.*;

public class DateTest {

	public static void main(String[] args) {
		Date d1 = new Date();
		System.out.println(d1);
		// 현재 시각을 이용해 Date 타입 객체 d1을 생성하고 출력.
		
		Date d2 = new Date(1500000000000L);
		//1500000000000L 을 이용해 Date 타입 객체 d2를 생성하고 출력. 
		
		System.out.println(d2);
		long gap = d1.getTime() - d2.getTime();
		System.out.printf("두 날짜의 차는 "+gap/1000/60/60/24 +"일이다.");
	}
}
//실행 시점에 따라 결과는 달라짐. 
Sun Apr 14 15:16:58 KST 2019
Fri Jul 14 11:40:00 KST 2017
두 날짜의 차는 639일이다.

(2) java.util.Calendar

Date 의 다음으로 시간 처리에 추천된 클래스에는 Calendar 클래스이다.
Calendar는 추상클래스로 직접 객체를 생성할수 없고 static 메서드인 
getInstance()를 호출해서 얻는다. 

getInstance()는 OS의 로케일(Locale)과 타임존(Timezone) 정보를 이용해서 
적절한 Calendar 객체를 생성 후 리턴한다. 이때 리턴되는 실제 구현체는 
BuddhistCalendar, JapaneseImperialCalendar, GregorianCalendar의 
세종류이다.
BuddhistCalendar는 주로 태국 지역에서 사용되는 불기를 기준으로 하는 달력.
GregorianCalendar는 우리가 주로 사용하는 서기이다. 

로케일(Locale)이란 사용자의 언어와 국가를 기반으로 사용자에 적합한 
환경을 제공하기 위한 것으로 "언어-국가" 형식으로 표시한다. 
예를들어 대한민국 로케일(ko-KR)이 적용되면 통화 기호로 원화가()
가 사용되지만, 미국 로케일(en-US)의 경우는 달러$ 가 사용된다. 
사용 가능한 Locale은 다음과 같이 찾아볼수 있다. 

ex)
Locale [] locales = Locale.getAvailableLocales();
for(Locale l: locales){
System.out.println(l.getLanguage()+"_" + l.getCountry());
}

타임존(Timezone)이란 시간대를 말하며 지구 자전에 따른 지역별 
사간 차이를 나타낸다. 흔히 멀리 해외여행을 다녀왔을 때 느끼는 시차는 
다른 타임존의 지역을 다녀왔을 때 느낄수 있는 것이다. 
사용가능한 타임존은 다음과 같이 확인할수 있다. 

ex2)
String [] tzs = TimeZone.getAvailableIDs();
for(String tz: tzs){
System.out.println(tz);
}

로케일과 타임존을 이용해서 다양한 Calendar를 사용해보자.

ex3)

package ch12.date;

import java.util.Calendar;
import java.util.Locale;
import java.util.TimeZone;

public class GetCalendarTest {

	public static void main(String[] args) {
		Calendar cal = Calendar.getInstance();
		System.out.println(cal.getClass().getName()); // java.util.GregorianCalendar
		TimeZone newYorkTZ = TimeZone.getTimeZone("America/New_York");
		Calendar calNewYork = Calendar.getInstance(newYorkTZ);
		int gap = (cal.get(Calendar.HOUR_OF_DAY) - calNewYork.get(Calendar.HOUR_OF_DAY));
		System.out.printf("서울은 뉴욕보다 %d시간 빠르다.%n", gap);

		Calendar buddhistCal = Calendar.getInstance(new Locale("th", "TH"));
		System.out.println(buddhistCal.getClass().getName()); // sun.util.BuddhistCalendar
	}
	
	public void printTimeZone() {
		String [] tzs = TimeZone.getAvailableIDs();
		for(String tz: tzs) {
			System.out.println(tz);
		}
	}
	public static void printLocale() {
		Locale [] locales = Locale.getAvailableLocales();
		for(Locale l: locales) {
			System.out.println(l.getLanguage()+"_"+l.getCountry());
		}
	}

}
//
java.util.GregorianCalendar
서울은 뉴욕보다 13시간 빠르다.
sun.util.BuddhistCalendar

Calendar에는 다양한 시간 관련 상수값과 setter 와 getter 메서드를 
이용해 시각을 설정한다. 

Calendar의 주요 상수 

상수명 : 설명 
Calendar.YEAR : 년도
Calendar.MONTH : 월
Calendar.DAY_OF_MONTH : 일
Calendar.DAY_OF_WEEK : 요일
Calendar.AM_PM : 오전/오후
Calendar.HOUR : 시
Calendar.MINUTE : 분
Calendar.SECOND : 초

다음은 Calendar 클래스의 주요 메서드이다. 

메서드명 : 선언부와 설명 

getInstance() : public static Calendar getInstance()
OS의 TimeZone, Locale에 의거해서 적절한 Calendar 객체를 
리턴한다. 

public static Calendar getInstance(
TimeZone zone, Locale aLocale)
지정된 zone 과 aLocale에 의거해서 Calendar 객체를 리턴한다. 

getTime() : public final Date getTime()
Calendar 객체를 Date 타입으로 리턴한다. 

setTime() : public final void setTime(Date date)
Date 객체를 이용해 Calendar의 시각을설정한다. 

getTimeInMillis() : public long getTimeInMillis()
Calendar 의 시각을 밀리 초로 리턴한다. 

setTimeInMillis() : public void setTimeInMillis(long millis)
밀리 초 단위인 millis 로 Calendar의 시각을 설정한다. 

get() : public int get(int field)
field에 해당하는 값을 리턴한다. field는 Calendar의 상수 값중 
하나이다. 

set() : public void set(int field, int value)
field 에 해당하는 값을 value로 설정한다. 
field는 Calendar 상수 값중 하나이다. 

public final void set( int year, int month, int date)
year, month , date 값을 이용해 Calendar의 날짜를 설정한다. 

날짜를 다루면서 한가지 주의할 사항이 있는데 대부분 컴퓨터 
프로그램에서 월은 0부터 시작한다. 
따라서 우리가 일반적으로 사용하는 달력으로 환산하려면 1을 
더해준다. 

ex)
Calendar cal = Calendar.getInstance();
cal.set(Calendar.MONTH,0); // 1월 설정 
System.out.printf("지금은 %d월이다. ", cal.get(Calendar.MONTH) +1);

주의 ,
프로그래밍에서 월은 0부터 시작하므로 0~11 까지 정의돼 있을 꺼 같지만, 
0~12 까지 사용된다. 12는 UNDECIMBER 라 부르며 
GregorianCalendar에서는 사용하지 않고, 음력 체계에서만 사용된다. 

Calendar와 Date 간의 형변환도 기억해 두어야 한다. 

ex)
Calendar cal = Calendar.getInstance();
Date fromCal = cal.getTime(); // Calendar --> Date 
cal.setTime(fromCal); // Date --> Calendar

ex2)
package ch12.date;

import java.util.Calendar;

public class CalendarTest {

	public static String getDateString(Calendar c) {
		int year = c.get(Calendar.YEAR);
		int month = c.get(Calendar.MONTH)+1;
		int date = c.get(Calendar.DATE);

		int dayOfWeek = c.get(Calendar.DAY_OF_WEEK);// 1:일요일 ~ 7:토요일
		String dayOfWeekStr = null;
		if (dayOfWeek == Calendar.SUNDAY) {
			dayOfWeekStr = "일";
		} else if (dayOfWeek == Calendar.MONDAY) {
			dayOfWeekStr = "월";
		} else if (dayOfWeek == Calendar.TUESDAY) {
			dayOfWeekStr = "화";
		} else if (dayOfWeek == Calendar.WEDNESDAY) {
			dayOfWeekStr = "수";
		} else if (dayOfWeek == Calendar.THURSDAY) {
			dayOfWeekStr = "목";
		} else if (dayOfWeek == Calendar.FRIDAY) {
			dayOfWeekStr = "금";
		} else {
			dayOfWeekStr = "토";
		}
		return String.format("%d년 %d월 %d일(%s)", year, month, date, dayOfWeekStr);
	}

	public static String getTimeString(Calendar c) {
		int hour = c.get(Calendar.HOUR);
		int minute = c.get(Calendar.MINUTE);
		int second = c.get(Calendar.SECOND);
		int amPm = c.get(Calendar.AM_PM);
		String amPmString = (amPm == Calendar.AM ? "오전" : "오후");
		return String.format("%d시 %d분 %d초(%s)", hour, minute, second, amPmString);


	}

	public static void main(String[] args) {
		Calendar cal = Calendar.getInstance();
		System.out.println("오늘은: " + getDateString(cal));
		System.out.println("지금은 " + getTimeString(cal));
		cal.set(Calendar.YEAR, 2002);
		System.out.println("오늘은: " + getDateString(cal));
	}
}
//
오늘은: 2019년 4월 14일(일)
지금은 5시 11분 38초(오후)
오늘은: 2002년 4월 14일(일)

Calendar는 add()와 roll() 메서드를 이용해서 연산할수 있다. 

표12.5 Calendar의 시간 연산 메서드 

메서드명 : 선언부와 설명 

add() : abstract public void add(int field, int amount);
Calendar, DATE 등 주어진 field 값을 amount 만틈 더하거나 뺀다. 
이때 다음 단위(Calendar, DATE 일 경우 Calendar.MONTH)도 영향을 받는다. 

roll() : abstract public void roll(int field, boolean up);
Calendar.DATE 등 주어진 field의 값을 amount 만큼 더하거나 뺀다. 단, 
다음 단위(Calendar.DATE 일 경우 Calendar.MONTH)는 영향받지 않는다. 

add()와 roll()은 모두 특정 field에 값을 더하거나 뺄수있다. 차이점은 
add는 연산결과가 다른 field에 영향을 준다. 
예를들어 시계의 태엽을 감을때 add 방식은 분침이 한퀴 돌면 시침도 
한칸 이동하는 식이다. 
하지만, roll은 계속해서 분침만 돌아간다. 

ex)

package ch12.date;

import java.util.Calendar;

public class CalendarOperTest {
	public static String printSimpleCalendar(Calendar c) {
		int month = c.get(Calendar.MONTH);
		int date = c.get(Calendar.DATE);
		return String.format("%d월 %d일", month, date);
	}
	
	public static void main(String[] args) {
		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 29);
		System.out.println("최초: "+printSimpleCalendar(cal));
		cal.add(Calendar.DATE, 20);
		System.out.println("20일 add 후: "+printSimpleCalendar(cal));
		cal.roll(Calendar.DATE, -20);
		System.out.println("-20일 roll 후: "+printSimpleCalendar(cal));
	}

}
//
최초: 3월 29일
20일 add 후: 4월 19일
-20일 roll 후: 4월 30일

(3) java.time 패키지 
Calendar 클래스는 날짜에 대한 간편한 조작이 가능하지만 사용하기 
번거롭고 기능이 많이 부족했다. 시간과 날짜가 섞여 있는 것도 어색하다. 
마치 달력에 몇시냐고 물어보는 형태이다. 여전희 월의 시작이 0인점도 
혼동을 일으키기 쉽다. 이런 번거로움 때문에 많은 개발자가 별도의 
라이브러리를 이용하기도 했다. 

자바 8에서부터는 java.time 패키지가 등장해서 날짜, 시간에 대한 모든 것을 
담당하게 되었다. 

java.time 과 주요 하위 패키지들. 

java.time : 날짜와 시간을 다루는데 필요한 클래스 정의 
ex)LocalDate, LocalTime, LocalDateTime,
ZonedDateTime, Instant Period, Duration 

java.time.chrono : ISO 이외의 비 표준 달력 시스템을 다루는 클래스 정의 
ex)HijrahDate, JapanessDate, ThaiBuddishDate ..

java.time.format : 문자로 된 날짜, 시간을 파싱해서 객체로 만들거나 
필요한 문자열로 출력하는 클래스 정의 
ex) DateTimeFormatter 

java.time.temporal : 날짜와 시간의 필드와 단위를 처리하기 위한 클래스 정의 
ex) Temporal, TemporalAdjuster 

java.time.zone : 시간대와 관련된 클래스 정의 

----------------------------------------------------
2.2 java.time 패키지

(1) 날짜 및 시간을 표현하는 클래스 
java.time에는 Temporal 인터페이스와 다섯 가지의 구현체가 
날짜와 시간을 표현한다. 

LocalDate, LocalDateTime, LocalTime, ZonedDateTime, Instant 
--> <<interface>> Temporal 

클래스들이 많아졌지만, Temporal 인터페이스에 대한 구현체들이기 
때문에 Temporal 인터페이스의 사용법만 익히면 나머지 클래스의 사용법은 
매우 유사하다. 기존의 Calendar 대비 클래스별로 세분화되어 날짜와 
시간을 표시한다. 

- LocalDate : 현재 소속된 로컬의 날짜를 다루는 클래스 이다. 
- LocalTime : 현재 소속된 로컬의 시간을 다루는 클래스 이다. 
- LocalDateTime :현재 소속된 로컬의 날짜와 시간을 다루는 클래스로 
LocalDate와  LocalTime을 합한 것과 같다. 
- ZonedDateTime : 특정 타임존의 날짜와 시간을 다루는 클래스로 
LocalDate와 LocalTime 그리고 Timezone이 합쳐진 형태이다. 
- Instant : 1970.01.01 0:00:00 초 부터 지금까지의 시간을 나노초로
표현하며 Date와 의 타입 변환에 주로 사용된다. 

Instant를 제외한 나머지는 4개의 클래스는 사용법이 매우유사하다. 
이들은 now() 와 of()라는 정적 메서드를 갖는다. 

now()는 현재 시각을 기준으로 날짜 또는 시간 정보를 갖는 객체를 
리턴한다. now()는 필요에 따라 ZoneId 또는 Clock 객체를 이용해 특정 
타임존 또는 클럭 기반으로 객체를 생성할수 있다. 

of()는 각 객체가 가지는 요소(예를들어 LocalDate는 년/월/일 정보, 
LocalTime은 시/분/초 정보)들을 파라미터로 받아서 객체를 생성한다. 

ex)
 package ch12.date;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;

public class CreateTime {

	public static void main(String[] args) {
		localDate();
		localTime();
		etc();
	}

	private static void localDate() {
		LocalDate date = LocalDate.now();
		System.out.println(date);

		LocalDate date2 = LocalDate.of(2015, 01, 01);
		System.out.println(date2);
	}

	private static void localTime() {
		LocalTime time = LocalTime.now();
		System.out.println(time);

		LocalTime time2 = LocalTime.of(13, 40, 23);
		System.out.println(time2);
	}

	private static void etc() {
		LocalDateTime dt = LocalDateTime.now();
		System.out.println(dt);
		
		ZonedDateTime zdt = ZonedDateTime.of(dt, ZoneId.of("Asia/Seoul"));
		System.out.println(zdt);
	}
}
//
2019-04-14
2015-01-01
18:04:13.231910900
13:40:23
2019-04-14T18:04:13.231910900
2019-04-14T18:04:13.231910900+09:00[Asia/Seoul]

(2)날짜/시간 정보의 조회와 변경 

각 클래스는 상황에 맞는 getXXX() 메서드를 제공한다. 여기서 XXX는 
클래스 별로 Year, Month, Hour, Minute 등이 사용된다.

정보 조회를 위한 메서드들 

클래스 : 메서드 : 설명 

LocalDate 
public int getYear() : 연도 정보 리턴 
public int getMonthValue() : 월 정보(1~12) 리턴 
public Month getMonth() : Month 객체로 월 정보 리턴 
public int getDayOfMonth() : 그 달에서 일 정보(1~31) 리턴 
public int getDayOfYear() : 그 해에서 일 정보(1~365) 리턴 
public DayOfWeek getDayOfWeek() : DayOfWeek 타입으로 요일 정보 리턴.
public boolean isLeapYear() : 윤년 여부 리턴 
public int lengthOfMonth() : 그 달이 몇일까지 인지 리턴 (365|366)

LocalTime
public int getHour() : 시간 정보(0~23)리턴 
public int getMinute() : 분 정보(0~59)리턴 
public int getSecond() : 초 정보(0~59)리턴 

LocalDateTime에서는 시간 연산을 위해서 
plusXXX(), minusXXX(), withXXX() 메서드들이 사용된다.
plus 계열은 더하기 , minus 계열은 빼기, with 계열은 
설정하기라고 생각하면 쉽다. 
XXX는 get() 계열과 마찬가지로 클래스에 따라서 Years,
Months 등이 사용된다. 이 메서드들은 같은 타입을 리턴하는데,
time 패키지의 클래스들은 String과 마찬가지로 변경 불가능한 
클래스이므로 매번 새로운 객체를 리턴한다. 

예를들어 11월에 다음 코드를 수행한다고 가정해보자. 처음 now 
값은 November이고 이 값은 아무리 plus, minus 연산을 수행해도 
변하지 않는다. plus 등 연산은 결과로 새로운 객체를 반환한다. 
따라서 now2의 값은 January 가 된다. 

ex)
LocalDate now = LocalDate.now()
LocalDate now2 = now.plusMonths(2)
System.out.println(now.getMonth().name()); //November
System.out.println(now2.getMonth().name()); //JANUARY

ex2)
package ch12.date;

import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.Month;
import java.time.format.TextStyle;
import java.util.Locale;

public class UseTimeInfo {

	public static void printDate(LocalDateTime now) {
		String date = now.getYear() + "/" + now.getMonthValue() + "/" + now.getDayOfMonth();
		String time = now.getHour() + ":" + now.getMinute() + ":" + now.getSecond();
		DayOfWeek day = now.getDayOfWeek();
		String dayDsipName = day.getDisplayName(TextStyle.SHORT, Locale.KOREAN);
		System.out.println(date + "(" + dayDsipName + ")" + time);
		Month month = now.getMonth();
		String monthDispName = month.getDisplayName(TextStyle.SHORT, Locale.KOREAN);
		System.out.println(monthDispName);
	}

	public static void main(String[] args) {
		LocalDateTime now = LocalDateTime.of(2017, 1, 1, 12, 30, 30);
		printDate(now);
		LocalDateTime now2 = now.plusMonths(2).minusDays(5);// now 월+2, 일-5
		printDate(now2);
		LocalDateTime now3 = now.withMonth(5).withHour(0); // 기존 월 --> 5로 수정
		printDate(now3);
	}
}
//
2017/1/1(일)12:30:30
1월
2017/2/24(금)12:30:30
2월
2017/5/1(월)0:30:30
5월

with() 중에 TemporalAdjuster를 파라미터로 받는 경우가 있는데 이 메서드는 
단순히 값을 설정하는 것이 아니라 기존 값을 기준으로 상대적으로 값을 
변경한다. TemporalAdjusters에는 TemporalAdjuster를 리턴하는 다양한 
정적(static) 메서드를 제공한다. 사용법들이 유사하고 가짓수만 많으므로 
대표적인 것들만 살펴보자. 

TemporalAdjusters의 주요 메서드 

메서드명 : 선언부와설명

firstDayOfYear() : public static TemporalAdjuster firstDayOfYear()
해당 년도의 첫날을 설정하기 위한 TemporalAdjuster를 리턴한다. 

lastDayOfYear() : public static TemporalAdjuster lastDayOfYear()
해당 년도의 마지막날을 설정하기 위한 TemporalAdjuster를 리턴한다. 

firstDayOfMonth() : public static TemporalAdjuster firstDayOfMonth()
해당 월의 첫날을 설정하기 위한 TemporalAdjuster를 리턴한다. 

lastDayOfMonth() : public static TemporalAdjuster lastDayOfMonth()
해당 월의 마지막날을 설정하기 위한 TemporalAdjuster를 리턴한다. 

next() : public static TemporalAdjuster next(DayOfWeek dayOfWeek)
돌아오는 요일을 설정하기 위한 TemporalAdjuster를 리턴한다

previous() : public static TemporalAdjuster previous( DayOfWeek dayOfWeek)
이전 요일을 설정하기 위한 TemporalAdjuster를 리턴한다.

ex)

package ch12.date;

import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.temporal.TemporalAdjusters;

public class UseTemporalAdjuster {

	public static void main(String[] args) {
		LocalDateTime datetime = LocalDateTime.of(2017, 1, 1, 1, 1, 1);
		System.out.println("기준일: "+datetime+"-"+datetime.getDayOfWeek());
		LocalDateTime lastDay = datetime.with(TemporalAdjusters.lastDayOfYear());
		System.out.println("마지막일: "+lastDay+"-"+lastDay.getDayOfWeek());
		LocalDateTime prevWeekDay = datetime.with(TemporalAdjusters.previous(DayOfWeek.SUNDAY));
		System.out.println("이전 일요일: "+prevWeekDay+"-"+prevWeekDay.getDayOfWeek());
		LocalDateTime nextWeekDay = datetime.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
		System.out.println("다음 월요일: "+nextWeekDay+"-"+nextWeekDay.getDayOfWeek());
	}
}
//
기준일: 2017-01-01T01:01:01-SUNDAY
마지막일: 2017-12-31T01:01:01-SUNDAY
이전 일요일: 2016-12-25T01:01:01-SUNDAY
다음 월요일: 2017-01-02T01:01:01-MONDAY

(3) 날짜와 시간의 비교 
날짜와 시간을 비교하기 위해 compareTo(), isAfter(), isBefore(),
isEqual(), until()등의 메서드를 사용한다. 

메서드명 : 선언부와설명

compareTo() : public int compareTo(ChronoLocalDate other)
객체의 날짜가 other와 비교해서 빠르면 양수, 느리면 음수, 같으면 0을 
리턴 한다.

isAfter() : public boolean isAfter(ChronoLocalDate other)
객체의 날짜가 other 뒤의 시점인지 리턴한다.

isBefore() : public boolean isBefore(ChronoLocalDate other)
객체의 날짜가 other 이전 시점인지 리턴한다. 

isEqual() : public boolean isEqual(ChronoLocalDate other)
객체의 날짜가 other와 동일한 날짜인지 리턴한다. 

until() : public long until(Temporal endExclusive, TemporalUnit unit)
객체의 날짜와 endExclusive와의 unit 에 대한 차이를 long 값으로 
리턴한다.

위 표는 LocalDate의 메서드들이며 다른 클래스에도 유사한 메서드들이 
있으니 어렵지 않게 사용할수 있다. 다른 클래스의 메서드들은 
도큐멘테이션을 활용하자.

until()은 TemporalUnit 타입의 unit 을 기준으로 두 날짜의 차이를 
long 값으로 리턴한다. 
TemporalUnit 의 구현체로는 ChronoUnit 이 사용된다.
ChronoUnit은 Enum 으로 YEARS, MONTHS, WEEKS, DAYS, MINUTES, SECONDS 
등 enum 상수 값을 갖는다. 

ex)
package ch12.date;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

public class DateCompare {

	public static void main(String[] args) {
		LocalDateTime date1 = LocalDateTime.now();
		LocalDateTime date2 = LocalDateTime.of(2000, 1, 1, 1, 1, 1);
		System.out.printf("date1: %s, date2: %s%n",date1,date2);
		System.out.println(date1.isBefore(date2));
		System.out.println(date1.isAfter(date2));
		System.out.println(date1.isEqual(date2));

		long pasted = date2.until(date1, ChronoUnit.YEARS);
		System.out.printf("date1는 date2으로부터 %d년 지났다." ,pasted);
	}
}
//
date1: 2019-04-17T23:40:27.424598500, date2: 2000-01-01T01:01:01
false
true
false
date1는 date2으로부터 19년 지났다.

두 날짜/시간 사이를 더 전문적으로 처리하기 위해서는 Period와
Duration 클래스를 사용할수 있다. 
이 두 클래스는 각각 between()이라는 정적 메서드를 이용해서 
구할수 있다. 
Period는 년, 달, 일의 차이를 계산하고 Period는 초, 나노초의 
차이를 계산한다. 

Period 클래스의 주요 메서드

메서드명 : 선언부와설명

between() : public static Period between
(LocalDate startDateInclusive, LocalDate endDateExclusive)
비교할 두 날짜의 차이를 저장할 Period 객체를 리턴한다.
단, startDateInclusives는 포함하고 endDateExclusive는 
포함되지 않는다.

getYears() : public int getYears()
년의 차이를 리턴한다.

getMonths() : public int getMonths()
월의 차이를 리턴한다.

getDays() : public int getDays()
일의 차이를 리턴한다.

Duration 클래스의 주요 메서드 

메서드명 : 선언부와설명

between() : public static Duration between
(Temporal startInclusive, Temporal endtInclusive)
비교할 두 시간 사이의 차이를 저장할 Duration 객체를 리턴한다.
단 startInclusive는 포함하고 endExclusive는 포함하지 않는다.

getSeconds() : public long getSeconds()
초의 차이를 리턴한다. 

getNano() : public int getNano()
나노초의 차이를 리턴한다.

주의할점은 Period는 단위별로 차이를 계산하고 Duration은 총 시간의
차이를 계산한다는 점. 

ChronoUnit의 열거 타입들도 between() 메서드를 갖는데 이 메서드는 
Duration과 마찬가지로 총 시간의 차이를 계산한다. 

ex)
LocalDateTime dt1 = LocalDateTime.of(2016, 1, 1, 1, 1, 1);
LocalDateTime dt1 = LocalDateTime.now();
long secDiff = ChronoUnit.SECONDS.between(dt1, dt2); // 총 초의 차이
long hourDiff = ChronoUnit.HOURS.between(dt1, dt2); // 총 시간의 차이

3개의 between() 메서드를 비교하면 다음과 같다. 

between()  메서드의 동작 기준 

메서드 : 리턴 타입 : 연산_기준
Period.between() : 년/월/일 차이_계산 : 각 단위별로 연산 

Duration.between() : 초/나노 초로 계산 : 총 시간을 기준으로 연산

ChronoUnit.XXX.between() : 모든 단위 계산 : 총 시간을 기준으로 연산

ex)
package ch12.date;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Period;
import java.time.temporal.ChronoUnit;

public class DifferBetween {

	public static void main(String[] args) {
		LocalDate date1 = LocalDate.of(2000, 1, 3);
		LocalDate date2 = LocalDate.of(2017, 5, 1);

		Period period = Period.between(date1, date2);
		System.out.println(period);// Period에는 두 날짜의 차이가 저장됨
		System.out.println("몇 년 차이? " + period.getYears()); // 년 간의 차이
		System.out.println("몇 월 차이? " + period.get(ChronoUnit.MONTHS));// 월 간의 차이
		System.out.println("몇 일 차이? " + period.get(ChronoUnit.DAYS));// 일 간의 차이	
		
		long monthDiff = ChronoUnit.MONTHS.between(date1, date2);
		System.out.println("몇 개월 차이? "+monthDiff);// 총 개월의 차이
		
		LocalDateTime dt1 = LocalDateTime.of(2016,1,1,1,1,1);
		LocalDateTime dt2 = LocalDateTime.of(2017,1,1,1,1,1);
		Duration duration = Duration.between(dt1, dt2);
		System.out.println(duration);
		System.out.println("몇 초 차이? "+duration.getSeconds());		
		long secDiff = ChronoUnit.SECONDS.between(dt1, dt2); // 총 초의 차이
		System.out.println("몇 초 차이? "+secDiff);// 총 초의 차이
		long hourDiff = ChronoUnit.HOURS.between(dt1, dt2);
		System.out.println("몇 시간 차이? "+hourDiff);
	}
}
//
P17Y3M28D
몇 년 차이? 17
몇 월 차이? 3
몇 일 차이? 28
몇 개월 차이? 207
PT8784H
몇 초 차이? 31622400
몇 초 차이? 31622400
몇 시간 차이? 8784

(4) 날짜/시간의 표현 
날짜/시간 정보는 필요에 따라 다양한 형태로 표시될수 있다. 
예를들어 2017년 1월 1일이라는 값을 필요에 따라 
2017/01/01, 170101, 0101(일) 등과 같이 출력할수 있다. 
출력될 때는 어떤 형식이든지 문자열로 출력되는데 매번 필요한
값을 뽑아서 문자열을 구성하기는 매우 힘들다. 
또는 거꾸로 화면상에 다양하게 출력된 문자열 값을 다시 날짜로 
환산할 필요도 발생한다. 

이처럼 객체를 원하는 형태의 문자열로 변환하는 과정을 포멧팅
(형식화, formatting)이 라고 하고, 반대로 문자열을 객체로 변경하는 
과정을 파싱(parsing)이라고 한다. 포멧팅과 파싱을 위해서는 
DateTimeFormatter객체가 활용된다. 

포멧팅과 파싱을 위한 LocalTime의 메서드 

메서드명 : 선언부와설명

parse() : public static LocalTime parse(CharSequence text)
text를 DateTimeFormatter.ISO_LOCAL_TIME에 의해서 LocalTime으로 
리턴한다. 

public static LocalTime parse(CharSequence text, DateTimeFormatter formatter)
text를 formatter에 의거 LocalTime으로 리턴한다. 

format() : public String format(DateTimeFormatter formatter)
LocalTime을 formatter에 의거 String으로 리턴한다. 

LocalDate와 LocalDateTime도 LocalTime과 동일한 메서드들이 제공된다. 
단지 리턴 타입만 LocalTime이 아니라 해당 클래스 타입으로 
변경된다.
DateTimeFormatter는 다양한 상수로 출력 형태들이 정의 되어 있다. 
주요 포맷들을 살펴보자. 

DateTimeFormatter에 미리 정의된 출력 형태 

상수명 : 설명 : 예

BASIC_ISO_DATE : 기본 ISO 날짜 형태 : "20111203"
ISO_LOCAL_DATE : ISO 로컬 날짜 형태 : "2011-12-03"
ISO_LOCAL_TIME : ISO 로컬 시간 형태 : '10:15'or '10:15:30'
ISO_LOCAL_DATE_TIME : ISO 로컬 날짜_시간 형태 : '2011-12-03T10:15:30'
ISO_ORDINAL_DATE : 년과 년에서의 날 수 : '2012-337'
ISO_WEEK_DATE : 년과 주수 및 주에서의 날수 : '2012-W48-6'

다음은 '2007.02.05.01:11:0'의 시각을 다양한 형태로 출력한 예.

ex)
package ch12.date;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class DateParse {
	public static void main(String[] args) {
		LocalDateTime date = LocalDateTime.of(2007, 2, 5, 1, 11, 0);
		System.out.printf("기본 날짜 출력: %s%n", date);
		System.out.println(date.format(DateTimeFormatter.BASIC_ISO_DATE));
		System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
		System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_TIME));
		System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
		System.out.println(date.format(DateTimeFormatter.ISO_ORDINAL_DATE));
		System.out.println(date.format(DateTimeFormatter.ISO_WEEK_DATE));
		
		String isoLocalDateTime = "2007-02-05T01:11";
		System.out.println(isoLocalDateTime);
		LocalDateTime parsed = LocalDateTime.parse(isoLocalDateTime);
		System.out.printf("복원된 값: %s",parsed);
	}
}
//
기본 날짜 출력: 2007-02-05T01:11
20070205
2007-02-05
01:11:00
2007-02-05T01:11:00
2007-036
2007-W06-1
2007-02-05T01:11
복원된 값: 2007-02-05T01:11

위와 같이 DateTimeFormatter는 다양한 포맷의 출력을 지원하지만,
개발자가 원하는 형태의 출력이 아닐수 있다. 이때는 ofPattern()을 
이용할수 있다. ofPattern()에는 미리 지정된 형식 문자들을 조합해서 
원하는 패턴을 작성할수 있다. 

다음은 사용자 정의 패턴 지정에 사용할수 있는 형식 문자들이다. 

포멧과 파싱에 자주 사용되는 형식 문자들 

기호 : 의미 : 표현 : 예 

y : 연도 : yyyy,yy : 2007,07
M : 월 : MMM, MM : 12월 , 12
d : 일 : dd : 21
E : 요일 : EEEE, E : 수요일, 수 
H : 시간( 0 ~ 23) : HH : 4
K : 시간( 0 ~ 11) : KK : 11
m : 분 ( 0 ~ 59) : mm : 30
s : 초 ( 0 ~ 59) : ss : 40 
a : 오전/오후 : a : 오전/오후 

이 외의 다양한 형식 문자들은 
java.time.format.DateTimeFormatter API의 'Patterns 
for Formatting and Parsing'부분을 살펴보도록 한다. 

위의 형식 문자 중 한글이 들어가는 것을 사용할 때는 로케일을 
고러해야 한다. 예를 들어 오전/오후는 Locale.KOREAN에서만 
적용된다. AM이나 PM을 a로 대체하려면 
Locale.ENGLISH를 이용해야 한다. 

DateTimeFormatter의 ofPattern() 메서드 

메서드명 : 선언부와설명

ofPattern() : public static DateTimeFormatter ofPattern(String pattern)
pattern 이 적용된 DateTimeFormatter를 반환한다. 

public static DateTimeFormatter ofPattern(String pattern, Locale locate)
pattern과 locale 이 적용된 DateTimeFormatter를 반환한다. 

다음 예는 사용자 정의 패턴을 이용해서 날짜 및 시간을 출력하는 방법.

ex)

package ch12.date;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

public class DateParse2 {
	public static void main(String[] args) {
		String sDate = "2015-01-01";
		LocalDate lDate = LocalDate.parse(sDate);
		System.out.println("ISO_LOCAL_DATE 형태 : " + lDate);

		String sDate2 = "2015-01-01(목)";
		DateTimeFormatter dformatter = DateTimeFormatter.ofPattern("yyyy-MM-dd(E)");
		LocalDate lDate2 = LocalDate.parse(sDate2, dformatter);
		System.out.println("사용자 정의 형태(날짜) : " + lDate2);

		String sTime = "03:30:30";
		LocalTime lTime = LocalTime.parse(sTime);
		System.out.println("ISO_LOCAL_TIME 형태 : " + lTime);

		String sTime2 = "03:30:30 오후";
		DateTimeFormatter tformatter = DateTimeFormatter.ofPattern("KK:mm:ss a");
		LocalTime lTime2 = LocalTime.parse(sTime2, tformatter);
		System.out.println("사용자 정의 형태(시간) : " + lTime2);

		String sTime3 = "03:30:30 PM";
		DateTimeFormatter tformatter2 = DateTimeFormatter.ofPattern("KK:mm:ss a", Locale.ENGLISH);
		LocalTime lTime3 = LocalTime.parse(sTime3, tformatter2);
		System.out.println("사용자 정의 형태(시간_로케일) : "+lTime3);

		String sDateTime = "2015-01-01T11:20:30";
		LocalDateTime ldt = LocalDateTime.parse(sDateTime);
		System.out.println("ISO_LOCAL_DATE_TIME 형태: " + ldt);
		
		String sDateTime2 = "2015년 01월 01일(목요일) 오후 03시 30분";
		DateTimeFormatter tformatter3 = DateTimeFormatter.ofPattern("yyyy년 MM월 dd일(EEEE) a KK시 mm분");
		LocalDateTime ldt2 = LocalDateTime.parse(sDateTime2, tformatter3);
		System.out.println("사용자 정의 형태(날짜_시간) : " + ldt2);
	}
}
//
ISO_LOCAL_DATE 형태 : 2015-01-01
사용자 정의 형태(날짜) : 2015-01-01
ISO_LOCAL_TIME 형태 : 03:30:30
사용자 정의 형태(시간) : 15:30:30
사용자 정의 형태(시간_로케일) : 15:30:30
ISO_LOCAL_DATE_TIME 형태: 2015-01-01T11:20:30
사용자 정의 형태(날짜_시간) : 2015-01-01T15:30


----------------------------------------------------
3. StringTokenizer 클래스를 통한 문자열 분리 

StringTokenizer는 문자열을 구분자 캐릭터를 이용해 분리해주는 클래스이다. 
예를들어 여러 개의 '이름: 값' 쌍으로 구성된 문자열이 있을 때 
이름과 값들을 쉽게 분리할수 있다. 
StringTokenizer는 분리할 문자열과 구분자를 파라미터로 받는다. 

예를들어 숫자와 쉼표로 구성된 문자열을 쉼표 기준으로 분리하기 
위한 코드를 다음과 같이 작성할수 있다. 

ex)
StringTokenizer tokens = new StringTokenizer("10,030,042,034,023",",");

StringTokenizer에는 구분자에 의해 분리된 토큰들의 정보를 알수 있는 
메서드들을 제공한다. 

다음은 StringTokenizer 클래스의 주요 메서드이다. 

메서드명 : 선언부와설명

countTokens() : public int countTokens()
소모하지 않고 남아있는 토큰의 개수를 리턴한다. 
여기서 소모의 개념은 nextToken()을 호출한 것을 말한다. 

hasMoreTokens() : public boolean hashMoreTokens()
남아있는 토큰이 있는지 여부를 리턴한다. 

nextToken() : public String nextToken()
다음 토큰을 문자열로 리턴한다. 

StringTokenizer는 구분자를 이용해서 문자열을 분리-관리한다. 
countTokens()를 사용하면 생성된 토큰의 개수를 확인할수 있다. 
주로 반복문을 통해서 토큰들을 확인하는데 hasMoreTokens()를 
이용해 토큰이 있는지 확인하고 있다면 nextToken()을 이용해서 
개별 토큰들을 사용할수 있다. 

ex)
String source = "10,030,042";
StringTokenizer tokens = new StringTokenizer(source, ",");
System.out.println("토큰의 개수: " + tokens.countTokens());
while(tokens.hashMoreTokens()){
System.out.println(tokens.nextToken());
} 

위의 예는 source 문자열을 ','를 이용해서 분리한다. 
따라서 10과 030 그리고 042 라는 3개의 토큰이 생기게 되고 
반복문을 통해 토큰들을 하나씩 빼서 출력한다. 

StringTokenizer를 사용할 때는 두가지 주의사항이 있다. 

첫번째는 countTokens()가 유동적이라는 점이다. 다음코드를 보자. 

ex2)
String source = "10,030,042";
StringTokenizer tokens2 = new StringTokenizer(source, ",");
for(int i = 0; i < tokens2.countTokens(); i++){
System.out.println(tokens2.nextToken());
} 

for 문을 이용한 아주 단순한 반복문이다. 얼른 생각하면 10, 030, 042 
가 리턴될 것 같지만, 이 코드의 실행과는 10, 030 이다. 
이유는 countTokens()는 남아있는 토큰의 개수를 리턴하는데 
이 값은 nextToken()을 호출할때 마다 하나씩 줄어든다. 
결국, 다음 그림처럼 세번째 토큰을 출력할 기회가 없는 것이다. 

따라서 적절한 for 문은 countTokens() 의 값을 미리 변수에 
할당해 놓은 후 사용하거나, hasMoreTokens() 조건을 
사용하는 것이다. 

ex3)
int cnt = tokens2.countTokens();
for(int i = 0; i < cnt; i++){
System.out.println(tokens2.nextToken());
}

for(; tokens2.hasMoreTokens(); ) {
System.out.println(tokens2.nextToken());
}

두번째 주의사항은 문자열을 토큰으로 분리할때 구분자는 문자열 
단위가 아니라 문자 단위라는 점이다. 
예를들어 구분자에 '0,'을 입력했다면, 구분자는 '0' 또는 ','가 
되고 토큰은 1, 3, 42가 된다. 

다음 예는 학생의 시험점수를 하나의 문자열 형태로 받아서 
평균을 구하는 방법을 보자. 

ex)
package ch12.token;

import java.util.StringTokenizer;

public class StringTokenizerTest {

	public static void main(String[] args) {
		String info = "이름:홍길동, Java:100, HTML:80, Script:85";
		StringTokenizer tokens = new StringTokenizer(info, ": ,");
		
		//소스와 구분자(: ,)를 이용해 StringTokenizer를 생성한다. 
		//따라서 실제로 동작하는 ':'과 '( 공백문자)' , ','의 3개로 
		//"이름", "홍길동", "Java", "100", "HTML", "80"
		//, "Script", "85"의 8개 토큰이 생성된다. 
		
		System.out.println("총 토큰의 개수: " + tokens.countTokens());
		int sum = 0;
		while(tokens.hasMoreTokens()) {
			String token = null;
			try {
				token = tokens.nextToken();
				sum += Integer.parseInt(token);
			} catch (NumberFormatException e) {
				System.out.println("숫자 아님: " + token);
				
				// 반복문을 이용해서 토큰을 사용한다. 
				//토큰은 String 형태로 얻을 수 있기 때문에 
				// 점수를 숫자로 변경하기 위해 Interger의 parseInt()를 
				// 사용한다. 만약, 숫자 형태가 아니라면 NumberFormatException이 
				//발생하므로 try ~ catch 블록으로 처리한다. 
			}
		}
		System.out.println("총점: " + sum);
	}
}
//
총 토큰의 개수: 8
숫자 아님: 이름
숫자 아님: 홍길동
숫자 아님: Java
숫자 아님: HTML
숫자 아님: Script
총점: 265



----------------------------------------------------
4. 형식화 클래스

많은 경우 프로그래밍에서 유용한 형식과 화면에서 유용한 데이터의 
형태는 다르다. 프로그램에서 유용한 형식은 데이터 자체가 많은 정보를 
가지는 경우로 객체일 경우가 많다. 
객체를 통해 다양한 속성과 기능들을 사용할수 있기 때문이다. 
하지만 화면에 출력될 때는 오로지 문자열만 의미 있기 때문에 사람이 
읽을수 있도록 가시성 좋은 표현이 필요하다.
그래서,Object 의 toString() 메서드를 오버라이딩해서 사용한다. 

하지만, 오버라이딩해서 사용하기 어려운 형태가 두 종류있다. 
바로 객체가 아닌 기본형 중 숫자와 다양한 형태로 출력될수 있는 
Date 클래스이다. 
예를들어 100000000은 쉽게 읽기 어렵다. 
100,000,000 과 같이 천단위 구분자가 있다면 좀더 읽기 쉬울걸이다. 
하지만, 100,000,000은 숫자가 아닌 문자열이다. 
숫자에는 ',' 가 들어갈수 없기 때문이다. 
이처럼 숫자 또는 Date 를 읽기 쉬운 문자열로 바꾸는데 사용되는 
클래스를 형식화 클래스라고 한다. 
형식화 클래스는 DecimalFormat과 SimpleDateFormat이 있다. 


4.1 DecimalFormat 클래스 

DecimalFormat은 숫자에 대한 형식화 클래스이다. 이런 형식화 클래스에서 
패턴을 만들고 적용하는 방법은 앞서 살펴봤던 DateFormatter에서의 방법과 
유사하다. 먼저 지정된 기호들을 조합해서 패턴을 만들고 그것을 이용해 
데이터를 문자열로 만들거나 거꾸로 문자열을 데이터로 변환한다. 

다음은 DecimalFormat에서 사용되는 기호와 사용예를 보여준다. 

DecimalFormat의 주요 패턴 기호 

기호 : 의미 : 예(1234.5에 패턴을 적용했을 경우)

0 : 0~9, 값이 없으면 0으로 채움 : 0->1234,
0.0 -> 1234.5 , 00000.00 -> 01234.50 

# : 0~9 : # -> 1234 , #.# -> 1234.5 , #####.## -> 1234.5

. : 소수 구분 기호 

- : 마이너스 표시 : -#.# -> -1234.5

, : 1,000 단위 그룹 구분자 -> #,###.# -> 1,234.5

E : 과학 표기법에서의 지수 문자 : 0.0E0 -> 1.2E3

% : 100이 곱해진 값으로 퍼센트(%) : #,###.##% -> 123,450%

\u2030 : 1000이 곱해진 값으로 퍼밀 (‰) : #,###.##\u2030 -> 1,234,500‰

\u00A4 : 통화 기호. 두 개가 사용되면 국제 통화 기호로 대체됨.
\u00A4#,###.## -> ￦1,234.5
\u00A4\u00A4#,###.## -> ￦1,234.5

사용할 패턴을 결정했다면, DecimalFormat의 생성자에 패턴을 넘겨주고 
객체를 생성할수 있다. 

ex)
DecimalFormat df = new DecimalFormat("#,###.#");

이제 DecimalFormat을 이용해서 parse()와 format()을 처리한다. 
앞서 DateFormatter에서의 밝혔듯이 parse()는 문자열을 데이터로 
만드는 과정이고, format()은 데이터를 문자열로 만드는 과정이다. 
applyPattern()은 기존의 DecimalFormat 객체에 새로운 패턴을 
적용한다. 

DecimalFormat의 주요 메서드 

메서드명 : 선언부와설명

format() : public final String format(double number)
number를 패턴에 의해 문자열로 변환 후 리턴한다. 

parse() : public Number parse(String source) throws ParseException
source 를 패턴에 의해 Number로 변환 후 리턴한다. 

applyPattern() : public void applyPattern(String pattern)
새로운 패턴을 DecimalFormat 객체에 적용한다. 

다음_예는 숫자를 통화기호가 붙은 문자열로 표현하고 
다시 숫자로 변환하는 과정을 보여준다. 

ex)
package ch12.format;

import java.text.DecimalFormat;
import java.text.ParseException;

public class DecimalFormatTest {

	public static void main(String[] args) throws ParseException {
		double orgNum = 1234.5;
		//DecimalFormat df = new DecimalFormat("\u00A4#,###.#");
		DecimalFormat df = new DecimalFormat("￦#,###.#");
		System.out.println(df.format(orgNum));
		String orgStr = "￦1,234.5";
		double parsed = (double) df.parse(orgStr);
		System.out.println(parsed);
		
		df.applyPattern("#.#%");
		System.out.println(df.format(parsed));
	}
}

//
￦1,234.5
1234.5
123450%

Note 
막상 한글 통화 기호를 입력하려면 당황스러울때가 있다. 
키보드에 있는 통화기호처럼 보이는 것은 백슬래시로 정식 통화 
기호가 아니며 심지어 사용하는 폰트에 따라 다르게 표시된다. 
정식적인 한글 통화 기호는 다음과 같이 Currency 클래스를 이용한다. 

ex)
String symbol = Currency.getInstance(Locale.KOREA).getSymbol();

간단히 입력할 때는 통상'ㄹ' 입력 후 한자키를 눌러 특수 문자 입력 
보드로 변경 후 3 번째에 있는 '￦' 를 사용하기도 한다. 

----------------------------------------------------
4.2 SimpleDateFormat 클래스

SimpleDateFormat은 DateFormatter와 마찬가지로 날짜/시간 정보에 
대한 패턴을 지정해서 파싱과 포멧팅을 처리한다. 
차이점은 SimpleDateFormat은 Date 객체에 대해서 사용된다는 점이다. 
SimpleDateFormat에서 패턴 작성을 위해 사용되는 기호들은 
DateFormatter에서 사용되는 것과 동일하다. 

SimpleDateFormat을 생성할 때에는 DecimalFormat과 마찬가지로 
생성자에 패턴 문자를 전달하면 되고 이후 format()과 parse()
메서드를 사용할수 있다. 

ex)
SimpleDateFormat sdf = new SimpleDateFormat("yyyy년 MM월 dd일 E요일");
System.out.println(sdf.format(date));

SimpleDateFormat에서 사용하는 메서드들은 DecimalFormat의 메서드들과 
동일하다. 
단지 파라미터와 리턴 타입이 약간씩 차이가 있을 뿐이다. 

SimpleDateFormat의 주요 메서드 

메서드명 : 선언부와 설명 

format() : public final String format(Date date)
date를 패턴에 의해 문자열로 변환 후 리턴한다. 

parse() : public Date parse(String source) throws ParseException
문자열을 패턴에 의해 Date로 변환 후 리턴한다. 

applyPattern() : public void applyPattern(String pattern)
새로운 패턴을 SimpleDateFormat 객체에 적용한다. 

다음은 날짜 형태의 문자열을 다른 형태의 문자열로 출력하기 
위한 과정을 보여주는 예

ex)
package ch12.format;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class SimpleDateFormatTest {

	public static void main(String[] args) throws ParseException {

		String source = "2020년 12월 25일";
		System.out.println(source+"를 요일 정보까지 출력하려면?");
		
		SimpleDateFormat format = new SimpleDateFormat("yyyy년 MM월 dd일");
		Date parsed = format.parse(source);
		
		format.applyPattern("yyyy년 MM월 dd일(E)");
		System.out.println(format.format(parsed));
	}
}
//
2020년 12월 25일를 요일 정보까지 출력하려면?
2020년 12월 25일(금)

----------------------------------------------------
4.3 MessageFormat 클래스 

문자열을 구성하다 보면 String과 다른 String , 기본형, 
객체들을 연결하는 경우가 많이 발생한다. 이런 경우
일반적으로 '+' 연산자를 사용한다.

String source = "Java: " + 100 + ", HTML: " + 90 + ", result: " +
'A';
아주 간단하기 때문에 자주 사용되기는 하지만 계속되는 '+'로 
인해 지저분해 보이고 한눈에 파악하기가 어렵다. 
이때 MessageFormat 을 이용하면 데이터를 변수 처럼 사용해서
메시지 패턴에 적용할수 있다. 

ex)
String pattern = "Java: {0}, HTML: {1}, result: {2}" ;
String result = MessageFormat.format(pattern, 100, 90, 'A');
System.out.println(result); // Java: 100, HTML: 90, result: A 
String result2 = MessageFormat.format(pattern, new Object[] {100,90,'A'});

패턴을 작성할때는 삽입될 데이터 위치에 파라미터가 들어온다는 
의미로 중괄호와 함께 데이터의 인덱스 번호를 써준다.
MessageFormat의 static 메서드인 format()에는 패턴과 함께 패턴의
파라미터에 사용될 값들이 가변인수(Varargs)형태로 전달된다. 
만약 패턴의 파라미터 개수가 가변인수의 개수보다 많으면 
파라미터 선언 그대로 출력된다. 
가변인수 대신 배열을 이용해서 값을 전달할 수도 있다. 

ex)
package ch12.format;

import java.text.MessageFormat;
import java.text.ParseException;

public class MessageFormatTest {

	public static void main(String[] args) throws ParseException {
		String pattern = "이름: {0}, Java: {1}, HTML: {2}, Script: {3}";
		String src = "홍길동:100:90:85,임꺽정:90:95:70,장길산:75:85:90";
		String [] studentInfo = src.split(",");
		for(String student: studentInfo) {
			System.out.println(MessageFormat.format(pattern, student.split(":")));
		}
	}
}
//
이름: 홍길동, Java: 100, HTML: 90, Script: 85
이름: 임꺽정, Java: 90, HTML: 95, Script: 70
이름: 장길산, Java: 75, HTML: 85, Script: 90

주의, 
위와 같이 코드를 작성하면 13행에 경고(warning)가 하나 발생한다. 
내용은 MessageFormat의 format()은 Object... 형태의 파라미터를 
받는데 실제 타입은 String... 이어서 타입이 정확히 일치하지 않는다는 
오류 메시지다. 이는 이클립스에서 프로그램의 안정성을 위해 출력하는 
경고 메시지로 무시해도 지장은 없다. 하지만 좀 꺼림칙하다면 
Window -> Preference -> Java -> Compiler -> Errors/Warnings
-> Potential programming problems 항목에서 
inexact type match for vararg arguments의 항목을 Ignore로 
변경한다.
또는 소스 코드에서 문제를 해결하려면 Object[]로 
student.split(":")를 형변환해서 사용한다.
System.out.println(MessageFormat.format(pattern, student.split(":")));
System.out.println(MessageFormat.format(pattern, (Object[])student.split(":")));

----------------------------------------------------
5. 정규표현식 처리 

정규표현식(Regular Expression: regexp)이란 문자열을 처리하는 방법으로 
패턴 기반의 특정한 조건에 맞는 문자를 검색하거나 치환하는데 사용된다. 
흔히 웹 페이지를 사용하다 보면 이메일이나 전화번호 등이 지정된 
형식에 맞는지, 비밀번호의 복잡도에 특수문자, 영문자, 숫자 등이 
섞여 있는지 등을 확인해야 하는 경우가 많다. 이 과정을 입력 값 
검증 즉 validation 체크라고 한다. 

이런 입력 값을 검증할때 사용자가 입력한 문자열을 파악해서 양식에 
맞는지 파악하기는 매우 어려운일이다. 이때 정규표현식을 이용하면
아주 쉽게 문자열을 분석하고 우리가 원하는 형태인지 파악할수 있다.
정규표현식은 자바 언어만을 위한 것이 아니라 자바스크립트, SQL ,
파이썬 등 다양한 분야에서 활용되므로 복잡하지만 한번 잘 익혀 놓으면
활용할 곳은 아주 많다. 

정규표현식을 작성할때는 일정한 패턴의 문자를 '/'로 감싸서 표현하며 
필요하다면 뒤에 플래그를 추가할수도 있다. 

ex)
/패턴/[플래그]

5.1 정규표현식 표현 방법 

먼저 정규표현식의 패턴 작성법에 대해 알아보자.
정규표현식의 패턴은 표준인 POSIX(Portable Operation System Interface)
형식과 언어별 확장 표현이 있는데 대부분 유사하므로 표준 방식만 익혀도 
큰 무리가 없다. 정규표현식에서 사용하는 기호들을 메타 문자(Meta 문자)라고 
한다. 메타 문자는 표현식 내에서 특정한 의미를 갖는다. 

메타 문자와 그 의미를 https://regexper.com 에서 제공하는 
레일로드 다이어그램(railroad diagram)형태로 알아보자. 

(1) 기본 메타 문자 활용 

메타 문자 : 레일로드 다이어그램 : 의미 

^x : Start of line -- "x" : 문자열이 x로 시작한다. 
ex) x,  xa,  xb, ...

x$ : "x" -- End of line : 문자열이 x로 끝난다.
ex) x, ax, bx, ...

.x : any character -- "x" : x 앞에 어떤 문자가 하나 있다. 
ex) ax, bx, 

x+ :  "x " loop 그림 : x 가 1번 이상 반복될수 있다. 
ex) x, xx, xxx, ...

x? : "x"  위로 선 : x 가 나오거나 안 나올수 있다.
ex) x,  ,  a 

x* : "x" 위로 선, loop 그림 : x가 0번 이상 반복될수 있다. 
ex) a,  x,  xx,  xxx, ...,

x│y : "x" 위에 , "y" 아래 : x 또는 y가 올수 있다. 
ex) x , y 

이런 문자들은 단독으로 사용되지 않고 여러 개가 묶여서 
사용된다. 

다음 예들을 살펴보자. 

ex1)
xa?y$ : 시작은 관계없이 x 뒤에 a가 있거나 없고 y로 끝난다. 
따라서 xy, hixy, hixay는 괜찮지만 xaay는 안된다.

ex2)
x│a?y$ : 연산자 우선순위에서 │의 우선순위가 가장 낮다. 
x 또는 a?y$가 적용된다. 
xy, hixay, xaa 등은 적합하지만, ay2는 부적합.

(2) 괄호의 활용 

정규표현식 : 레일로드 다이어그램 : 의미 

(xy) : group #1 "xy" : 괄호 안의 내용을 하나로 그룹화한다.

x{n, m} : "x" 1..4 times :
{} 앞의 내용이 최소 n번이상 m 번 이하까지 등장한다.
{n}: n 번 반복됨 
{n, } : n번 이상 반복됨.
{n,m} : n번 이상, m번 이하 반복됨 

[xy] : One of "x" 밑에 "y" : []안의 문자중 하나가 나와야 한다. 
[xy] : x 또는 y
[a-z] : 알파벳 소문자 a~z 
[0-9] : 숫자 
[가-힣] : 한글 

[^x] : None of "x" : [] 안에서의 ^는 부정을 의미한다. 
[^0-9] : 숫자가 아닌 것 

()는 내용을 그룹화할 때 사용한다.

- ^(abc)(def)+(ghi)$라는 패턴은 abc로 시작하고 def가 한번이상 
나오고 ghi로 끝나야 한다. 따라서 abcdefghi, abcdefdefghi는 적합,
abcdeghi는 부적합. 

{} 는 내용의 반복 횟수를 지정할수 있다. 

- (a1){2}b{2,4}c{2, } 패턴은 a1이 두번 나오고 
b가 2에서 4번, c가 두번이상 나와야한다.
따라서 a1a1bbcc의 경우는 적합,
a1a1bbbbbbcc 는 부적합.

[] 표기법은 문자의 구성요소를 확인할 때 많이 사용된다. 

- [a-z]{2}[0-9][가-힣][^A-Z]는 
영어 소문자 두 개, 숫자 하나, 한글 하나, 대문자가 아닌 것 하나를 의미.
따라서 aa1홍a , aa1홍2 적합,
aa1홍A는 부적합. 

(3) 예외문자처리
예외 문자를 처리할 때는 '\'를 사용한다. 예를들어 물음표나 
마침표를 표현하고 싶은데 이것들은 이미 정규표현식에서 
각각 특별한 의미를 지니고 있다. 따라서 의미 있는 기호로 
해석하지말고 글자 그대로 처리하라는 의미로 '\'을 붙여준다. 

- .x : x 앞에 어떤 문자가 하나 나와야 한다. 

- \.x : x 앞에 단순히 '.'가 있다. 

정규표현식에는 '\'를 이용한 축약형이 많은데 일괄적으로 소문자는 적용되는 
것을 찾는 것이고 대문자는 적용되지 않는 것을 찾는다. 

정규표현식 : 레일로드 다이어그램 : 의미 

\^ : "^" : \ 뒤에 나오는 문자를 기호로 처리하지 않는다.

\b : word boundary :단어의 경계를 찾는다

\B : non word boundary : 단어의 경계가 아닌 것을 찾는다. 

\d : digit : 숫자를 찾는다. 

\D : non-digit : 숫자가 아닌 것을 찾는다. 

\s : white space : 공백 문자를 찾는다.

\S : non-white space : 공백 문자가 아닌 것을 찾는다.

\w : word : 단어를 구성하는 알파벳, 숫자, _를 찾는다. 
[a-zA-Z0-9_]와 동일하다.

\W : non-word : 알파벳, 숫자, _를 제외한 문자를 찾는다. 
[^a-zA-Z0-9_]와 동일하다.

41/53 486

- \b 와 \B는 이해하기가 좀 어렵다. 다른 메타 문자들이 
특정 텍스트의 집합을 매칭시키는 것과 달리 이 둘은 단어의 
경계(boundary)를 가리킨다. 여기서 단어란 \w 즉, 
[a-zA-Z0-9_] 와 동일하다. 경계라는 말은 특정 문자가 아닌 
위치를 가리키기 때문에 패턴이 일치하더라도 매치되는 길이가 
0이 된다. 예를 들어 'Do you like lily?'에서 \b 와 \B의 위치를 
'*'로 나타내면 다음과 같다. 

ex)
\b : *Do* *you* *like* *lily*?
\B : D*o y*o*u l*i*k*e l*i*l*y?

따라서 '\bl'은 단어 경계뒤에 'l'이 나와야 하므로 밑줄로 
표시하면 Do you like lily?에서 
밑줄은 like의 'l', lily 의 앞의 'l' 이다. 
'\Bl'은 단어 경계뒤에 'l'이 나오지 않아야 하므로 역시 
밑줄로 표시하면 Do you like lily?가 된다. 
밑줄은 lily 의 두번째 'l' 

\Bl 다시 , 단어의 경계뒤에 l 이 아닌것은 이렇게 이해

- 숫자 입력이 필요한 경우 [0-9] 그렇지 않으면 
[^0-9]를 쓸수 있지만, 대신 \d와 \D를 사용할수 있다. 

ex)
a\dg\Dh 라는 패턴은 a, 숫자, g , 숫자가 아닌 것, h 순서대로 나와야한다

a3gAh 적합, adagah, a3g4h 등은 부적합. 

- 공백 문자는 공백, 탭, 엔터를 의미한다. 

ex2)
a\sb\Sc 라는 패턴은 a, 공백, b , 공백이 아닌문자, c가 순서대로 나와야한다

a boc는 적합, ab c 나 a b c 등 부적합. 

a boc는 적합, ab c 나 a b c 등 부적합. 

487 42/53

-일반적으로 단어를 구성하는 문자로는 알파벳, 숫자, _ 를
사용한다. (한글은 해당안됨.)

ex3)
^\w.. 라는 패턴은 단어를 구성하는 글자 하나로 시작해서 
어떤 문자가 두개 오면 된다. 
start of line - word - any_character- any_character
abc, _ab, 123 적합.  .aa, 한글 자 등은 부적합. 

(4) 유용한 정규표현식의 예 
자주 사용되는 구문들을 만들어 보자. 

- 한글이름: ^[가-힣]{2,5}$
Start_of_line - "가"-"힣"  : 2번이상 ~ 5 번 이하 반복 - End_of_line 

-휴대전화번호: 
^(010|011)[-\s]?\d{3,4}[-\s]?\d{4}$

Start_of_line - group1 "010" or "011"- One of : "-" or "(공백)"
digit 3번이상 4번 이하, One of : "-" or "(공백)"
digit 4번 - End_of_line

- 이메일 주소의 표현 
^[\w\.-]{1,64}@[\w\.-]{1,252}\.\w{2,4}$

Start_of_line - One_of : word , ".", "-" 1번이상 64번이하
"@"
One_of : word , ".", "-" 1번이상 252번이하
"."
word 2번이상 4번이하
End_of_line

----------------------------------------------------
5.2 플래그 

플래그는 이제까지 학습한 패턴을 적용하는 방식을 결정하는데 
자주 사용되는 플래그는 다음과 같다. 

플래그  :  설명 
g : Global : 문자열 내의 모든 패턴을 찾는다. 
i : Ignore Case : 문자열의 대소문자를 구별하지 않는다. 
m : Multi line : 문자열이 행이 바뀌어도 찾는다. 

정규표현식을 작성할때는 /패턴/[플래그] 형태로 사용한다. 

예를 들어 
기본 : Hello , Java , Lily 
(1)
/l/ 
Hello 의 첫번째 l 
(2)
/l/g 
Hello 의 l, l 둘다 
Lily 의 l 하나 
(3)
/l/gi
Hello 의 l,l 둘다 
Lily 의 L, l 둘다 
(4)
^[HJL]/g
Hello 의 H 하나 
(5)
^[HJL]/gm
Hello 의 H 하나 
Java 의 J 하나 
Lily 의 L 하나 

만약 패턴만으로 작성 정규표현식 /l/이 있다면 
이식을 만족시키는 표현은 (1) 번처럼 
맨 처음 매칭 부분을 발견하고 끝낸다. 

하지만 /l/g와 같이 플래그를 추가하면 전체에서 
매칭되는 문자열을 찾으므로 (2)번결과 처럼 
총 3개가 매칭된다. 

플래그는 여러개 중복해서 사용할수 있는데 (2)번 정규표현식 뒤에 
i를 추가하면 대소문자 구별을 없애 준다. 
따라서 (3)번의 결과를 얻을수 있다. 

m 즉 멀티행은 시작(^)과 끝($)을 각 문장마다 처리한다. 
이 플래그가 없다면 데이터가 여러 줄로 구성된 경우 시작과 끝에 
대한 점검을 1회만 한다. 즉 (4) 와 같다. 
m 플래그를 추가하면 (5)번 처럼 각 행마다 별도로 시작과 끝을 
확인 하게 된다. 
----------------------------------------------------
5.3 정규표현식을 사용하는 클래스

정규표현식을 자바에서 사용하기 위해서는 
java.util.regex.Pattern 과 java.util.regex.Matcher 
클래스가 주로 사용 된다. 

(1) Pattern 클래스 
Pattern 클래스는 정규표현식을 컴파일해서 관리한다. 
이 클래스는 public 한 생성자를 제공하지 않고 정적인 compile() 
메서드에 문자열 형태의 정규표현식을 넘겨주면 Pattern 객체를 
생성할 수 있다. 본격적인 정규표현식의 사용은 matcher() 메서드에 
분석하려는 문자열을 넘겨줘서 생성되는 Matcher 를 활용한다. 
또는 간단히 정규표현식에 문자열이 적합한지 확인하기 위해서는 matches()를 
사용할수 있다. 
다음은 Pattern 클래스에 선언된 주요 메서드 들이다. 

메서드명 : 선언부와 설명 
complie() : public static Pattern complie(String regex)
정규표현식 regex을 이용해 Pattern 객체를 생성하고 리턴한다. 

matcher() : public Matcher matcher(CharSequence input)
input 을 분석할수 있는 Matcher 객체를 리턴한다. 

matches() : public static boolean matches(String regex, CharSequence input)
input이 regexp에 부합하는지를 리턴한다. 

ex)
package ch12.regexp;

import java.text.MessageFormat;
import java.util.regex.Pattern;

public class RegexpTest {

	public static void main(String[] args) {
		String regexp = "^(010|011)[-\\s]?\\d{3,4}[-\\s]?\\d{4}$";
		String[] numbers = {
				"010-000-1234",
				"01112345678",
				"010)1234 5678",
				"010 1234 567a" };
		String resultPattern = "{0}는 전화번호 타입인가? {1}";
		for (String number : numbers) {
			boolean result = Pattern.matches(regexp, number);
			System.out.println(MessageFormat.format(resultPattern, number, result));
		}
	}
}
//
010-000-1234는 전화번호 타입인가? true
01112345678는 전화번호 타입인가? true
010)1234 5678는 전화번호 타입인가? false
010 1234 567a는 전화번호 타입인가? false

(2) Matcher 클래스 
Matcher 클래스는 패턴을 해석하고 입력 문자열에 대해 일치하는지 
파악하는 역할을 수행한다. 
Pattern과 마찬가지로 공개된 생성자는 없으며 Pattern의 matcher()를 
통해서 얻을수 있다. Pattern은 간단히 문자열이 정규표현식에 부합하는지만 
확인할수 있지만, Matcher는 문자열이 정규표현식의 내용을 가지고 있는지,
위치는 어디인지등 자세한 정보를 알수 있다. 

Matcher의 주요 메서드들. 

메서드명 : 선언부와설명

find() : public boolean find()
문자열 내에서 정규표현식에 부합되는 내용이 있는지 여부를 리턴한다. 
이때 start()의 리턴 값에서부터 검색한다. 

start() : public int start()
패턴에 부합되는 요소의 시작 인덱스를 리턴한다. 

end() : public int end()
패턴에 부합되는 요소의 끝 인덱스+1 를 리턴한다. 

matches() : public boolean matches()
비교하려는 문자열 전체가 정규표현식과 일치하는지를 리턴한다. 

lookingAt() : public boolean lookingAt()
비교하려는 문자열이 정규표현식으로 시작하는지를 리턴한다. 
이때 언제나 문자열의 0번 인덱스부터 검색한다. 

replaceFirst() : public String replaceFirst(String replacement)
문자열 중 정규표현식과 일치하는 처음 요소의 값을 replacement로 대체한다. 

replaceAll() : public String replaceAll(String replacement)
문자열 중 정규표현식과 일치하는 모든 요소의 값을 replacement로 대체한다. 

reset() : public Matcher reset()
Matcher 의 정보를 리셋해서 0번 인덱스부터 다시 검색하게 한다. 

Matcher에는 문자열과 정규표현식과의 관계를 조사하는 다양한 
메서드가 제공된다. 
matches()는 Pattern의 matches()처럼 전체 문자열이 정규표현식에 부합되는지
검사한다. lookingAt()은 문자열의 시작이 정규표현식에 부합되는지는 
검사한다. find()는 이전 검색 결과의 다음 위치에서부터 검색한다. 
따라서 몇번이나 포함되어 있는지를 알수 있다. 
다음 그림은 주어진 문장에서 'Java'를 찾는 3가지 메서드의 검색 기준을 
표현한다. 

<---------------------------matches()---->
<----lookingAt
Java and JavaScript has no relation
<-->     <-->
find()   find()

matches()와 lookingAt(), find()의 차이 

start()는 찾은 요소의 시작 인덱스, end() 는 찾은 요소의 
(인덱스+1)을 리턴한다. 다음 그림은 주어진 문장에서 
문자열"Java"를 찾았을 때 start()와 end()의 위치이다. 

Java and JavaScript
"j" -> start(0) == 0
"Java"의 옆 공백 -> end() == 4

ex)
package ch12.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class UseMatcherTest {

	public static void main(String[] args) {
		String src = "A Java and JavaScript has no relation";
		// lookingAt()은 문자열의 시작만 표현식에 일치하면 되는데,
		// 일치 안해서 false
		
		String regexp = "Java";
		Pattern pattern = Pattern.compile(regexp);
		Matcher matcher = pattern.matcher(src);
		
		System.out.println("완전히 일치 되는가? " + matcher.matches());
		System.out.println("정규 표현식을 포함하는가? " + matcher.lookingAt());
		
		matcher.reset();
		int cnt = 0;
		while (matcher.find()) {
			cnt++;
			int start = matcher.start();
			int end = matcher.end();
			System.out.println(cnt + ":(" + start + "," + end + ")" + src.substring(start, end));
		}
		
		String replaced = matcher.replaceAll("Some");
		System.out.println(replaced);
	}
}
//
완전히 일치 되는가? false
정규 표현식을 포함하는가? false 
1:(2,6)Java
2:(11,15)Java
A Some and SomeScript has no relation

마지막으로 정규표현식을 이용해 비밀번호의 복잡성을 테스트하는 예를 
살펴보자.  여기서 비밀번호는 영문, 숫자, 특수문자 중 두가지 
이상의 조합으로 8자리 이상의 문자열이 필요하다고 가정한다. 

ex)
package ch12.regexp;

import java.util.regex.Pattern;

public class PasswordValidationTest {

	public static void main(String[] args) {
		String[] passwords = {
				"abcde한글124",
				"abc!12",
				"abcdefghij",
				"abcdef!@",
				"abc123!@#"
		};

		for (String password : passwords) {
			String lenReg = "[a-zA-Z0-9!@#$%]{8,}";
			String engReg = "[a-zA-Z]";
			String numReg = "[0-9]";
			String specReg = "[!@#$%]";
			System.out.print(password+"는 ");
			int has = 0;
			if (Pattern.matches(lenReg, password)) {
				has += Pattern.compile(engReg).matcher(password).find() ? 1 : 0;
				has += Pattern.compile(numReg).matcher(password).find() ? 1 : 0;
				has += Pattern.compile(specReg).matcher(password).find() ? 1 : 0;
				if (has < 2) {
					System.out.println("영문, 숫자, 특수문자 중 두 가지 이상이 조합되어야 합니다.");
				} else {
					System.out.println("적합한 패스워드 입니다.");
				}
			} else {
				System.out.println("영문, 숫자, 특수문자로 8자 이상이어야 합니다.");
			}
		}
	}
}
//
abcde한글124는 영문, 숫자, 특수문자로 8자 이상이어야 합니다.
abc!12는 영문, 숫자, 특수문자로 8자 이상이어야 합니다.
abcdefghij는 영문, 숫자, 특수문자 중 두 가지 이상이 조합되어야 합니다.
abcdef!@는 적합한 패스워드 입니다.
abc123!@#는 적합한 패스워드 입니다.

----------------------------------------------------
6. 숫자 관련 처리 

6.1 java.util.Random 클래스 

앞서 Math.random()을 통해서 주사위를 구현하는 예제를 작성해보았다. 
이 random()은 0~1 사이의 double을 리턴하기 때문에 원하는 정수를 
만들기 위한 과정이 추가로 필요했다. 하지만,
java.util.Random은 double은 물론 int 와 같은 다양한 타입의 
무작위 수를 리턴받을수 있다. 

java.util.Random의 주요메서드 

메서드명 : 선언부와설명

nextInt() : public int nextInt()
int 범위의 무작위 int 값을 리턴한다. 

public int nextInt(int bound)
0 <= x < bound 사이의 무작위 int를 리턴한다. 

nextLong() : public long nextLong()
long 범위의 무작위 long 값을 리턴한다. 

nextBoolean() : public boolean nextBoolean()
무작위로 true/false 를 리턴한다. 

nextFloat() : public float nextFloat()
0.0f <= x < 1.0f 사이의 무작위 float를 리턴한다. 

nextDouble() : public double nextDouble()
0.0 <= x < 1.0 사이의 무작위 double을 리턴한다. 

다음 예제는 주사위 놀이를 하면서 무작위로 한번더 던질수 있는 
기회를 얻도록 프로그래밍 한것이다. 

ex)
package ch12.number;

import java.util.Random;

public class RandomTest {
	public static void playDice(Random random) {
		int step = random.nextInt(6);
		System.out.println((step + 1) + "만큼 전진");
	}
	
	public static void main(String[] args) {
		Random random = new Random();

		playDice(random);
		if (random.nextBoolean()) {
			System.out.println("보너스 스테이지");
			playDice(random);
		}
	}
}
//
3만큼 전진
보너스 스테이지
3만큼 전진


----------------------------------------------------
6.2 java.math.BigInteger 클래스 

long 이 제법 큰 범위의 정수를 표현할수 있지만, 여전히 그 한계는 있다. 
Number를 상속받은 BigInteger는 말 그대로 큰 정수를 표현하는 클래스이다. 
이 클래스는 내부적으로 int [] 에 값을 저장한다. 따라서 배열의 크기만 
커지면 아무리 큰 수도 저장할수 있게 된다. 

(1) 객체의 생성과 값 활용 

BigInteger는 생성자에 정수 형태의 문자열을 넘겨주면서 생성 하는 것이 
일반적이다. 이후 xxValue()나 xxValueExact()처럼 exact 가 붙은 
메서드들을 제공한다. 여기서 xx는 int, long, float, double 타입이다. 
둘의 차이점은 BigInteger가 가진 값이 변환하려는 타입의 범위 내에 
있는가에 있다. xxValue()는 값이 타입의 범위는 넘는 경우 내부적으로
형변환 처리해서 표현 못할 부분을 잘라내고 표현하지만, 
xxValueExact()는 범위를 넘어가면 java.lang.ArithmeticException을 
발생시킨다. 

ex) BigInteger 객체의 생성과 값 활용.
String largeNum = "12345678901234567890" 
-> BigInteger bi = new BigInteger(largeNum);
-> long num = bi.longValue();
//-6101065172474983726
-> long num = bi.longValueExact();
// ArithmeticException

(2) 기본 연산 

BigDecimal은 연산자가 아닌 메서드를 이용해서 사칙연산(+,-,*,/)
과 모듈러스 연산(%)을 처리한다. 이 연산 결과는 다시 
BigDecimal을 리턴한다. BigDecimal은 String과 마찬가지로 변경
불가한(immutable) 클래스이므로 리턴된 객체는 원래의 객체와 다르다. 

BigInteger 클래스의 주요 메서드 

메서드 명 : 선언부와설명

add() : public BigInteger add(BigInteger val)
val 을 더한 결과를 값으로 갖는 BigInteger를 리턴한다. 

subtract() : public BigInteger subtract(BigInteger val)
val을 뺀 결과를 값으로는 갖는 BigInteger를 리턴한다. 

multiply() : public BigInteger multiply(BigInteger val)
val과의 곱을 값으로 갖는 BigInteger를 리턴한다. 

divide() : public BigInteger divide(BigInteger val)
val로 나눈 몫을 값으로 갖는 BigInteger를 리턴한다. 

remainder() : public BigInteger remainder(BigInteger val)
val로 나눈 나머지를 값으로 갖는 BigInteger를 리턴한다. 

mod() : public BigInteger mod(BigInteger m)
m으로 나눈 나머지를 값으로 갖는 BigInteger를 리턴한다. 
단, m이 음수면 ArithmeticException이 발생한다. 

ex)
BigInteger 클래스의 활용 예 

package ch12.number;

import java.math.BigInteger;

public class BigIntegerTest {
	public static void createAndConvert() {
		// long l1 = 12345678901234567890L; - long의 범위를 벗어나는 정수
		BigInteger bi = new BigInteger("12345678901234567890");
		System.out.println(bi.longValue()); // 값의 잘림
		try {
			System.out.println(bi.longValueExact());// 예외 처리
		} catch (Exception e) {
			System.out.println("범위를 벗어남");
		}
		System.out.println(bi.doubleValue());
	}

	public static void simpleOperation() {
		BigInteger b1 = new BigInteger("1234567890");
		BigInteger b2 = new BigInteger("9876543210");
		System.out.println("연산 결과: " + b2.subtract(b1));
		System.out.println("원판 불변: " + b2);
	}

	public static void main(String[] args) {
		createAndConvert();
		simpleOperation();
	}
}
//
-6101065172474983726
범위를 벗어남
1.2345678901234567E19
연산 결과: 8641975320
원판 불변: 9876543210

----------------------------------------------------
6.3 java.math.BigDecimal 클래스 

BigInteger가 정수형 기본형을 확장한 클래스라면 BigDecimal은 
실수형 기본형을 확장한 클래스이다. BigDecimal 클래스를 사용하는 
주요 이유는 정확도에 있다. 앞서 실수형의 연산에서 배웠듯이 
실수는 정확하지 않다. 

ex)
double d1 = 2.0;
double d2 = 1.1;
double d1 = d1 - d2;
System.out.println("결과비교:d3: " +d3);
//결과비교 : d3:0.899999999999999

BigDecimal을 이용하면 실수의 연산을 정확히 처리할수 있다. 

(1) 객체의 생성과 값 활용 
BigDecimal은 여러모로 BigInteger와 유사하다. Number 클래스를 
상속받았으며 내부적으로 char[]에 값을 저장하며 변경 불가능한
클래스이다.

객체를 생성할때는 문자열을 이용할수도 있고 기본형을 이용할수도 있다.
주의할 점은 기본형을 이용할 경우 정확도를 기대할수 없다는 점이다. 
따라서 가급적 문자열을 이용해서 객체를 만들도록 하자.

ex)
BigDecimal b1 = new BigDecimal(2.0);
// 여전히 부정확한 연산 결과 발생 
BigDecimal b1 = new BigDecimal("2.0");

값의 활용이나 기본 연산자의 경우 BigInteger와 유사한 형태의 
메서드들을 제공하므로 관련 내용은 BigInteger의 설명을 참조한다. 

ex2)
package ch12.number;

import java.math.BigDecimal;

public class BigDecimalTest {

	public static void main(String[] args) {
		double d1 = 2.0;
		double d2 = 1.1;
		System.out.println(d1-d2);
		
		BigDecimal bd1 = new BigDecimal("2.0");
		BigDecimal bd2 = new BigDecimal("1.1");
		System.out.println(bd1.subtract(bd2));

		BigDecimal bd3 = new BigDecimal(2.0);
		BigDecimal bd4 = new BigDecimal(1.1);
		System.out.println(bd3.subtract(bd4));
	}
}
//
0.8999999999999999
0.9
0.899999999999999911182158029987476766109466552734375


===================================
[자바 해바라기 정리] 13 컬렉션 프레임워크 

컬렉션 프레임워크는 java.util에 있는 일련의 클래스들로 자바에서 
자료구조를 담당한다. 
자료구조란(data structure) 전산학에서 대량의 데이터를 효율적으로
이용할수 있도록 컴퓨터에서 데이터를 추가, 조회, 수정, 삭제 
(CRUD - Create, Retrieve, Update, Delete)하는 방식을 말한다. 
프로그램이라는 것이 데이터를 비즈니스 로직에 따라 가공해서 
보여주는 것이기 때문에 자료구조는 매우 활용도가 높다. 자바에서는 
다양한 컬렉션 프레임워크 클래스들을 제공해주는데 각 클래스의 
특징을 이해하고 용도에 맞는 컬렉션 API를 사용하는 것이 중용하다.


1. 컬렉션 프레임워크의 특징 

1.1 컬렉션 프레임워크 소개 

프로그래밍하면서 가장 쉽게 접할 수 있는 자료구조는 배열이다. 
하지만 배열은 너무 원시적이서 사용하기가 번거롭다. 예를들어
배열은 한번 크기가 정해지면 크기를 늘릴수 없고, 배열에 데이터가 
있는 상태에서 중간에 하나를 끼워 넣으면 끼워 넣으려는 자리의 
뒤쪽에 있던 자료들을 모두 한 칸씩 뒤로 움직여야 한다. 
마찬가지로 중간의 데이터를 지우려면 그 뒤쪽에 있던 자료들은 모두 
앞으로 한 칸씩 움직여야 한다. 

컬렉션 프레임워크는 기본적으로 이 배열을 확장해서 손쉽게 데이터를 
관리할수 있는 API를 제공해준다. 여기서 프레임워크란 잘 짜인 틀에
의해 만들어진 클래스들의 모임을 의미한다. 초창기 자바의 자료 구조는 
Vector, Stack, Hashtable, Properties 등이 있었다. 
이것들은 클래스 기반으로 연관 관계가 별로 없었다. 하지만 JDK 1.2 
버전 이후 등장한 컬렉션 프레임워크는 잘 짜인 인터페이스 기반의 관계를 
가지고 있기 때문에 몇 가지만 잘 익혀 놓으면 편하게 다양한 종류의 API를 
사용할 수 있다. 

컬렉션 프레임워크의 구성 

List->Collection->Iterable
Set->Collection->Iterable

3대 주요 인터페이스
List , Set , Map 

컬렉션 프레임워크는 크게 List, Set, Map 의 3가지 계열로 
구성된다. List와 Set은 Collection을 상속받았으므로 유사한 
메서드들이 사용된다. 
먼저 3가지 계열의 특징에 대해 알아보자. 

-List 계열 
List는 순서가 있는 데이터의 집합이다. 순서가 있기 때문에 
동일한 데이터의 중복이 허락된다. 동일 데이터의 값이라고 해도 
'몇 번째'라는 식으로 접근하면 찾을수 있기 때문이다. 
대표적인 List 계열의 구현체는 ArrayList나 
LinkedList, Stack , Vector가 있다. 

-Set 계열 
Set 은 순서를 유지하지 않는 데이터 집합이다. List 와 달리 
순서가 없기 때문에 '몇 번째'라는 말을 할수 없어 동일한 
데이터의 중복을 허락하지 않는다. 대표적인 Set 계열의 
구현체는 HashSet, TreeSet이 있다. 

-Map 계열 
Map 계열은 키와 값의 쌍으로 데이터를 관리하는 집합이다. 
이때 키는 중복되지 않고 값은 종복이 허락된다. 
대표적인 Map 계열의 구현체는 HashMap이나 TreeMap, Hashtable,
Properties가 있다. 

----------------------------------------------------
1.2 Collection 인터페이스

500 2/43

Collection 인터페이스는 List 와 Set 계열의 공통 조상으로 
다음의 메서드들이 정의되어 있다. 

Collection의 주요 메서드 

메서드 명 : 선언부와설명

add() : boolean add(E e)
요소 e를 컬렉션에 저장하고 성공 여부를 반환한다. 

addAll() : boolean addAll(Collection< ? extends E> c)
다른 컬렉션인 c의 모든 요소를 컬렉션에 추가하고 성공 여부를 
리턴한다. 

clear() : void clear()
컬렉션이 가지고 있는 모든 요소를 삭제한다. 

contains() : boolean contains(Object o)
컬렉션이 o 를 요소로 가지고 있는지 리턴한다. 

containsAll() : boolean containsAll(Collection<?> c)
다른 컬렉션인 c의 모든 요소가 컬렉션에 포함되어 있는지 
리턴한다.

equals() : boolean equals(Object o)
컬렉션과 o 가 같은 내용을 포함하고 있는지 비교하도록 재정의 
되었다. 

isEmpty() : boolean isEmpty()
컬렉션이 비어 있는지 확인한다. 

iterator() : IteratorFor<E> iterator()
컬렉션의 IteratorFor를 리턴한다. Iterator는 Collection에서 
자료를 조회하기 위한 표준 인터페이스이다. 

remove() : boolean remove(Object o)
컬렉션에서 o 를 제거하고 성공여부를 리턴한다. 

removeALl() : boolean removeAll(Collection<?> c)
다른 컬렉션인 c 의 모든요소를 컬렉션에서 제거하고 성공여부를 리턴한다. 

retainAll() : boolean retainAll(Collection<?> c)
다른 컬렉션 c에 포함된 객체는 남기고 다른 객체들은 제거한다. 
이 작업으로 컬렉션에 변화가 생기면 true, 그렇지 않으면 
false를 리턴한다. 

size() : int size()
컬렉션에 저장된 요소의 개수를 리턴한다. 

toArray() : Object[] toArray()
컬렉션의 요소들을 Object[] 형태로 리턴한다. 

<T> T[] toArray(T[] a)
컬렉션의 요소들은 T[] 형태로 리턴한다. 

Collection의 메서드들은 기능적으로 분류해보면 다음과 같다. 

분류 : Collection

추가 : add(E e) , addAll(Collection< ? extends E> c)

조회 : contains(Object o) , containsAll(Collection<?> c)
equals(), isEmpty(), iterator(), size()

삭제 : clear(), removeALl(Collection<?> c)
retainAll(Collection<?> c)

수정 : 없고 

기타 : toArray()

과거의 컬렉션 API들은 모든 요소를 원시 타입의 Object 형태로 저장했지만, 
8장에서 배운 제너릭 개념이 등장하는 JDK 5 버전부터는 타입 파라미터를 
이용하는 형태로 변경되었다. 


----------------------------------------------------
2. List 계열의 컬렉션 

2.1 List 인터페이스

List 계열은 순서, 즉 인덱스 기반으로 데이터를 저장한다.
실생활에서 List 가 적용된 예를 많이 생각해볼 수 있다. 
수첩에 해야 할 일들을 순서대로 적거나 은행에서 대기표를 
받아서 기다리기도 한다. 

List는 같은 데이터가 들어오더라도 인덱스를 이용해 구별할수 있어 
데이터의 중복이 허용되는 특징을 갖는다. 
여기서 같은 데이터라는 표현은 객체의 equals() 메서드가 
true를 리턴하고 객체가 갖는 hashCode() 값이 같을 때를 이야기한다. 
또한, List에는 null 값도 저장할 수 있다. 

다음은 n개의 문자열을 관리하는 List의 예를 살펴본것이다. 

0 : 0x100 -> Hi 
1 : 0x200 -> Hello 
2 : 0x200 -> Hello 
:
n-1 : null 

Collection 메서드의 기능별 분류 

위에 보면 인덱스는 0부터 n-1 까지 존재하며 각각의 인덱스에 관리하는 객체의 
참조값이 연결된다. 인덱스 1번과 2번의 'Hello'라는 문자열은 동일한 객체이지만 
중복해서 저장할수 있다. 

List 인터페이스는 Collection을 상속받았으며 추가로 인덱스를 사용할수 있는 
메서드들이 선언되어 있다. 

List 의 주요 메서드 

add() : void add(int index, E element)
index 위치에 element 를 저장한다. 

addAll() : boolean addAll(int index, Collection<? extends E> c)
index 위치부터 c의 요소들을 추가한다. 단 c는 E의 하위 요소들을 
저장하고 있어야 한다. 

get() : E get(int index)
index 위치에 저장된 요소를 리턴한다. 

indexOf() : int indexOf(Object o)
저장된 객체 o의 인덱스를 리턴한다. 동일한 객체가 여러개일 경우는 
맨 처음 발견한 객체의 인덱스를 리턴하고 객체가 없을 경우 -1이 
리턴된다. 

lastIndexOf() : int lastIndexOf(Object o)
List에 동일한 객체(o)가 여러 개 있을때 마지막 요소의 인덱스를 
리턴한다. 만약 객체가 없을 경우 -1을 리턴한다. 

listIterator() : ListIterator <E> listIterator()
List의 요소를 탐색할 수 있는 ListIterator를 리턴한다. 

remove() : E remove(int index)
index에 위치한 객체를 리스트에서 제거하고 리턴한다. 

set() : E set(int index, E element)
index의 요소를 element로 대체한다.

subList() : List<E> subList(int fromIndex, int toIndex)
fromIndex <= x < toIndex의 요소들로 구성된 새로운 List를 
리턴한다. 

List 까지 등장한 메서드를 기능적으로 분류하면 다음과 같다. 

분류 : Collection : List 

추가 :add (E e) : add (int index, E element)
추가 :addAll(Collection<? extends E> c) : 
addAll(int index, Collection<? extends E> c)

조회 : contains(Object o), containsAll(Collection<?> c)
, equals(), isEmpty(), iterator(), size()
: List 
get(int index) , indexOf(Object o), lastIndexOf(Object o)
listIterator()

삭제 : clear(), removeAll(Collection<?> c)
retainAll(Collection<?> c)
: List 
remove(int index)

수정 : 
List 
set(int index, E element)

기타 : toArray() : subList(int fromIndex, int toIndex)

List에서 범위를 넘어가는 인덱스를 사용하면 배열과 유사하게 
IndexOutOfBoundsException을 발생시킨다.

List 인터페이스의 구현체로는 Vector, Vector를 상속받은 
Stack, ArrayList , LinkedList 등이 있다. 

과거 버전 - List<E> 계열의 클래스 관계도 
Stack -> Vector ->List
ArrayList -> List 
LinkedList -> List 

이중 Vector와 Stack은 초창기부터 있던 버전이며 멀티스레드 환경에서 
안정적이지만 성능이 좋지 않다. 일반적으로는 ArrayList나 LinkedList를 
사용하는 것을 권장한다. 스레드와 관련된 내용은 14장에서 다룬다. 

----------------------------------------------------
2.2 ArrayList<E>

ArrayList<E>는 습관처럼 자주 사용되는 클래스로 활용도가 아주 높다. 
컬렉션 클래스들은 대부분 제너릭이 적용되어 있다. ArrayList<E>도 
예외는 아니므로 객체를 생성할 때 타입 파라미터를 넘겨주는 것이 좋다. 
또한, 객체를 참조할때 클래스를 이용한 참조보다는 인터페이스를 이용해서 
참조하는 것이 프로그램의 유연성을 좋게 한다. 

//원시 타입을 사용하는 형태 
List list = new ArrayList();

//제너릭을 적용한 형태 
List<String> strList = new ArrayList<>();

ArrayList에는 기본 생성자와 추가로 파라미터를 갖는 두개의 생성자를 
제공한다. 

public ArrayList()
public ArrayList(int initialCapacity)
public ArrayList(Collection<? extends E> c)

기본 생성자는 기본 용량이 0에서 시작한다. 반면 int를 받는 
생성자는 기본 용량을 파라미터인 initialCapacity로 잡는다. 
StringBuilder에서와 마찬가지로 크기와 용량은 다르다는 것의 유의하자.
컬렉션에서 '크기란(=size)', '실제로 관리하는 데이터의 크기'이다. 
반면 '용량(capacity)'은 '몇개까지 데이터를 관리할수 있는가?'와 
관련된다. 

생성자 중 int를 파라미터로 받는 생성자를 분석해 보면 ArrayList의
정체를 명확히 알수있다.

ex)
public ArrayList(int initialCapacity){
if (initialCapacity > 0) {
this.elementData = new Object[initialCapacity];
}else if (initialCapacity == 0) {
this.elementData = EMPTY_ELEMENTDATA;
}else {
throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
}
}

생성자를 통해 전달된 값은 내부적으로 elementData, 즉 
Object[]의 length로 사용된다. 이 elementData는 ArrayList<E>에서 
객체를 저장할수 있는 배열이다. ArrayList는 Array 즉 배열을 이용한 
List 인것이다. 

배열의 특징 중 하나가 한 번 결정된 크기는 변경이 불가능하다는 점이다. 
ArrayList도 배열을 기반으로 만들어졌지만, 용량과 상관없이 add()를 호출하면 
데이터는 잘만 들어간다. 이 비밀은 add()가 호출될 때 내부적으로 호출되는 
grow()의 소스를 살펴보면 쉽게 풀린다. 
다음 코드를 보면  grow()는 Arrays.copyOf()를 이용해서 기존 작은 배열인 
elementData를 newCapacity 용량의 큰 배열로 대체하는 것을 볼수 있다. 

ex)
private void grow(int minCapacity) {
int oldCapacity = elementData.length; // 기존 배열의 크기 
int newCapacity = oldCapacity + (oldCapacity >> 1);
if (newCapacity - minCapacity < 0)
newCapacity = minCapacity;
//-------------------------------------------------------
if ( newCapacity - MAX_ARRAY_SIZE > 0)
newCapacity = hugeCapacity(minCapacity); //필요한 배열의 크기 
elementData = Arrays.copyOf(elementData, newCapacity); 
//---------------------------------------- 큰 배열로 대체 
}

다음은 ArrayList<E>를 이용한 자료 처리의 예.

ex)
package ch13.list;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ArrayListTest {
	List<Object> list = new ArrayList<>();
	
	List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5);

	public void createTest() {
		list.add("Hello");
		list.add("Hello"); // 동일 데이터 추가
		list.add(null); // null 추가
		list.addAll(integers); // 다른 Collection 요소 추가
		list.add(integers); // 다른 Collection 추가
		list.add(0, new Object()); // 끼워 넣기
		System.out.println("추가 후 내용 출력: " + list);
	}

	public void retrieveTest() {
		// 반복을 이용한 요소 조회
		for(int i=0; i<list.size(); i++) {				// 리스트의 크기 조회
			System.out.println(i+" : "+list.get(i));	// 특정 인덱스의 객체 조회
		}
		// 포함 여부의 활용
		if (list.contains("Hello")) {	// 객체의 포함 여부 
			System.out.println("Hello의 위치는: " + list.indexOf("Hello"));	// 객체의 위치 조회
		}
		// 서브 리스트 활용
		List<Object> sub = list.subList(3, 5);
		System.out.println("sub의 내용: "+sub);
		System.out.println("sub의 내용을 다 가지고 있는가? " + list.containsAll(sub));
	}

	public void updateTest() {
		list.set(1, "updated");
		System.out.println("업데이트 후: "+list);
	}

	public void deleteTest() {
		list.remove(0);			// 특정 위치의 객체 삭제
		list.remove("Hello");	// 특정 객체가 있다면 처음 객체 삭제
		// 타입이 Integer인 경우 삭제
		for (int i = 0; i < list.size(); i++) {
			if (list.get(i) instanceof Integer) {
				list.remove(i);
			}
		}
		// Iterator 추가해서 해보기
		// Iterator<Object> iter = list.iterator();
		// while (iter.hasNext()) {
		// 처음 부터 끝까지 한번에 하나씩 밖에 못가져온다. 
		// (1) hasNext() : 다음요소에 읽어 올 요소가 있는지?> 확인하는 메소드
		// 있으면 true 없으면 false 를 반환. 
		// next() : 다음 요소를 가져온다. 
		// remove() : next() 로 읽어온 요소를 삭제한다. 
		//	Object s = iter.next();
		//	if (s instanceof Integer) {
		//		iter.remove();
		//	}
		//  }
		// 그러면 정수는 다 삭제 됨. 
		System.out.println("삭제 후 : " + list);
		list.clear();// 리스트 초기화
		System.out.println("초기화 후 : " + list);
	}

	public static void main(String[] args) {
		ArrayListTest alt = new ArrayListTest();
		alt.createTest();
		alt.retrieveTest();
		alt.updateTest();
		alt.deleteTest();
	}
}
//
추가 후 내용 출력: 
[java.lang.Object@2c13da15, Hello, Hello, null, 1, 2, 3, 4, 5, [1, 2, 3, 4, 5]]
0 : java.lang.Object@2c13da15
1 : Hello
2 : Hello
3 : null
4 : 1
5 : 2
6 : 3
7 : 4
8 : 5
9 : [1, 2, 3, 4, 5]
Hello의 위치는: 1
sub의 내용: [null, 1]
sub의 내용을 다 가지고 있는가? true
업데이트 후: [java.lang.Object@2c13da15, updated, Hello, null, 1, 2, 3, 4, 5, [1, 2, 3, 4, 5]]
삭제 후 : [updated, null, 2, 4, [1, 2, 3, 4, 5]]
초기화 후 : []

----------------------------------------------------
2.3 배열과 ArrayList, LinkedList의 특징 

508 10/43

배열은 우리가 알고 있는 가장 기본적인 형태의 자료 구조로 인덱스를 기반으로 
하는 구조가 간단하고 배열 내부에서의 접근 속도가 매우 빠르다. 

반면 배열은 크기를 변경할 수 없고 기존 배열의 크기보다 더 많은 데이터를 
추가하기 위해서는 새로운 배열을 만들고 기존 값들을 복사해야 한다. 
또한, 비순차적인 데이터의 추가, 삭제에는 더 많은 시간이 걸린다. 

예를들어 0~4까지의 index를 가진 배열이 있다고 할 때 1번 인덱스 요소를 
빼고 2와 3사이에 5라는 값을 끼워 넣는다고 생각해보자. 

일단 1번 데이터가 없어지며 뒤에 있던 2,3,4 번은 앞으로 한자리씩 
이동한다. 5가 새로 추가되기 위해서는 3,4 번이 다시 뒤로 움직여야 한다.

배열을 기반으로 하는 ArrayList도 태생적으로 배열의 장단점을 그대로 가질 수 
밖에 없다. 

이런 불합리성을 개선하기 위해 등장한 또 다른 리스트가 있는데 바로 
LinkedList<E> 이다. LinkedList는 각 요소를 Node(노드)로 정의하며
Node는 다음 요소의 참조값과 데이터로 구성된다. 
각 Node는 다음 Node에 대한 링크 정보를 가지며 데이터를 연속으로 
구성할 필요가 없어진다. 
ex)
LinkedList
      ->0x100 -> 0x200 ->0x500 -> 0x600 
0x100 ->0x200 -> 0x500 ->0x600 -> null 
         0          1       2        3
		 	 
위와 같은 자료 구조에서 만약 1을 삭제하고 2와 3사이에 4를 
추가한다면 어떻게 될까?

ex2)
LinkedList 에서의 추가와 삭제 
0x100 -> 
0x100 : 0x200 (->0x500으로 변경) :0
0x200 -> 0x500 : (삭제) :1
0x500 -> 0x600 : (->0x700 으로 변경) :2
0x700 -> 0x600 : (추가) :4
0x600 -> : null : 3

509 11/43

위에서 1을 삭제하려면 1을 참조하던 0번의 참조 링크를 
0x500으로 바꾸기만 하면된다. 이제 0x200번지는 G.C의 
대상이 될것이다. 2와 3사이에 4를 넣기 위해서는 3을 
바라보던 2의 링크를 새로운 4를 바라보도록 하고 4가 3을
바라보도록  링크를 조절하기만 하면 끝이다. 
ArrayList가 전체적으로 요소들이 움직였던 것에 비해 
훨씬 가볍게 동작한다. 

이제 LinkedList를 사용해보기 위해 LinkedList의 API를 
다시 알아봐야 할까? 결론은 거의 그렇지 않다. 앞선 예제에서 
ArrayList를 테스트할 때 코드에는 ArrayList가 객체 생성할 때 
말고는 나온 적이 없다. 단지 List의 메서드들을 사용했고 
LinkedList 역시 List의 구현체이므로 객체 생성부분만 바꾸면 
ArrayList에서 LinkedList로 대체된다. 이것이 인터페이스를
이용했을 때의 장점이다. 

ex) 
//List 의 구현체로 ArrayList 사용 
List<Object> list = new ArrayList<>(); 
//List 의 구현체로 LinkedList 사용 
List<Object> list = new LinkedList<>();

ArrayList와 LinkedList를 썼을때 성능상에 어떤 차이가 있는지 
알아보자. 다음 예제에는 ArrayList와 LinkedList를 이용해 
순차적/비순차적 데이터 검색과 추가 과정을 거쳐 성능을 확인한다. 

ex)
package ch13.list;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ArrayVsLinkedTest {
	private static void addTest(String testcase, List<Object> list) {
		long start = System.nanoTime();
		for (int i = 0; i < 1000000; i++) {
			list.add(new String("Hello"));
		}
		long end = System.nanoTime();
		System.out.println(testcase + " 소요시간 : " + (end - start));
	}

	private static void addTest2(String testcase, List<Object> list) {
		long start = System.nanoTime();
		for (int i = 0; i < 100000; i++) {
			list.add(0, new String("Hello"));
		}
		long end = System.nanoTime();
		System.out.println(testcase + " 소요시간 : " + (end - start));
	}

	private static void accessTest(String testcase, List<Object> list) {
		long start = System.nanoTime();
		for (int i = 0; i < 100000; i++) {
			list.get(i);
		}
		long end = System.nanoTime();
		System.out.println(testcase + " 소요시간 : " + (end - start));
	}

	public static void main(String[] args) {
		ArrayList<Object> alist = new ArrayList<Object>();
		LinkedList<Object> llist = new LinkedList<Object>();

		addTest("순차적 추가: ArrayList", alist);
		addTest("순차적 추가: LinkedList", llist);

		addTest2("중간에 추가: ArrayList", alist);
		addTest2("중간에 추가: LinkedList", llist);

		accessTest("데이터 접근: ArrayList", alist);
		accessTest("데이터 접근: LinkedList", llist);
	}
}
//
순차적 추가: ArrayList 소요시간 : 93209700
순차적 추가: LinkedList 소요시간 : 154365000
중간에 추가: ArrayList 소요시간 : 109729447400
중간에 추가: LinkedList 소요시간 : 5186700
데이터 접근: ArrayList 소요시간 : 3905700
데이터 접근: LinkedList 소요시간 : 15382276300
시간이 조금 걸림 

둘의 성능을 표로 비교하면 다음과 같다. 

구분 : 순차 추가/수정/삭제 : 비순차 추가/수정/삭제 : 조회 

ArrayList : 빠름 : 느림 : 빠름 
LinkedList : 느림 : 빠름 : 느림 

소량의 데이터를 가지고 사용하는 경우에는 차이가 없지만, 일반적으로
데이터를 정적으로 사용할 경우, 즉 단순 조회용인 경우는 ArrayList가 
유리하고 반대로 동적인 추가/삭제가 많은 경우는 LinkedList가 유리하다. 

결론적으로 특정 클래스가 좋고 나쁨은 없다. 용도에 적합하게 사용해야 한다. 

----------------------------------------------------
2.4 정렬 

많은 요소 중에서 데이터를 찾다 보면 정렬을 통해 순서를 지정할 필요가 있다. 
이때 Collection 의 sort() 메서드가 사용된다. 

정렬을 위한 Collection의 sort() 

메서드명 : 선언부와설명
sort() : public static < T extends Comparable<? super T>> void sort(List<T> list)
기본 정책에 의해서 list의 요소를 정렬한다. 

public static <T> void sort(List<T> list, Comparable<? super T> c)
c에 의거해서 list의 요소를 정렬한다. 

첫번째 sort() 메서드에는 타입 파라미터가 복잡하게 설정돼 있는데 2단계로 
살펴보자. 먼저 메서드 레벨에 선언된 T는 Comparable을 상속받아야 하고 
메서드의 파라미터로 T가 타입 파라미터로 전달된 List가 필요하다. 
다음으로 Comparable은 클래스 레벨에 타입 파라미터가 있으며 T의 조상이 
설정돼야 한다. 예를 들어 Integer나 String 같은 클래스가 T의 좋은 
예가 될수 있다. 

ex)
public final class Integer extends Number implements Comparable<Integer> {}
public final String implements java.io.Serializable, Comparable<String>,
CharSequence{}

Comparable은 객체를 비교할 수 있는 기준인 compareTo() 메서드가 선언돼 있고 
String이나 Integer는 각각 사전 순으로 요소를 정렬하도록 구현돼 있다. 
그런데 만약 사전 순이 아니라 자리수를 기준으로 정렬하려면 어떻게 해야 
할까? String은 final 클래스 이므로 compareTo()를 재정의 할수 도 없는 일이다. 

이때는 두번째 sort() 메서드를 사용한다. 이 메서드는 호출할 때마다 
Comparator<T> 타입의 객체를 넘겨주면 된다. 

Comparator는 compare() 메서드를 통해 정렬의 방식을 결정한다. 
compare()는 T 타입의 객체 두개를 받아서 정렬을 위한 알고리즘을 
작성한다. 

ex)
public int compare ( T o1 , T o2)

Comparable의 compareTo()나 Comparator의 compare() 모두 int를 
리턴하는데 양수가 리턴되면 순서가 바뀌어야 하고, 음수가 리턴되면
순서를 그대로 유지한다. 0이 리턴 될 때 List<E> 계열에서는 
음수처럼 순서를 유지한다. 하지만 뒤에 살펴볼 TreeSet<E>
계열에서는 다르다. 

다음은 문자열의 길이를 비교하는 Comparator<E> 의예이다.

ex)
package ch13.list;

import java.util.Comparator;

public class StringLengthComparator implements Comparator<String> {
	@Override
	public int compare(String o1, String o2) {
		int len1 = o1.length();
		int len2 = o2.length();
		return len1 - len2;
	}
}

다음은 위의 StringLengthComparator를 이용해서 정렬을 처리하는 
예이다. 

ex2)
package ch13.list;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ListSortTest {
	public static void main(String[] args) {
		List<String> names = Arrays.asList("토르", "캡틴아메리카", "스파이더맨", "아이언맨");
		Collections.sort(names);
		System.out.println("알파벳 순 정렬 결과: "+names);
		Collections.sort(names, new StringLengthComparator());
		System.out.println("글자수 정렬 결과: "+names);
	}
}
//
알파벳 순 정렬 결과: [스파이더맨, 아이언맨, 캡틴아메리카, 토르]
글자수 정렬 결과: [토르, 아이언맨, 스파이더맨, 캡틴아메리카]

주의,

Comparator의 compare()를 재정의할 때 상황에 따라 주의해야 한다. 
다음과 같이 구현하면 어떨까?

ex)
public int compare(Integer num1, Integer num2) {
return num1 - num2;
}

아주 간단히 num1과 num2를 정렬하는 메서드처럼 보인다. 하지만, 
만약 num1이 int의 최댓값이고 num2가 음수라면 어떤 결과가 발생할까?
정수의 오버플로가 발생해서 예상치 못했던 정렬 결과가 나올 것이다. 
따라서 위 코드는 다음과 같이 변경하는 것이 좋다. 

ex2)
public int compare(Integer num1, Integer num2){
if(num1 > num2) {
return 1;
}else if(num1 < num2){
return -1;
}else{
return 0;
}
}

물론 StringLengthComparator는 문자열의 길이가 
음수일 경우는 없기 때문에 상관없다. 

----------------------------------------------------
2.5 List<E>를 이용한 로또 게임 

List<E>의 특성을 이용해서 로또 게임을 만들어보자. 
로또는 1~45까지의 숫자가 적힌 공 중에서 당첨 공 6개와 
보너스 공 1개를 뽑는다. 이 공들은 중복되어 뽑힐 수 없는 
점만 주의하면 된다. 

ex)

package ch13.list;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

class ListLotto {
	Integer bonus;
	List<Integer> lotto = new ArrayList<>();

	public void setup() {
		Random random = new Random();
		while (bonus==null) {
			int num = random.nextInt(45) + 1;
			if (!lotto.contains(num)) {
				if (lotto.size() < 6) {
					lotto.add(num);
				} else {
					bonus = num;
				}
			}
		}
		Collections.sort(lotto);
	}
	
   //객체의 내용을 출력하도록  toString()을 재정의 
   
	@Override
	public String toString() {
		return "당첨번호: " + lotto + ", 보너스: " + bonus;
	}
}

public class ListLottoTest {

	public static void main(String[] args) {
		ListLotto lotto = new ListLotto();
		lotto.setup();
		System.out.println(lotto);
	}
}
// Random 객체를 이용하므로 결과는 매번 다름 
당첨번호: [2, 19, 31, 32, 33, 44], 보너스: 21


----------------------------------------------------
3. Set 계열의 컬렉션 

3.1 Set 인터페이스

Set 계열은 주머니에 순서 없이 데이터를 넣는 형태이다. Set은 순서가 
없어서 리스트와 달리 동일한 데이터가 들어오게 되면 객체들을 구별할수가
없다. 따라서 데이터의 종복을 허용하지 않으며 이것은 효율적인 종복 데이터 
제거 수단이 된다. 이때 동일한 데이터인지 판단 여부는 equals() 메서드의 
리턴값이 true이고 hashCode() 값이 같은 객체를 이야기한다. 

ex)
0x100 -> Hi 
0x200 -> Hello 
null 

Hello -> .. : 올수 없다. 

Set 계열의 데이터 저장 

Set 계열에는 가장 많이 사용되는 형태인 HashSet 과 정렬 기능을 내장하고 
있는 TreeSet 이 있다. 

ex) Set 계열의 클래스 관계도 
HashSet -> Set 
TreeSet -> NavigableSet -> SortedSet -> Set

Set 계열은 인덱스가 없기 때문에 위치 기반으로 데이터를 가져올수 없다. 
Set이 가진 요소의 목록을 사용하기 위해서는 iterator()가 반환하는 
Iterator 객체를 사용한다. 
Iterator는 Collection에 저장된 요소에 접근하기 위해 사용하며, 표준 인터페이스로 
데이터를 읽는 방법을 제시한다. 

Iterator의 주요 메서드 

메서드명 : 선언부와설명

hasNext() : boolean hasNext()
가져올 다음 요소가 있는지 여부를 리턴한다. 

next() : E next()
가져올 다음 요소가 있다면 그 요소를 리턴한다

remove() : void remove()
현재 위치의 요소를 삭제한다. 

다음 예는 Set에서 Iterator를 획득 후 Set의 내용을 출력하는 
방식을 보여준다. 

ex)
Iterator<Object> iter = set.iterator();
while (iter.hasNext()){
Object obj = iter.next();
System.out.println(obj);
}

또는 간단히 인덱스를 사용하지 않는 for ~ each문을 이용할수도 있다. 

for (Object sobj : set) {
System.out.println(sobj);
}

어느 모로 보나, 향상된 for 문의 형태가 훨씬 간단하다. 
하지만 Iterator를 이용하는 문도 활용도가 있기 때문에 
기억해 두도록 하자. 

참고로 이 Iterator는 단방향으로만 사용된다. Iterator를 상속받은 
ListIterator는 양방향으로 사용이 가능한데 hasPrevious()와 
previous() 메서드가 제공된다. 단, ListIterator는 List 계열에서만 
사용이 가능하다. 

ListIterator가 추가로 갖는 메서드 

메서드명 : 선언부와설명

hasPrevious() : boolean hasPrevious()
가져올 이전 요소가 있는지 여부를 리턴한다. 

previous() : E previous()
가져올 이전 요소가 있다면 그 요소를 리턴한다. 

remove() : void remove()
현재 위치의 요소를 삭제한다. 


----------------------------------------------------
3.2 HashSet<E>

Set<E>의 대표적 구현체인 HashSet<E>을 이용한 자료 관리를 예제를 통해 
알아보자. 이 예제에서는 Phone이라는 사용자 정의 클래스를 HashSet에 
추가해보고 중복 데이터가 어떻게 제거되는지 살펴보자. 

Phone 클래스는 String 타입의 number가 선언된 아주 간단한 클래스이다. 
현실 세계에서 전화번호는 하나만 존재하는데, 즉 같은 전화번호는 없다. 
Set<E>에서는 어떨지 알아보자. 

ex)
package ch13.set;

public class Phone {
	String number;

	public Phone(String number) {
		this.number = number;
	}

	@Override
	public String toString() {
		return "전화 번호: " + this.number;
	}
}

본격적으로 HashSet<E>에 데이터를 추가/조회/수정/삭제해보자. 
List<E> 계열과 비교하여 특이한 점은 수정하는 메서드가 없다는 점이다. 
List<E>는 인덱스 위치의 요소를 수정했지만, Set<E>계열에서는 
인덱스가 없기 때문에 수정이 불가능하다. 인덱스를 사용하지 않는 
나머지 메서드들은 어차피 Collection<E> 을 구현한 것이기 때문에 
동일하게 사용할수 있다. 

ex2)
package ch13.set;

import java.util.HashSet;
import java.util.Set;

public class HashSetTest {
	Set<Object> hset = new HashSet<Object>();

	private void addMethod() {
		this.hset.add(Integer.valueOf(1));
		this.hset.add("Hello");
		this.hset.add("Hello");
		this.hset.add(null);
		this.hset.add(1);
		this.hset.add(new Phone("010-000-1234"));
		this.hset.add(new Phone("010-000-1234"));
		System.out.println("데이터 추가 결과: " + this.hset);
	}

	private void retrieveMethod() {
		System.out.println("데이터 개수: " + this.hset.size());

		for (Object sobj : this.hset) {
			System.out.println("데이터 조회: " + sobj);
		}
	}

	private void removeMethod() {
		this.hset.remove("Hello");
		System.out.println("데이터 삭제 결과: " + this.hset);
	}

	public static void main(String[] args) {
		HashSetTest hst = new HashSetTest();
		hst.addMethod();
		hst.retrieveMethod();
		hst.removeMethod();
	}
}
//
데이터 추가 결과: [null, 1, Hello, 전화 번호: 010-000-1234, 전화 번호: 010-000-1234]
데이터 개수: 5
데이터 조회: null
데이터 조회: 1
데이터 조회: Hello
데이터 조회: 전화 번호: 010-000-1234
데이터 조회: 전화 번호: 010-000-1234
데이터 삭제 결과: [null, 1, 전화 번호: 010-000-1234, 전화 번호: 010-000-1234]

출력된 결과를 살펴보면 두 가지 흥미로운 점이 있다. 
첫째는 Integer.valueOf(1)과 1, "Hello"와 "Hello"는 중복된 데이터로 
간주되어 출력 결과에는 하나만 존재한다. 하지만, Phone 객체는 2개가 
다 들어 있음을 알수 있다. 
둘째는 출력된 요소의 순서이다. 기본적으로 Set<E>에 add()한 순서가 
아닐 뿐 아니라 실행할 때마다 다른 결과가 나올 수도 있다. 

String이나 Integer 등은 중복되는 데이터가 잘 제거 되었지만, 
Phone은 그렇지 못했다. Set<E>이 number가 같은 Phone 객체를 중복 
데이터로 간주해서 하나만 관리하도록 처리해보자. 
Set<E>에서 두 객체가 '같다'라는 평가는 
equals()의 결과 true가 리턴되는 것과 함께 추가로 hashCode()의 
결과가 같아야 한다. 
다음과 같이 Phone을 수정한 Phone2를 이용해 테스트를 해보자. 
참고로 equals()와 hashCode()의 재정의는 소스파일에서 
마우스 오른쪽 버튼을 클릭하여 단축 메뉴에서 
[Source]->[Generate]->[hashCode() and equals()]
를 이용한다. 

ex)
package ch13.set;

public class Phone2 {
	String number;
	Integer price;

	public Phone2(String number, Integer price) {
		this.number = number;
		this.price = price;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((number == null) ? 0 : number.hashCode());
		result = prime * result + ((price == null) ? 0 : price.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Phone2 other = (Phone2) obj;
		if (number == null) {
			if (other.number != null)
				return false;
		} else if (!number.equals(other.number))
			return false;
		if (price == null) {
			if (other.price != null)
				return false;
		} else if (!price.equals(other.price))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "SamePhone [number=" + number + ", price=" + price + "]";
	}
}
//
이클립스에서 제공하는 소스 코드 생성기능을 사용하면 hashCode()와 
equals()를 함께 재정의하도록 메뉴가 구성된 이유도 두 메서드가 다 
재정의되어야 함을 암시한다. 

ex)
package ch13.set;

import java.util.HashSet;
import java.util.Set;

public class PhoneTest {
	public static void main(String[] args) {
		Set<Phone2> pSet = new HashSet<>();
		pSet.add(new Phone2("010", 2000));
		pSet.add(new Phone2("010", 2000));
		pSet.add(new Phone2("011", 3000));
		pSet.add(new Phone2("011", 3000));
		pSet.add(new Phone2("011", 1000));
		System.out.println("set의 크기: " + pSet.size());
		for(Phone2 phone: pSet) {
			System.out.println(phone);
		}
	}
}
//
set의 크기: 3
SamePhone [number=010, price=2000]
SamePhone [number=011, price=3000]
SamePhone [number=011, price=1000]

----------------------------------------------------
3.3 Set<E>의 정렬과 TreeSet<E> 

522 24/43

----------------------------------------------------
3.4 TreeSet<E> 을 이용한 로또 게임 

----------------------------------------------------
4. Map 계열의 컬렉션

4.1 Map 인터페이스

----------------------------------------------------
4.2 HashMap<K, V>

----------------------------------------------------
4.3 TreeMap<K, V>를 이용한 정렬 

----------------------------------------------------
4.4 HashMap<K, V>을 이용한 로또 게임

----------------------------------------------------
4.5 Propertie<K, V>

===================================
[자바 해바라기 정리] 14 멀티스레드 프로그래밍

1. 멀티스레드 프로그래밍

1.1 스레드 와 프로세스 

----------------------------------------------------
1.2 멀티스레드 프로그래밍 의 장/단점 

----------------------------------------------------
2. 스레드 생성과 수행

2.1 스레드 생성 

----------------------------------------------------
2.2 스레드의 실행 

----------------------------------------------------
3. 스레드의 상태와 제어 

3.1 스레드의 상태 

----------------------------------------------------
3.2 스레드 선택과 우선순위

----------------------------------------------------
3.3 sleep()을 통한 상태 제어 

----------------------------------------------------
3.4 join() 을 통한 상태 제어 

----------------------------------------------------
3.5 interrupt()를 통한 대기 풀 탈출 

----------------------------------------------------
3.6 yield()를 통한 상태 제어 

----------------------------------------------------
3.7 스레드의 종료 

----------------------------------------------------
3.8 데몬 스레드

----------------------------------------------------
4. 멀티스레드 의 문제점과 해결 

4.1 데이터 공유와 동기화 문제 

----------------------------------------------------
4.2 공유 데이터의 동기화 처리 

----------------------------------------------------
4.3 wait() 아 notify(), notifyAll()

----------------------------------------------------
4.4 멀티스레드 와 컬렉션

----------------------------------------------------
5. 스레드 풀(Thread Pool) 활용 

5.1 스레드 풀의 개념 

----------------------------------------------------
5.2 스레드 풀의 사용 


===================================
[자바 해바라기 정리] 15 Input-Output 

1. I-O 와 스트림 

1.1 스트림의 개념 

----------------------------------------------------
2. 노드 스트림

2.1 키보드를 이용한 InputStream 과 Reader 

----------------------------------------------------
2.2 모니터를 이용한 OutputStream 과 Writer 

----------------------------------------------------
2.3 메모리 기반의 입/출력 처리 

----------------------------------------------------
2.4 파일 기반의 입/출력 처리 

----------------------------------------------------
2.5 다른 스레드와의 통신을 위한 스트림 

----------------------------------------------------
3. 보조 스트림 

3.1 보조 스트림의 개념과 종류 

----------------------------------------------------
3.2 byte 기반 스트림을 char 기반 스트림으로 변경하는 스트림 

----------------------------------------------------
3.3 버퍼를 이용하는 성능 향상 스트림

----------------------------------------------------
3.4 기본 데이터형 전송을 위한 스트림 

----------------------------------------------------
3.5 객체 저장을 위한 스트림 

----------------------------------------------------
4 NIO(New Input Output) 

4.1 NIO 의 특징 

----------------------------------------------------
4.2 Path 와 Files 

----------------------------------------------------
4.3 Buffer 

----------------------------------------------------
4.4 FileChannel 


===================================
[자바 해바라기 정리] 16 스트림 API

1. 스트림 API 소개 

1.1 스트림 API 의 주요 역할과 특징 

----------------------------------------------------
2. 스트림 API 자료 처리 

2.1 스트림 API의 종류와 획득 

----------------------------------------------------
2.2 맵/리듀스(Map/Reduce) 모델 지원 

----------------------------------------------------
3. 중간 처리 

3.1 필터링 

----------------------------------------------------
3.2 자르기 

----------------------------------------------------
3.3 정렬 

----------------------------------------------------
3.4 매핑(변환)

----------------------------------------------------
3.5 조회(주석)

----------------------------------------------------
4. 최종 처리 

4.1 매칭

----------------------------------------------------
4.2 집계

----------------------------------------------------
4.3 반복 

----------------------------------------------------
4.4 조사 

----------------------------------------------------
4.5 수집 

----------------------------------------------------
5. 병렬 스트림

5.1 병렬 처리의 정의와 병렬 스트림 생성 

----------------------------------------------------
5.2 병렬 스트림 사용

----------------------------------------------------
5.3 병렬 스트림 사용 시 주의점 

------------------------------------------------------
[자바 커피 정리]


